# s11.py
# ================================================================================
# BOOST SOFTWARE LICENSE
#
# Copyright 2020 BitWise Laboratories Inc.
# Original Author.......Jim Waschura
# Contact...............info@bitwiselabs.com
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
# ================================================================================
import datetime
import math
import os
import numpy
from PyQt5 import QtWidgets
from PyQt5.QtWidgets import QVBoxLayout, QApplication, QMainWindow

from matplotlib import pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
# from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
from popup import Popup
from connect import Connect
from tdr import Tdr


class S11(Tdr):

    def __init__(self, mainWindow: QMainWindow):
        super().__init__(mainWindow)
        # print("S11::__init__()")

        # Establish event handlers

        self.buttonS11Refresh.clicked.connect(self.buttonS11Refresh_clicked)
        self.buttonS11Clear.clicked.connect(self.buttonS11Clear_clicked)
        self.buttonS11RunSingle.clicked.connect(self.buttonS11RunSingle_clicked)
        self.buttonS11ResetView.clicked.connect(self.buttonS11ResetView_clicked)
        self.buttonS11SaveResults.clicked.connect(self.buttonS11SaveResults_clicked)

        # Initialize results variables

        self.S11LogFileContents = None
        self.S11ResultsDateTime = None

        self.S11chartFigure = plt.figure()
        self.S11chartFigure.set_tight_layout(True)
        self.S11chartCanvas = FigureCanvas(self.S11chartFigure)
        # self.chartToolbar = NavigationToolbar(self.S11chartCanvas, mainWindow)

        vLayout = QVBoxLayout()
        vLayout.addWidget(self.S11chartCanvas)
        # vLayout.addWidget(self.chartToolbar)
        self.S11ChartLayout.addLayout(vLayout)
        self.S11currentPlot = None
        self.S11currentShadowPlot = None

        self.S11shadowFigure = plt.figure()
        self.S11shadowFigure.set_tight_layout(True)
        self.S11shadowCanvas = FigureCanvas(self.S11shadowFigure)

    def buttonS11Refresh_clicked(self):
        # print("S11::buttonS11Refresh_clicked")
        try:
            self.refreshResults(0x2)
        except Exception as e:
            Popup.error(str(e))

    def buttonS11Clear_clicked(self):
        # print("S11::buttonS11Clear_clicked")
        try:
            Connect.getDevice().App.Stop()
            Connect.getDevice().App.setTab("S11")
            Connect.getDevice().Clear()
            self.refreshResults(0x2)
        except Exception as e:
            Popup.error(str(e))

    def buttonS11ResetView_clicked(self):
        # print("S11::buttonS11ResetView_clicked")
        try:
            Connect.getDevice().App.Stop()
            Connect.getDevice().App.setTab("S11")
            Connect.getDevice().S11.Reset()
            Connect.getDevice().WaitForRunToStart()
            Connect.getDevice().WaitForRunToComplete(120.0)
            self.refreshResults(0x2)
        except Exception as e:
            Popup.error(str(e))

    def buttonS11SaveResults_clicked(self):
        # print("S11::buttonS11SaveResults_clicked")

        try:
            # ensure directories exist
            self.ensureDirectoriesExist()

            # if results subdirectory doesn't exist, create it
            results_subdir = os.path.normpath(
                self.editDataDirectory.text().strip() + "/" + self.editResultsName.text().strip())
            # print("results_subdir is: " + results_subdir)

            if not os.path.exists(results_subdir):
                os.mkdir(results_subdir)

            name_nospace = self.editResultsName.text().strip().replace(" ", "_")

            if self.S11ResultsDateTime is None:
                self.S11ResultsDateTime = datetime.datetime.now()

            dt_string = self.S11ResultsDateTime.strftime("_%Y-%m-%d_%Hh%Mm%Ss")
            chart_file_name = os.path.normpath(results_subdir + "/" + name_nospace + "_S11_Chart" + dt_string + ".png")
            csv_file_name = os.path.normpath(results_subdir + "/" + name_nospace + "_S11_Csv" + dt_string + ".csv")
            pivot_file_name = os.path.normpath(results_subdir + "/" + name_nospace + "_S11_Pivot"+ dt_string + ".csv")
            # print("chart_file_name is: " + chart_file_name)
            # print("csv_file_name is: " + csv_file_name)

            # retrieve CSV file and store in results subdirectory

            if self.checkSaveCSV.isChecked():
                Connect.getDevice().App.Stop()
                Connect.getDevice().App.setTab("S11")
                try:
                    csv_remote_file = Connect.getDevice().S11.FileSave()
                    # print("csv remote file is: ", csv_remote_file)

                    csv_file_contents = Connect.getDevice().File.Fetch(csv_remote_file).decode(encoding='utf-8')
                    f = open(csv_file_name, "w")
                    f.write(csv_file_contents)
                    f.close()

                except Exception as e:
                    print("problem saving CSV file")
                    raise e

            # save Pivot log file in results subdirectory

            if self.S11LogFileContents is not None:
                try:
                    f = open(pivot_file_name, "w")
                    f.write(self.S11LogFileContents)
                    f.close()
                except Exception as e:
                    print("Problem saving pivot file: ", e)
                    raise e

            # save current chart in results subdirectory

            if self.checkSaveCharts.isChecked():
                if self.S11currentShadowPlot is not None:
                    self.S11shadowFigure.savefig(chart_file_name,
                                                 dpi=300,
                                                 format="png",
                                                 pad_inches=0.5,
                                                 orientation='portrait',
                                                 papertype="letter",
                                                 edgecolor="black")
            Popup.info("S11 results saved to: " + results_subdir, "Save S11 Results")
                
        except Exception as e:
            Popup.error(str(e))

    def buttonS11RunSingle_clicked(self):
        # print("S11::buttonS11RunSingle_clicked")
        try:
            Connect.getDevice().App.Stop()
            Connect.getDevice().App.setTab("S11")

            self.buttonS11RunSingle.setEnabled(False)
            self.buttonS11Refresh.setEnabled(False)
            self.buttonS11ResetView.setEnabled(False)
            self.buttonS11SaveResults.setEnabled(False)
            self.buttonS11Clear.setEnabled(False)

            QApplication.processEvents()

            Connect.getDevice().RunSingle()
            Connect.getDevice().WaitForRunToComplete(120.0)
            self.refreshResults(0x2)

        except Exception as e:
            Popup.error(str(e))

        finally:
            self.buttonS11RunSingle.setEnabled(True)
            self.buttonS11Refresh.setEnabled(True)
            self.buttonS11ResetView.setEnabled(True)
            self.buttonS11SaveResults.setEnabled(True)
            self.buttonS11Clear.setEnabled(True)
        pass

    # override
    def editResultsName_editingFinished(self):
        super().editResultsName_editingFinished()
        # print("S11::editResultsName_editingFinished()")

        if self.S11currentPlot is not None:
            self.S11currentPlot.set_title(
                "S11" if self.editResultsName.text() == "" else (self.editResultsName.text() + "\nS11"))
            self.S11chartCanvas.draw()

        if self.S11currentShadowPlot is not None:
            self.S11currentShadowPlot.set_title(
                "S11" if self.editResultsName.text() == "" else (self.editResultsName.text() + "\nS11"))
            self.S11shadowCanvas.draw()

    # override
    def setConnectionDependentEnables(self, newValue: bool):
        super().setConnectionDependentEnables(newValue)
        # print("S11::setConnectionDependentEnables(), newValue=", newValue)
        self.buttonS11Refresh.setEnabled(newValue)
        self.buttonS11RunSingle.setEnabled(newValue)
        self.buttonS11ResetView.setEnabled(newValue)
        self.buttonS11Clear.setEnabled(newValue)
        self.buttonS11SaveResults.setEnabled(newValue)

    # override
    def refreshResults(self, flag: int):
        super().refreshResults(flag)
        #  print("S11::refreshResults()")

        if (flag & 0x2) == 0:
            return

        # Fetch X-axis mapping
        offsetGHz = Connect.getDevice().S11.Cfg.getOffsetGHz()
        spanGHz = Connect.getDevice().S11.Cfg.getSpanGHz()
        fftlength = Connect.getDevice().S11.Cfg.getReclen()
        # print("offsetGHz =", offsetGHz, ", spanGHz =", spanGHz, ", fftlength =", fftlength)

        # Fetch important settings
        persist = Connect.getDevice().S11.Cfg.getPersist()
        applySmoothing = Connect.getDevice().S11.Cfg.getApplySmooth()
        avg = Connect.getDevice().S11.Cfg.getAvg()
        # print("persist =", persist, ", applySmoothing =", applySmoothing, ", avg =", avg)

        # Fetch trace data
        data_y = Connect.getDevice().S11.getBinaryMagn()
        data_incident = Connect.getDevice().S11.getBinaryIncident()
        data_reflected = Connect.getDevice().S11.getBinaryReflected()
        # print("Length of fetched data:")
        # print("  data_y: ", len(data_y))
        # print("  data_incident: ", len(data_incident))
        # print("  data_reflected: ", len(data_reflected))

        reclen = len(data_y)
        data_x = numpy.empty(reclen, float)

        for index in range(reclen):
            ghz = offsetGHz + (index * spanGHz) / fftlength
            ohm = data_y[index]
            data_x[index] = ghz
            data_y[index] = 0.0 if data_y[index] <= 0.0 else (20.0 * math.log10(data_y[index]))
            data_incident[index] = 0.0 if data_incident[index] <= 0.0 else (20.0 * math.log10(data_incident[index]))
            data_reflected[index] = 0.0 if data_reflected[index] <= 0.0 else (20.0 * math.log10(data_reflected[index]))

        # Assign results into Gui widgets

        # Build meta-data string
        metaData = "Record len: " + ("{:.0f}".format(reclen)) + "\n" + \
                   "FFT len: " + ("{:.0f}".format(fftlength)) + "\n" + \
                   "Averages: " + ("{:.0f}".format(avg)) + "\n" + \
                   "Persist: " + ("{:.0f}".format(persist)) + "\n" + \
                   "Apply smoothing: " + ("Yes" if applySmoothing else "No") + "\n\n"
        # print("Metadata: ", metaData)

        # Build chart for screen display
        self.S11chartFigure.clear()

        plot = self.S11chartFigure.add_subplot(1, 1, 1)
        plot.plot(data_x, data_y)
        # plot.plot(data_x, data_incident)
        # plot.plot(data_x, data_reflected)

        plot.set_title("S11" if self.editResultsName.text() == "" else self.editResultsName.text() + "\nS11",
                       fontsize=9)
        plot.set_xlabel("GHz", fontsize=9)
        plot.set_ylabel("dB", fontsize=9)
        plot.grid()

        t = plot.text(0.95, 0.95, metaData,
                      backgroundcolor="lightyellow",
                      verticalalignment="top",
                      horizontalalignment="right",
                      fontsize=8,
                      transform=plot.transAxes
                      )
        t.set_bbox(dict(facecolor='lightyellow', alpha=0.6))

        self.S11chartCanvas.draw()
        self.S11currentPlot = plot

        # Create duplicate chart for "save" function so not dependent on viewing configuration
        self.S11shadowFigure.clear()
        plot2 = self.S11shadowFigure.add_subplot(1, 1, 1)
        plot2.plot(data_x, data_y)
        # plot2.plot(data_x, data_incident)
        # plot2.plot(data_x, data_reflected)
        plot2.set_title("S11" if self.editResultsName.text() == "" else self.editResultsName.text() + "\nS11",
                        fontsize=9)
        plot2.set_xlabel("GHz", fontsize=9)
        plot2.set_ylabel("dB", fontsize=9)
        plot2.grid()

        t = plot2.text(0.95, 0.95, metaData,
                       backgroundcolor="lightyellow",
                       verticalalignment="top",
                       horizontalalignment="right",
                       fontsize=8,
                       transform=plot2.transAxes
                       )
        t.set_bbox(dict(facecolor='lightyellow', alpha=0.6))

        self.S11shadowCanvas.draw()
        self.S11currentShadowPlot = plot2

        # build log file contents
        self.S11ResultsDateTime = datetime.datetime.now()
        header_str = "Results, Date, Time, Parameter, Index, x, Value"
        results_str = self.editResultsName.text().strip()
        date_str = self.S11ResultsDateTime.strftime("%m/%d/%Y")
        time_str = self.S11ResultsDateTime.strftime("%H:%M:%S")
        # print("Header: ", header_str)
        # print("Results name: ", results_str)
        # print("Date: ", date_str)
        # print("Time: ", time_str)

        try:
            self.S11LogFileContents = header_str + "\n"

            for index in range(reclen):
                index_str = "{:.0f}".format(index)
                x_value_str = "{:.3f}".format(data_x[index])
                y_value_str = "{:.2f}".format(data_y[index])

                self.S11LogFileContents = self.S11LogFileContents + \
                                          '"' + results_str + "\"," + date_str + "," + time_str + ", " + \
                                          "S11" + "," + index_str + "," + x_value_str + "," + y_value_str + "\n"
                pass

            for index in range(reclen):
                index_str = "{:.0f}".format(index)
                x_value_str = "{:.3f}".format(data_x[index])
                y_value_str = "{:.2f}".format(data_incident[index])

                self.S11LogFileContents = self.S11LogFileContents + \
                                          '"' + results_str + "\"," + date_str + "," + time_str + ", " + \
                                          "INCIDENT" + "," + index_str + "," + x_value_str + "," + y_value_str + "\n"
                pass

            for index in range(reclen):
                index_str = "{:.0f}".format(index)
                x_value_str = "{:.3f}".format(data_x[index])
                y_value_str = "{:.2f}".format(data_reflected[index])

                self.S11LogFileContents = self.S11LogFileContents + \
                                          '"' + results_str + "\"," + date_str + "," + time_str + ", " + \
                                          "REFLECTED" + "," + index_str + "," + x_value_str + "," + y_value_str + "\n"
                pass

        except Exception as e:
            print("Problem building pivot file contents: ", e)
            raise e

# EOF
