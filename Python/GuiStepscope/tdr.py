# tdr.py
# ================================================================================
# BOOST SOFTWARE LICENSE
#
# Copyright 2020 BitWise Laboratories Inc.
# Original Author.......Jim Waschura
# Contact...............info@bitwiselabs.com
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
# ================================================================================
import datetime
import math
import os
import numpy
from PyQt5 import QtWidgets
from PyQt5.QtWidgets import QVBoxLayout, QApplication, QMainWindow

from matplotlib import pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
from popup import Popup
from connect import Connect
from settings import Settings


class Tdr(Settings):
    def __init__(self, mainWindow: QMainWindow):
        super().__init__(mainWindow)
        # print("Tdr::__init__()")

        # Establish event handlers
        self.buttonTDRRefresh.clicked.connect(self.buttonTDRRefresh_clicked)
        self.buttonTDRClear.clicked.connect(self.buttonTDRClear_clicked)
        self.buttonTDRRunSingle.clicked.connect(self.buttonTDRRunSingle_clicked)
        self.buttonTDRResetView.clicked.connect(self.buttonTDRResetView_clicked)
        self.buttonTDRSaveResults.clicked.connect(self.buttonTDRSaveResults_clicked)
        self.numTDRCursorX1.editingFinished.connect(self.numTDRCursorX1_editingFinished)
        self.numTDRCursorX2.editingFinished.connect(self.numTDRCursorX2_editingFinished)

        # Initialize results variables
        self.TDRLogFileContents = None
        self.TDRResultsDateTime = None

        self.TDRchartFigure = plt.figure()
        self.TDRchartFigure.set_tight_layout(True)
        self.TDRchartCanvas = FigureCanvas(self.TDRchartFigure)
        self.chartToolbar = NavigationToolbar(self.TDRchartCanvas, mainWindow)

        vLayout = QVBoxLayout()
        vLayout.addWidget(self.TDRchartCanvas)
        vLayout.addWidget(self.chartToolbar)
        self.chartToolbar.hide()
        self.TDRChartLayout.addLayout(vLayout)
        self.TDRcurrentPlot = None
        self.TDRcurrentShadowPlot = None
        self.TDRchartLeft = None
        self.TDRchartWidth = None

        self.TDRshadowFigure = plt.figure()
        self.TDRshadowFigure.set_tight_layout(True)
        self.TDRshadowCanvas = FigureCanvas(self.TDRshadowFigure)

    def buttonTDRRefresh_clicked(self):
        # print("Tdr::buttonTDRRefresh_clicked")
        try:
            self.refreshResults(0x1)
        except Exception as e:
            Popup.error(e)

    def buttonTDRClear_clicked(self):
        # print("Tdr::buttonTDRClear_clicked")
        try:
            Connect.getDevice().App.Stop()
            Connect.getDevice().App.setTab("TDR")
            Connect.getDevice().Clear()
            self.refreshResults(0x1)
        except Exception as e:
            Popup.error(e)

    def buttonTDRResetView_clicked(self):
        # print("Tdr::buttonTDRResetView_clicked")
        try:
            Connect.getDevice().App.Stop()
            Connect.getDevice().App.setTab("TDR")
            Connect.getDevice().Tdr.Reset()
            Connect.getDevice().WaitForRunToStart()
            Connect.getDevice().WaitForRunToComplete(120.0)
            self.refreshResults(0x1)
        except Exception as e:
            Popup.error(e)

    def buttonTDRSaveResults_clicked(self):
        # print("Tdr::buttonTDRSaveResults_clicked")

        try:
            # ensure directories exist
            self.ensureDirectoriesExist()

            # if results subdirectory doesn't exist, create it
            results_subdir = os.path.normpath(
                self.editDataDirectory.text().strip() + "/" + self.editResultsName.text().strip())
            # print("results_subdir is: " + results_subdir)
            if not os.path.exists(results_subdir):
                os.mkdir(results_subdir)

            name_nospace = self.editResultsName.text().strip().replace(" ", "_")

            if self.TDRResultsDateTime is None:
                self.TDRResultsDateTime = datetime.datetime.now()

            dt_string = self.TDRResultsDateTime.strftime("_%Y-%m-%d_%Hh%Mm%Ss")
            chart_file_name = os.path.normpath(results_subdir + "/" + name_nospace + "_Tdr_Chart" + dt_string + ".png")
            csv_file_name = os.path.normpath(results_subdir + "/" + name_nospace + "_Tdr_Csv" + dt_string + ".csv")
            pivot_file_name = os.path.normpath(results_subdir + "/" + name_nospace + "_Tdr_Pivot"+ dt_string + ".csv")

            # print("chart_file_name is: " + chart_file_name)
            # print("csv_file_name is: " + csv_file_name)

            # retrieve CSV file and store in results subdirectory
            if self.checkSaveCSV.isChecked():
                Connect.getDevice().App.Stop()
                Connect.getDevice().App.setTab("TDR")
                try:
                    csv_remote_file = Connect.getDevice().Tdr.Csv()
                    # print("csv remote file is: ", csv_remote_file)

                    csv_file_contents = Connect.getDevice().File.Fetch(csv_remote_file).decode(encoding='utf-8')
                    f = open(csv_file_name, "w")
                    f.write(csv_file_contents)
                    f.close()

                except Exception as e:
                    print("Problem saving CSV file: ", e)
                    raise e

            # save Pivot log file in results subdirectory
            if self.TDRLogFileContents is not None:
                try:
                    f = open(pivot_file_name, "w")
                    f.write(self.TDRLogFileContents)
                    f.close()
                except Exception as e:
                    print("Problem saving pivot file: ", e)
                    raise e

            # save current chart in results subdirectory
            if self.checkSaveCharts.isChecked():
                if self.TDRcurrentShadowPlot is not None:
                    self.TDRshadowFigure.savefig(chart_file_name,
                                                 dpi=300,
                                                 format="png",
                                                 pad_inches=0.5,
                                                 orientation='portrait',
                                                 papertype="letter",
                                                 edgecolor="black")
                    
            Popup.info("TDR results saved to: " + results_subdir, "Save TDR Results")
        except Exception as e:
            Popup.error(e)
            


    def buttonTDRRunSingle_clicked(self):
        # print("Tdr::buttonTDRRunSingle_clicked")
        try:
            Connect.getDevice().App.Stop()
            Connect.getDevice().App.setTab("TDR")

            self.buttonTDRRunSingle.setEnabled(False)
            self.buttonTDRRefresh.setEnabled(False)
            self.buttonTDRResetView.setEnabled(False)
            self.buttonTDRSaveResults.setEnabled(False)
            self.buttonTDRClear.setEnabled(False)
            self.numTDRCursorX1.setEnabled(False)
            self.numTDRCursorX2.setEnabled(False)
            QApplication.processEvents()

            Connect.getDevice().RunSingle()
            Connect.getDevice().WaitForRunToComplete(120.0)
            self.refreshResults(0x1)

        except Exception as e:
            Popup.error(e)

        finally:
            self.buttonTDRRunSingle.setEnabled(True)
            self.buttonTDRRefresh.setEnabled(True)
            self.buttonTDRResetView.setEnabled(True)
            self.buttonTDRSaveResults.setEnabled(True)
            self.buttonTDRClear.setEnabled(True)
            self.numTDRCursorX1.setEnabled(True)
            self.numTDRCursorX2.setEnabled(True)
        pass

    def numTDRCursorX1_editingFinished(self):
        # print("Tdr::numTDRCursorX1_editingFinished")
        try:
            Connect.getDevice().Tdr.Chart.setCursValue(0, math.floor(self.numTDRCursorX1.value()))
            self.refreshResults(0x1)
        except Exception as e:
            Popup.error(e)

    def numTDRCursorX2_editingFinished(self):
        # print("Tdr::numTDRCursorX2_editingFinished")
        try:
            Connect.getDevice().Tdr.Chart.setCursValue(1, math.floor(self.numTDRCursorX2.value()))
            self.refreshResults(0x1)
        except Exception as e:
            Popup.error(e)

    # override
    def editResultsName_editingFinished(self):
        super().editResultsName_editingFinished()
        # print("Tdr::editResultsName_editingFinished()")

        if self.TDRcurrentPlot is not None:
            self.TDRcurrentPlot.set_title(
                "TDR" if self.editResultsName.text() == "" else (self.editResultsName.text() + "\nTDR"))
            self.TDRchartCanvas.draw()

        if self.TDRcurrentShadowPlot is not None:
            self.TDRcurrentShadowPlot.set_title(
                "TDR" if self.editResultsName.text() == "" else (self.editResultsName.text() + "\nTDR"))
            self.TDRshadowCanvas.draw()

    # override
    def setConnectionDependentEnables(self, newValue: bool):
        super().setConnectionDependentEnables(newValue)
        # print("Tdr::setConnectionDependentEnables(), newValue=", newValue)
        self.buttonTDRRefresh.setEnabled(newValue)
        self.buttonTDRRunSingle.setEnabled(newValue)
        self.buttonTDRResetView.setEnabled(newValue)
        self.buttonTDRClear.setEnabled(newValue)
        self.buttonTDRSaveResults.setEnabled(newValue)
        self.numTDRCursorX1.setEnabled(newValue)
        self.numTDRCursorX2.setEnabled(newValue)

    # override
    def refreshResults(self, flag: int):
        super().refreshResults(flag)
        # print("Tdr::refreshResults()")

        if (flag & 0x1) == 0:
            return

        # Fetch cursor positions
        x1 = Connect.getDevice().Tdr.Chart.getCursValue(0)
        x2 = Connect.getDevice().Tdr.Chart.getCursValue(1)
        # print("CursorX1 =", x1, ", CursorX2 =", x2);

        self.numTDRCursorX1.blockSignals(True)
        self.numTDRCursorX2.blockSignals(True)
        self.numTDRCursorX1.setValue(x1)
        self.numTDRCursorX2.setValue(x2)
        self.numTDRCursorX1.blockSignals(False)
        self.numTDRCursorX2.blockSignals(False)

        if x1 > x2:
            tmp = x1
            x1 = x2
            x2 = tmp

        # Fetch X-axis mapping
        offsetPS = Connect.getDevice().Tdr.Cfg.getOffsetPS()
        spanPS = Connect.getDevice().Tdr.Cfg.getSpanPS()
        reclen = Connect.getDevice().Tdr.Cfg.getReclen()
        # print("offsetPS =", offsetPS, ", spanPS =", spanPS, ", reclen =", reclen);

        # Fetch important settings
        bw = Connect.getDevice().Tdr.Cfg.getBWGHz()
        usingDiff = Connect.getDevice().Tdr.Cfg.getUseDiff()
        avg = Connect.getDevice().Tdr.Cfg.getAvg()
        calState = Connect.getDevice().Tdr.getCalState()
        self.TDRchartLeft = Connect.getDevice().Tdr.Chart.getLeftPS()
        self.TDRchartWidth = Connect.getDevice().Tdr.Chart.getWidthPS()


        # print("bw =", bw, ", usingDiff =", usingDiff, ", avg =", avg, ", calState =", calState);

        # Fetch short calibration file names and contents, and extract date-time
        shortCalFile = Connect.getDevice().Tdr.getShortCalFile()
        shortCal = Connect.getDevice().File.Fetch(shortCalFile).decode(encoding='utf-8')

        shortCalLines = shortCal.splitlines()
        shortCalDateTime = "UNK"

        for index in range(len(shortCalLines)):
            cols = shortCalLines[index].split(',')
            if len(cols) == 2 and cols[0].strip() == "DATETIME":
                shortCalDateTime = cols[1].strip()[-20:]
                break
            pass

        # Fetch termination calibration file names and contents, and extract date-time
        termCalFile = Connect.getDevice().Tdr.getTermCalFile()
        termCal = Connect.getDevice().File.Fetch(termCalFile).decode(encoding='utf-8')

        termCalLines = termCal.splitlines()
        termCalDateTime = "UNK"
        for index in range(len(termCalLines)):
            cols = termCalLines[index].split(',')
            if len(cols) == 2 and cols[0].strip() == "DATETIME":
                termCalDateTime = cols[1].strip()[-20:]
                break
            pass

        # Fetch trace data data_y, calculate min, max, average
        data_y = Connect.getDevice().Tdr.getBinary()

        SENTINEL = 999999.999
        minimum = SENTINEL
        maximum = -SENTINEL

        accum = 0.0
        count = 0
        data_x = numpy.empty(len(data_y), float)

        for index in range(reclen):
            ps = offsetPS + (index * spanPS) / reclen
            ohm = data_y[index]
            data_x[index] = ps

            if x1 <= ps <= x2:
                if ohm < minimum:
                    minimum = ohm
                if ohm > maximum:
                    maximum = ohm
                accum = accum + ohm
                count = count + 1
                pass
            pass
        # print("TDR count =", count, "minimum =", minimum, "maximum =", maximum, "accum =", accum)

        # Duplicate values in second array for area between two cursors
        selected_x = numpy.empty(count, float)
        selected_y = numpy.empty(count, float)
        selected_count = 0

        for index in range(reclen):
            if x1 <= data_x[index] <= x2:
                selected_x[selected_count] = data_x[index]
                selected_y[selected_count] = data_y[index]
                selected_count = selected_count + 1
                pass
            pass

        # Assign results into Gui widgets
        self.editTDRShortCalib.setText(shortCalDateTime)
        self.editTDRTermCalib.setText(termCalDateTime)

        # Build meta-data string
        metaData = "Record len: " + ("{:.0f}".format(reclen)) + "\n" + \
                   "Averages: " + ("{:.0f}".format(avg)) + "\n" + \
                   "B/W limit: " + ("0 GHz" if bw == 0 else "{:.3f} GHz".format(bw)) + "\n" + \
                   "Differential: " + ("Yes" if usingDiff else "No") + "\n\n" + \
                   "Selected region:\n" + \
                   " min " + ("n/a" if minimum == SENTINEL else "{:.2f} ohm".format(minimum)) + "\n" + \
                   " max " + ("n/a" if maximum == -SENTINEL else "{:.2f} ohm".format(maximum)) + "\n" + \
                   " avg " + ("n/a" if count == 0 else "{:.2f} ohm".format(accum / count)) + "\n" + \
                   " (" + ("{:.0f} samples".format(count)) + ")"

        # Build chart for screen display
        self.TDRchartFigure.clear()

        plot = self.TDRchartFigure.add_subplot(1, 1, 1)
        plot.plot(data_x, data_y)
        plot.plot(selected_x, selected_y)
        plot.set_title("TDR" if self.editResultsName.text() == "" else self.editResultsName.text() + "\nTDR",
                       fontsize=9)
        plot.set_xlabel("ps", fontsize=9)
        plot.set_ylabel("ohm", fontsize=9)

        plot.set_xlim(self.TDRchartLeft, self.TDRchartLeft+self.TDRchartWidth)
        plot.grid()

        t = plot.text(0.95, 0.95, metaData,
                      backgroundcolor="lightyellow",
                      verticalalignment="top",
                      horizontalalignment="right",
                      fontsize=8,
                      transform=plot.transAxes
                      )
        t.set_bbox(dict(facecolor='lightyellow', alpha=0.6))

        self.TDRchartCanvas.draw()
        self.TDRcurrentPlot = plot

        # Create duplicate chart for "save" function so not dependent on viewing configuration
        self.TDRshadowFigure.clear()
        plot2 = self.TDRshadowFigure.add_subplot(1, 1, 1)
        plot2.plot(data_x, data_y)
        plot2.plot(selected_x, selected_y)
        plot2.set_title("TDR" if self.editResultsName.text() == "" else self.editResultsName.text() + "\nTDR",
                        fontsize=9)
        plot2.set_xlabel("ps", fontsize=9)
        plot2.set_ylabel("ohm", fontsize=9)
        plot.set_xlim(self.TDRchartLeft, self.TDRchartLeft+self.TDRchartWidth)
        plot2.grid()

        t = plot2.text(0.95, 0.95, metaData,
                       backgroundcolor="lightyellow",
                       verticalalignment="top",
                       horizontalalignment="right",
                       fontsize=8,
                       transform=plot2.transAxes
                       )
        t.set_bbox(dict(facecolor='lightyellow', alpha=0.6))

        self.TDRshadowCanvas.draw()
        self.TDRcurrentShadowPlot = plot2

        # build log file contents
        self.TDRResultsDateTime = datetime.datetime.now()
        header_str = "Results, Date, Time, Parameter, Index, x, Value"
        results_str = self.editResultsName.text().strip()
        date_str = self.TDRResultsDateTime.strftime("%m/%d/%Y")
        time_str = self.TDRResultsDateTime.strftime("%H:%M:%S")

        try:

            self.TDRLogFileContents = header_str + "\n"

            self.TDRLogFileContents = self.TDRLogFileContents + \
                                      '"' + results_str + "\"," + date_str + "," + time_str + ", " + \
                                      "X1" + "," + "-1" + "," + "-1" + "," + "{:.2f}".format(x1) + "\n"

            self.TDRLogFileContents = self.TDRLogFileContents + \
                                      '"' + results_str + "\"," + date_str + "," + time_str + ", " + \
                                      "X2" + "," + "-1" + "," + "-1" + "," + "{:.2f}".format(x2) + "\n"

            self.TDRLogFileContents = self.TDRLogFileContents + \
                                      '"' + results_str + "\"," + date_str + "," + time_str + ", " + \
                                      "SELCNT" + "," + "-1" + "," + "-1" + "," + "{:.0f}".format(count) + "\n"

            self.TDRLogFileContents = self.TDRLogFileContents + \
                                      '"' + results_str + "\"," + date_str + "," + time_str + ", " + \
                                      "SELMIN" + "," + "-1" + "," + "-1" + "," + "{:.2f}".format(minimum) + "\n"

            self.TDRLogFileContents = self.TDRLogFileContents + \
                                      '"' + results_str + "\"," + date_str + "," + time_str + ", " + \
                                      "SELMAX" + "," + "-1" + "," + "-1" + "," + "{:.2f}".format(maximum) + "\n"

            average_number = -1.0
            if count > 0:
                average_number = accum / count

            self.TDRLogFileContents = self.TDRLogFileContents + \
                                      '"' + results_str + "\"," + date_str + "," + time_str + ", " + \
                                      "SELAVG" + "," + "-1" + "," + "-1" + "," + "{:.2f}".format(average_number) + "\n"

            for index in range(reclen):
                index_str = "{:.0f}".format(index)
                x_value_str = "{:.3f}".format(offsetPS + (index * spanPS) / reclen)
                y_value_str = "{:.2f}".format(data_y[index])

                self.TDRLogFileContents = self.TDRLogFileContents + \
                                          '"' + results_str + "\"," + date_str + "," + time_str + ", " + \
                                          "TDR" + "," + index_str + "," + x_value_str + "," + y_value_str + "\n"
                pass

            for index in range(len(selected_y)):
                index_str = "{:.0f}".format(index)
                x_value_str = "{:.3f}".format(selected_x[index])
                y_value_str = "{:.2f}".format(selected_y[index])

                self.TDRLogFileContents = self.TDRLogFileContents + \
                                          '"' + results_str + "\"," + date_str + "," + time_str + ", " + \
                                          "SELTDR" + "," + index_str + "," + x_value_str + "," + y_value_str + "\n"
                pass

        except Exception as e:
            print("Problem building pivot file contents: ", e)
            raise e

# EOF
