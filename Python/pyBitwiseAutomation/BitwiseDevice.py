# BitwiseDevice.py
# ================================================================================
# BOOST SOFTWARE LICENSE
#
# Copyright 2020 BitWise Laboratories Inc.
# Original Author.......Jim Waschura
# Contact...............info@bitwiselabs.com
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
# ================================================================================
import math
import os
import time
import re
from pyBitwiseAutomation.SocketDevice import SocketDevice
from pyBitwiseAutomation.autogenCommon import *


class BitwiseDevice(SocketDevice):
    """Bitwise device class."""

    def __init__(self):
        super().__init__()
        self.App = BranchApp(self, "App:")
        self.File = BranchFile(self, "File:")
        self.Sys = BranchSys(self, "Sys:")
        self.Const = BranchConst(self, "Const:")
        self.Announce = BranchAnnounce(self, "Announce:")

    def __del__(self):
        super().__del__()
        return None

    # Override
    def SendCommand(self, command: str):
        """Send command (ending with '\n') to socket device, with error handling."""

        super().SendCommand("stc;" + command)
        statusResponse = super().QueryResponse("st?\n")

        if statusResponse.casefold() != "[none]".casefold():
            raise Exception("[" + statusResponse + "]")

        return None

    # Override
    def QueryResponse(self, command: str, maxLength: int = 4096) -> str:
        """Query response from command (ending with '\n') from socket device, with error handling."""

        if not isinstance(command, str):
            raise Exception("[Command_Must_Be_String]")

        if not isinstance(maxLength, int):
            raise Exception("[MaxLen_Must_Be_Int]")

        response = super().QueryResponse("stc;" + command, maxLength)
        statusResponse = super().QueryResponse("st?\n")

        if statusResponse.casefold() != "[none]".casefold():
            raise Exception("[" + statusResponse + "]")

        return response

    def SaveConfiguration(self, configuration: str = "[recent]"):
        """Restore configuration file and optionally pause while operation completes.

        specifying configurations:
        [recent]  ...  most recent settings
        [factory]  ... factory settings
        [startup]  ... settings from selectable startup configuration file
        full-path-name ... settings from fully-specified configuration file path
        filename-only ... settings from file located in configuration folder
        """

        super().SendCommand("stc;" + "save \"" + configuration + "\"\n")
        super().SendCommand("stc\n")
        return None

    def RestoreConfiguration(self, configuration: str, waitToComplete: bool = True):
        """Restore configuration file and optionally pause while operation completes.

        specifying configurations:
        [recent]  ...  most recent settings
        [factory]  ... factory settings
        [startup]  ... settings from selectable startup configuration file
        full-path-name ... settings from fully-specified configuration file path
        filename-only ... settings from file located in configuration folder
        """

        self.App.Stop()  # just to make sure

        super().SendCommand("stc;" + "restore \"" + configuration + "\"\n")

        if waitToComplete:
            self.WaitForRestoreToComplete()

        return None

    def WaitForRestoreToComplete(self):
        """Wait for restore configuration operation completes."""

        now = SocketDevice.timestamp()
        timeout = now + 30.0
        begin_time = now

        while now < timeout:
            time.sleep(0.5)
            now = SocketDevice.timestamp()

            if self.getDebugging():
                print("Restoring configuration " + "{:.1f}".format(now - begin_time))

            response = super().QueryResponse("inprogress\n")
            if response == "F" or response == "0":
                break

        if now >= timeout:
            raise Exception("[Timeout_Restoring_Configuration]")

        super().SendCommand("stc\n")
        return None

    def getIsRunning(self) -> bool:
        response = self.QueryResponse("App:RunState?\n")
        if len(response) < 2:
            raise Exception("[Invalid_RunState_Response]")

        tokens = response[1:-1].split(",")
        return_value = False
        for itm in tokens:
            if itm != "Stop":
                return_value = True
                break

        return return_value

    def Run(self, waitUntilRunningTimeout: float = 10.0):
        """Initiate run operation and wait until started."""

        self.App.Run(False)

        if waitUntilRunningTimeout > 0.0:
            self.WaitForRunToStart(waitUntilRunningTimeout)

        return None

    def RunSingle(self, waitUntilRunningTimeout: float = 10.0):
        """Initiate run once operation and wait until started."""

        self.App.Run(True)

        if waitUntilRunningTimeout > 0.0:
            self.WaitForRunToStart(waitUntilRunningTimeout)

        return None

    def Stop(self, ):
        self.App.Stop()
        return None

    def WaitForRunToStart(self, timeoutSec: float = 10.0):
        """Wait for device to start running."""

        now = SocketDevice.timestamp()
        timeout = now + timeoutSec

        while now < timeout and not self.getIsRunning():
            time.sleep(0.5)
            now = SocketDevice.timestamp()

            if now >= timeout:
                raise Exception("[Wait_Run_Start_Timeout]")

        return None

    def WaitForRunToComplete(self, timeoutSec: float):
        """Wait for device to stop running."""

        now = SocketDevice.timestamp()
        timeout = now + timeoutSec

        while now < timeout and self.getIsRunning():
            time.sleep(0.5)
            now = SocketDevice.timestamp()

        if now >= timeout:
            raise Exception("[Wait_Run_Complete_Timeout]")

        self.Stop()
        return None

    @staticmethod
    def unpackValueByKey(string: str, key: str) -> str:
        lines = string.split("\n")
        retn = None
        for tok in lines:
            if tok.startswith(key + " ") or tok.startswith(key + "=") or tok.startswith(key + "\t") or tok.startswith(
                    key + ","):
                retn = tok[len(key) + 1:]

        if retn == None:
            raise Exception("[Key_Not_Found]")

        return retn

    @staticmethod
    def unpackDoubleByKey(string: str, key: str) -> float:
        return float(BitwiseDevice.unpackValueByKey(string, key))

    @staticmethod
    def unpackIntegerByKey(string: str, key: str) -> float:
        value = BitwiseDevice.unpackValueByKey(string, key)
        if value.startswith("0x") or value.startswith("0X"):
            retn = int(value[2:], 16)
        else:
            retn = int(value)
        return retn

    def Clear(self):
        self.App.Clear()
        return None

    # ============================================================================
    # ============================================================================

    def fileXferBuffer(self, buffer_bytes: bytes, prefix: str = ""):  # use prefix "Same" for retry
        """Method for Transmit next buffer to device-requires count. """
        if len(buffer_bytes) == 0:
            raise Exception("[Xfer" + prefix + "Buffer_Is_Empty]")

        cksum = 0
        for i in range(len(buffer_bytes)):
            cksum = cksum + buffer_bytes[i]

        cksum = cksum & 0xffffffff

        super().SendCommand(
            "stc; File:Xfer:" + prefix + "Buffer " + "{:.0f}".format(len(buffer_bytes)) + " " + hex(cksum) + "\n")
        super().Send(buffer_bytes)

        return None

    def SendFileAs(self, localfilepath: str, destinationfilepath: str):
        """Send file to device.  """
        # print("BitwiseDevice::SendFileAs src=[" + localfilepath + "], dest=[" + destinationfilepath + "]")

        if len(localfilepath) == 0:
            raise Exception("[Local_Filename_Is_Missing]")

        if len(destinationfilepath) == 0:
            raise Exception("[Destination_Filename_Is_Missing]")

        dt = datetime.datetime.fromtimestamp(os.path.getmtime(localfilepath))
        f = open(localfilepath, "rb")

        try:
            datetime_str = dt.strftime(" %Y/%m/%d %H:%M:%S")
            self.SendCommand('File:Xfer:Put "' + destinationfilepath + '"' + datetime_str + '\n')

            byte_buffer = f.read(4096)
            # print("chunk: ", len(byte_buffer))
            while len(byte_buffer) > 0:
                self.fileXferBuffer(byte_buffer)
                status = super().QueryResponse("st?\n")

                retry = 0
                while retry < 3 and status == "[Checksum_Error]":
                    self.fileXferBuffer(byte_buffer, "Same")
                    status = super().QueryResponse("st?\n")
                    retry = retry + 1

                if status != "[none]":
                    raise Exception("[File_Send_Failed]")

                byte_buffer = f.read(4096)
                # print("chunk: ", len(byte_buffer))

            self.SendCommand("File:Xfer:DonePut\n")

        except Exception as e:
            print("problem sending file: ", e)
            self.SendCommand("File:Xfer:DonePut\n")
            super().SendCommand("File:Del \"" + destinationfilepath + "\"\n")

            raise e

        finally:
            f.close()

    def ReceiveFileAs(self, sourceFilePath: str, localFilePath: str):
        """Receive file from device.  Needs testing. """
        # print("BitwiseDevice::SendFileAs src=[" + sourceFilePath + "], localdest=[" + localFilePath + "]")

        if len(sourceFilePath) == 0:
            raise Exception("[Source_Filename_Is_Missing]")

        if len(localFilePath) == 0:
            raise Exception("[Local_Filename_Is_Missing]")

        # returns with long string containing fields separated by space:
        # "filename" ... including double quotes
        # byte count
        # year / month / day ... including forward slashes, year is 4 digits
        # HH: MM:SS ... including colons

        buffer = super().QueryResponse('File:Xfer:Get "' + sourceFilePath + '"\n')

        n = 0
        for n in range(1, len(buffer)):
            if buffer[n] == '"':
                break

        if buffer[0] != '"' or buffer[n] != '"':
            raise Exception("[Invalid_Response_From_Get_Command]")

        sevenNumbers = re.split("[0-9]+", buffer[n + 1:])
        if len(sevenNumbers) != 7:
            raise Exception("[Invalid_Response_Length_Date_Time]")

        length = int(sevenNumbers[0])
        year = int(sevenNumbers[1])
        month = int(sevenNumbers[2])
        day = int(sevenNumbers[3])
        hour = int(sevenNumbers[4])
        minute = int(sevenNumbers[5])
        second = int(sevenNumbers[6])

        f = open(localFilePath, "wb")
        try:

            totalTransferred = 0
            while totalTransferred < length:
                super().SendCommand("File:Xfer:Next\n")
                headerBytes = super().Receive(12)

                if len(headerBytes) != 12:
                    raise Exception("[No_Response_From_Next_Command]")

                smagic = int.from_bytes(headerBytes[0:4], byteorder="little")
                sbytes = int.from_bytes(headerBytes[4:8], byteorder="little")
                ssum = int.from_bytes(headerBytes[8:12], byteorder="little")

                if smagic != 0x12345678:
                    raise Exception("[Response_From_Next_Command_Is_Invalid]")

                if sbytes == 0:
                    break

                cnt = 0
                xfer = bytes(sbytes)
                while cnt < sbytes:
                    transfer = super().Receive(sbytes - cnt)
                    if len(transfer) == 0:
                        raise Exception("[Binary_Xfer_Unsuccessful]")

                    for i in range(len(transfer)):
                        xfer[cnt + i] = transfer[i]
                    cnt = cnt + len(transfer)

                xsum = 0
                for i in range(len(xfer)):
                    xsum = xsum + xfer[i]

                retry = 3
                while xsum != ssum and retry > 0:
                    super().SendCommand("File:Xfer:Resend\n")

                    headerBytes = super().Receive(12)

                    if len(headerBytes) != 12:
                        raise Exception("[No_Response_From_ResendCommand]")

                    smagic = int.from_bytes(headerBytes[0:4], byteorder="little")
                    sbytes = int.from_bytes(headerBytes[4:8], byteorder="little")
                    ssum = int.from_bytes(headerBytes[8:12], byteorder="little")

                    if smagic != 0x12345678:
                        raise Exception("[Response_From_Resend_Command_Is_Invalid]")

                    cnt = 0
                    xfer = bytes(sbytes)
                    while cnt < sbytes:
                        transfer = super().Receive(sbytes - cnt)
                        if len(transfer) == 0:
                            raise Exception("[Binary_Retry_Unsuccessful]")

                        for i in range(len(transfer)):
                            xfer[cnt + i] = transfer[i]
                        cnt = cnt + len(transfer)

                    xsum = 0
                    for i in range(len(xfer)):
                        xsum = xsum + xfer[i]

                if retry == 0:
                    raise Exception("[Binary_Xfer_Retries_Failed]")

                f.write(xfer)
                totalTransferred = totalTransferred + len(xfer)

            self.SendCommand("File:Xfer:DoneGet\n")

            f.close()
            f = None

            statbuf = os.stat(localFilePath)
            timeinfo = time.localtime(statbuf.st_mtime)
            timeinfo.tm_year = year  # careful - c/c++ is years since 1900, but python is all 4 digits
            timeinfo.tm_mon = month  # careful - c/c++ is 0-11, but python is 1-12
            timeinfo.tm_mday = day
            timeinfo.tm_hour = hour
            timeinfo.tm_min = minute
            timeinfo.tm_sec = second

            new_times = (time.mktime(timeinfo), time.mktime(timeinfo))
            os.utime(localFilePath, new_times)

        except Exception as e:
            print("Problem receiving file: " + str(e))

            if f is not None:
                f.close()

            os.unlink(localFilePath)

# EOF
