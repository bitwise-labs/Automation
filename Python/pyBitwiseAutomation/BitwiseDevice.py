# BitwiseDevice.py
# ================================================================================
# BOOST SOFTWARE LICENSE
#
# Copyright 2020 BitWise Laboratories Inc.
# Original Author.......Jim Waschura
# Contact...............info@bitwiselabs.com
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
# ================================================================================
import math
import os
import time
from pyBitwiseAutomation.SocketDevice import SocketDevice
from pyBitwiseAutomation.autogenCommon import *

class BitwiseDevice(SocketDevice):
    """Bitwise device class."""

    def __init__(self):
        super().__init__()
        self.App = BranchApp(self, "App:")
        self.File = BranchFile(self, "File:")
        self.Sys = BranchSys(self, "Sys:")
        self.Const = BranchConst(self, "Const:")

    def __del__(self):
        super().__del__()
        return None

    # Override
    def SendCommand(self, command:str ):
        """Send command (ending with '\n') to socket device, with error handling."""

        super().SendCommand( "stc;"+command)
        statusResponse = super().QueryResponse( "st?\n")

        if statusResponse.casefold() != "[none]".casefold() :
            raise Exception("["+statusResponse+"]")

        return None

    #Override
    def QueryResponse( self, command:str, maxLength:int = 4096 ) -> str:
        """Query response from command (ending with '\n') from socket device, with error handling."""

        if not isinstance(command,str):
            raise Exception("[Command_Must_Be_String]")

        if not isinstance(maxLength,int):
            raise Exception("[MaxLen_Must_Be_Int]")

        response = super().QueryResponse( "stc;"+command, maxLength)
        statusResponse = super().QueryResponse( "st?\n")

        if statusResponse.casefold() != "[none]".casefold():
            raise Exception("[" + statusResponse + "]")

        return response

    def SaveConfiguration(self, configuration:str = "[recent]"):
        """Restore configuration file and optionally pause while operation completes.

        specifying configurations:
        [recent]  ...  most recent settings
        [factory]  ... factory settings
        [startup]  ... settings from selectable startup configuration file
        full-path-name ... settings from fully-specified configuration file path
        filename-only ... settings from file located in configuration folder
        """

        super().SendCommand( "stc;"+"save \"" + configuration + "\"\n" )
        super().SendCommand( "stc\n")
        return None

    def RestoreConfiguration(self, configuration:str, waitToComplete:bool = True ):
        """Restore configuration file and optionally pause while operation completes.

        specifying configurations:
        [recent]  ...  most recent settings
        [factory]  ... factory settings
        [startup]  ... settings from selectable startup configuration file
        full-path-name ... settings from fully-specified configuration file path
        filename-only ... settings from file located in configuration folder
        """

        self.App.Stop() # just to make sure

        super().SendCommand( "stc;"+"restore \"" + configuration + "\"\n" )

        if waitToComplete:
            self.WaitForRestoreToComplete()

        return None

    def WaitForRestoreToComplete(self):
        """Wait for restore configuration operation completes."""

        now = SocketDevice.timestamp()
        timeout = now + 30.0
        begin_time = now

        while now < timeout:
            time.sleep(0.5)
            now = SocketDevice.timestamp()

            if self.getDebugging():
                print("Restoring configuration " + "{:.1f}".format(now - begin_time) )

            response = super().QueryResponse("inprogress\n")
            if response == "F" or response == "0":
                break

        if now >= timeout:
            raise Exception("[Timeout_Restoring_Configuration]")

        super().SendCommand( "stc\n")
        return None

    def getIsRunning(self) ->bool :
        response = self.QueryResponse("App:RunState?\n")
        if len(response) < 2:
            raise Exception("[Invalid_RunState_Response]")

        tokens = response[1:-1].split(",")
        return_value = False
        for itm in tokens:
            if itm != "Stop":
                return_value = True
                break

        return return_value

    def Run(self, waitUntilRunningTimeout: float = 10.0):
        """Initiate run operation and wait until started."""

        self.App.Run(False)

        if waitUntilRunningTimeout > 0.0:
            self.WaitForRunToStart(waitUntilRunningTimeout)

        return None

    def RunSingle(self, waitUntilRunningTimeout: float = 10.0):
        """Initiate run once operation and wait until started."""

        self.App.Run(True)

        if waitUntilRunningTimeout > 0.0:
            self.WaitForRunToStart(waitUntilRunningTimeout)

        return None

    def Stop(self, ):
        self.App.Stop()
        return None

    def WaitForRunToStart(self, timeoutSec: float = 10.0):
        """Wait for device to start running."""

        now = SocketDevice.timestamp()
        timeout = now + timeoutSec

        while now < timeout and not self.getIsRunning():
            time.sleep(0.5)
            now = SocketDevice.timestamp()

            if now >= timeout:
                raise Exception("[Wait_Run_Start_Timeout]")

        return None

    def WaitForRunToComplete(self, timeoutSec: float):
        """Wait for device to stop running."""

        now = SocketDevice.timestamp()
        timeout = now + timeoutSec

        while now < timeout and self.getIsRunning():
            time.sleep(0.5)
            now = SocketDevice.timestamp()

        if now >= timeout:
            raise Exception("[Wait_Run_Complete_Timeout]")

        self.Stop()
        return None

    @staticmethod
    def unpackValueByKey(string: str, key: str) -> str:
        lines = string.split("\n")
        retn = None
        for tok in lines:
            if tok.startswith(key+" ") or tok.startswith(key+"=") or tok.startswith(key+"\t") or tok.startswith(key+",") :
                retn = tok[len(key)+1:]

        if retn == None:
            raise Exception("[Key_Not_Found]")

        return retn

    @staticmethod
    def unpackDoubleByKey(string: str, key: str) -> float:
        return float(BitwiseDevice.unpackValueByKey(string, key))

    @staticmethod
    def unpackIntegerByKey(string: str, key: str) -> float:
        value = BitwiseDevice.unpackValueByKey(string,key)
        if value.startswith("0x") or value.startswith("0X"):
            retn = int(value[2:], 16)
        else:
            retn = int(value)
        return retn

    def Clear(self):
        self.App.Clear()
        return None

    def fileXferPut(self, destinationfilepath:str, dt:datetime = None ):
        """Method for Put file-requires filepath and optional modification date and time. """

        datetime_str = ""
        if dt is not None:
            datetime_str = dt.strftime(" %Y/%m/%d %H:%M:%S")

        self.SendCommand('File:Xfer:Put "'+destinationfilepath+'"' + datetime_str + '\n')
        return None

    def fileXferDonePut(self):
        """Method for Indicates completion of send operation. """
        self.SendCommand("File:Xfer:DonePut\n")
        return None

    def fileXferBuffer(self, buffer_bytes: bytes):
        """Method for Transmit next buffer to device-requires count, optional checksum. """
        if len(buffer_bytes) == 0:
            raise Exception("[XferBuffer_Is_Empty]")

        cksum = 0
        for i in range(len(buffer_bytes)):
            cksum = cksum + buffer_bytes[i]

        cksum = cksum & 0xffffffff

        super().SendCommand("stc; File:Xfer:Buffer " + "{:.0f}".format(len(buffer_bytes))+" " + hex(cksum) + "\n")
        super().Send(buffer_bytes)

        return None

    def fileXferSameBuffer(self, buffer_bytes: bytes ):
        """Method for Re-transmit same buffer to device-requires count, optional checksum. """

        if len(buffer_bytes) == 0:
            raise Exception("[XferSameBuffer_Is_Empty]")

        cksum = 0
        for i in range(len(buffer_bytes)):
            cksum = cksum + buffer_bytes[i]

        cksum = cksum % 256

        super().SendCommand("stc; File:Xfer:SameBuffer " + "{:.0f}".format(len(buffer_bytes))+" " + hex(cksum) + "\n")
        super().Send(buffer_bytes)

        return None

    def SendFileAs(self, localfilepath: str, destinationfilepath: str ):
        print("BitwiseDevice::SendFileAs src=[" + localfilepath + "], dest=[" + destinationfilepath + "]")

        dt = datetime.datetime.fromtimestamp(os.path.getmtime(localfilepath))
        f = open(localfilepath, "rb")

        try:
            self.fileXferPut(destinationfilepath, dt)

            byte_buffer = f.read(4096)
            print("chunk: ", len(byte_buffer))
            while len(byte_buffer) > 0:
                self.fileXferBuffer(byte_buffer)
                status = super().QueryResponse("st?\n")

                retry = 0
                while retry < 3 and status == "[Checksum_Error]":
                    self.fileXferSameBuffer(byte_buffer)
                    status = super().QueryResponse("st?\n")
                    retry = retry + 1

                if status != "[none]":
                    raise Exception("[File_Send_Failed]")

                byte_buffer = f.read(4096)
                print("chunk: ", len(byte_buffer))

            self.SendCommand("File:Xfer:DonePut\n");

        except Exception as e:
            print("problem sending file: ", e)
            self.File.Del(destinationfilepath)

            raise e

        finally:
            f.close()

# EOF