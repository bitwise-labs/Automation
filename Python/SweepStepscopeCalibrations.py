# SweepStepscopeCalibrations.py
# ================================================================================
# BOOST SOFTWARE LICENSE
#
# Copyright 2025 BitWise Laboratories Inc.
# Original Author.......Jim Waschura
# Contact...............info@bitwiselabs.com
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
# ================================================================================

from pyBitwiseAutomation import *
import sys
import csv
import math
from datetime import datetime, timedelta
from io import StringIO
from enum import Enum

INTERVAL = 1
TIMEOUT_RUN = 10
TIMEOUT_COMPLETE = 300

IPAddress = ""
DelayFlag = False
NoiseFlag = False
Interval = 0
Cycles = 1
VerboseFlag = False
FilePrefix = "Cal_"
Stepscope = StepscopeDevice()


class CalibrationType(Enum):
    Delay = 1
    Noise = 2
    S11 = 3
    Step = 4
    S21 = 5
    Tdr = 6
    Tdt = 7


def wait_until_calibration_launched(operation: CalibrationType):
    Stepscope.App.Stop()
    if Stepscope.Calib.getStatus() == Stepscope.Calib.Status.Running:
        Stepscope.Calib.Cancel()
    if operation == CalibrationType.Delay:
        Stepscope.Calib.RunDelay()
    elif operation == CalibrationType.Noise:
        Stepscope.Calib.RunNoise()

    timeout_time = datetime.now() + timedelta(seconds=TIMEOUT_RUN)

    while datetime.now() < timeout_time and Stepscope.Calib.getStatus() != Stepscope.Calib.Status.Running:
        time.sleep(INTERVAL)

    if Stepscope.Calib.getStatus() != Stepscope.Calib.Status.Running:
        if VerboseFlag:
            print("Error: Unable to start " + operation.name)
            raise Exception("[Unable_To_Start_Calibration]")

    if VerboseFlag:
        print(operation.name + " started")


def wait_until_calibration_completed():
    begin_time = datetime.now()
    timeout_time = begin_time + timedelta(seconds=TIMEOUT_COMPLETE)

    while datetime.now() < timeout_time and Stepscope.Calib.getStatus() == Stepscope.Calib.Status.Running:
        if VerboseFlag:
            print("Calibrating " + str(int((datetime.now() - begin_time).total_seconds())), end="  \r")
        time.sleep(INTERVAL)

    if VerboseFlag:
        print("Calibration completed: " + str(Stepscope.Calib.getStatus()))


def wait_until_app_launched(operation: CalibrationType):
    Stepscope.App.Stop()

    Stepscope.App.setTab(operation.name.upper())

    skip_run = False;
    if operation == CalibrationType.S11:
        Stepscope.S11.Reset()
    elif operation == CalibrationType.Step:
        Stepscope.Step.Align(Stepscope.Step.AlignMode.align0101)
        skip_run=True
    elif operation == CalibrationType.S21:
        Stepscope.S21.Reset()
    elif operation == CalibrationType.Tdr:
        Stepscope.Tdr.Reset()
    elif operation == CalibrationType.Tdt:
        Stepscope.Tdt.Reset()

    if not skip_run:
        Stepscope.App.Clear()
        Stepscope.App.Run(True)

        names = Stepscope.App.getRunList().strip("{}").split(",")
        states = Stepscope.App.getRunState().strip("{}").split(",")
        run_state_map = dict(zip(names, states))
        running_flag = run_state_map.get(operation.name, "Stop") != "Stop"

        timeout_time = datetime.now() + timedelta(seconds=TIMEOUT_RUN)

        while datetime.now() < timeout_time and not running_flag:
            time.sleep(INTERVAL)

            states = Stepscope.App.getRunState().strip("{}").split(",")
            run_state_map = dict(zip(names, states))
            running_flag = run_state_map.get(operation.name, "Stop") != "Stop"

        if not running_flag:
            if VerboseFlag:
                print("Error: Unable to start " + operation.name)
                raise Exception("[Unable_To_Start_Application]")

    if VerboseFlag:
        print("Application launched")


def wait_until_app_completed(operation: CalibrationType):
    names = Stepscope.App.getRunList().strip("{}").split(",")
    states = Stepscope.App.getRunState().strip("{}").split(",")
    run_state_map = dict(zip(names, states))
    running_flag = run_state_map.get(operation.name, "Stop") != "Stop"

    timeout_time = datetime.now() + timedelta(seconds=TIMEOUT_COMPLETE)

    while datetime.now() < timeout_time and running_flag:
        time.sleep(INTERVAL)

        states = Stepscope.App.getRunState().strip("{}").split(",")
        run_state_map = dict(zip(names, states))
        running_flag = run_state_map.get(operation.name, "Stop") != "Stop"

    if running_flag:
        if VerboseFlag:
            print("Error: Unable to stop " + operation.name)
            raise Exception("[Unable_To_Stop_Application]")

    if VerboseFlag:
        print("Application " + operation.name + " completed")


def download_operation_file(operation: CalibrationType, destination_file: str):
    download_file = "[none]"
    if operation == CalibrationType.Delay:
        download_file = Stepscope.Calib.getDelayFile()
    elif operation == CalibrationType.Noise:
        download_file = Stepscope.Calib.getNoiseFile()
    elif operation == CalibrationType.S11:
        download_file = Stepscope.S11.FileSave()
    elif operation == CalibrationType.Step:
        download_file = Stepscope.Step.Csv()

    print("Download: " + download_file + " into: " + destination_file)

    binary_data = Stepscope.File.Fetch(download_file)

    if VerboseFlag:
        print("Download completed")

    fd = open(destination_file, "w", encoding="utf-8")
    text_data = binary_data.decode("utf-8")
    fd.write(text_data)
    fd.close()


if __name__ == '__main__':
    print("SweepStepscopeCalibrations, Version 1.0")

    # Version 1.0 ... 05-15-2025 ... original

    IPAddress = ""
    Operations = []
    Interval = 0
    Cycles = 1
    VerboseFlag = False
    DebugFlag = False
    Prefix = "Cal"
    FactoryFlag = False
    Timestamp = datetime.now().strftime("%Yy%mm%dd_%Hh%Mm%Ss")

    i = 1
    while i < len(sys.argv):
        if sys.argv[i].lower() == "delay":
            Operations.append(CalibrationType.Delay)
        elif sys.argv[i].lower() == "noise":
            Operations.append(CalibrationType.Noise)
        elif sys.argv[i].lower() == "s11":
            Operations.append(CalibrationType.S11)
        elif sys.argv[i].lower() == "step":
            Operations.append(CalibrationType.Step)
        elif sys.argv[i].lower() == "s21":
            Operations.append(CalibrationType.S21)
        elif sys.argv[i].lower() == "tdr":
            Operations.append(CalibrationType.Tdr)
        elif sys.argv[i].lower() == "tdt":
            Operations.append(CalibrationType.Tdt)
        elif sys.argv[i].lower() == "-verbose":
            VerboseFlag = True
        elif sys.argv[i].lower() == "-debug":
            DebugFlag = True
        elif sys.argv[i].lower() == "-factory":
            FactoryFlag = True
        elif sys.argv[i].lower() == "-interval":
            if i + 1 < len(sys.argv):
                Interval = int(sys.argv[i + 1])
                i = i + 1
        elif sys.argv[i].lower() == "-cycles":
            if i + 1 < len(sys.argv):
                Cycles = int(sys.argv[i + 1])
                i = i + 1
        elif sys.argv[i].lower() == "-prefix":
            if i + 1 < len(sys.argv):
                Prefix = int(sys.argv[i + 1])
                i = i + 1
        elif sys.argv[i].lower() == "-ip":
            if i + 1 < len(sys.argv):
                IPAddress = sys.argv[i + 1]
                i = i + 1
        else:
            print("Unrecognized parameter: " + sys.argv[i])

        i = i + 1

    if IPAddress == "" or len(Operations) == 0 or Cycles < 1:
        print("Usage: SweepStepscopeCalibrations [options] <list of operations]")
        print("Operations: Delay Noise S11 S21 Step Tdr Tdt")
        print("Options:   -ip <ip address> ............... select IP address")
        print("           -interval <seconds> ............ number of seconds between each calibration")
        print("           -cycles <number-of-cycles> ..... number of calibrations to perform")
        print("           -verbose ....................... show verbose messages")
        print("           -debug ......................... show automation command messages")
        print("           -factory ....................... start with factory restore");
        print("           -prefix <output-file-prefix> ... specify prefix for output files")
        exit()

    try:
        Stepscope.setDebugging(DebugFlag)

        if VerboseFlag:
            print("Connect to ip: " + IPAddress)

        Stepscope.Connect(IPAddress)

        serial_number = Stepscope.Const.getSN()

        print("Sweep Stepscope Calibrations")
        print("IP Address........" + IPAddress)
        print("Serial number....." + serial_number)
        print("Build............." + Stepscope.Sys.getBuild())
        print("Architecture......" + Stepscope.Sys.getArchitecture())

        Stepscope.Stop()
        if FactoryFlag:
            Stepscope.RestoreConfiguration("[factory]")
            time.sleep(3)

        for k in range(0, Cycles):
            print("Cycle " + str(k + 1) + ", Start Operation")
            start_time = datetime.now()
            for op in Operations:
                time.sleep(1)  # ensure calib thread is quiet

                dest_filename = (Prefix + "_" + serial_number + "_" + op.name + "_" +
                                 Timestamp + "_" + str(k + 1).zfill(2) + ".csv")

                if op == CalibrationType.Delay or op == CalibrationType.Noise:
                    wait_until_calibration_launched(op)
                    wait_until_calibration_completed()
                    download_operation_file(op, dest_filename)

                elif (op == CalibrationType.S11 or op == CalibrationType.Step or op == CalibrationType.S21 or
                      op == CalibrationType.Tdr or op == CalibrationType.Tdt):
                    wait_until_app_launched(op)
                    wait_until_app_completed(op)
                    download_operation_file(op, dest_filename)

            if datetime.now() < start_time + timedelta(seconds=Interval) and k < Cycles - 1:
                sleep_remaining_seconds = (start_time + timedelta(seconds=Interval) - datetime.now()).total_seconds()

                if VerboseFlag:
                    print("Pause until next cycle:")

                Stepscope.Disconnect()

                while sleep_remaining_seconds > 0:
                    if VerboseFlag:
                        print(str(int(sleep_remaining_seconds)), end="  \r")

                    time.sleep(1)
                    sleep_remaining_seconds = sleep_remaining_seconds - 1

                Stepscope.Connect(IPAddress)

        Stepscope.Disconnect()

    except KeyboardInterrupt:
        print("\nCtrl-C encountered")

    except Exception as e:
        print("Error: " + str(e))

    finally:
        if Stepscope.IsConnected and Stepscope.Calib.getStatus() == Stepscope.Calib.Status.Running:
            Stepscope.Calib.Cancel()
        if Stepscope.IsConnected:
            Stepscope.Disconnect()

    if VerboseFlag:
        print("Terminating normally")
# EOF
