/* autogenPega.cpp */
//================================================================================
// BOOST SOFTWARE LICENSE
//
// Copyright 2020 BitWise Laboratories Inc.
// Author.......Jim Waschura
// Contact......info@bitwiselabs.com
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.
//================================================================================

#include <stdio.h> /* fprintf, stderr */
#include <unistd.h> /* usleep */
#include <math.h> /* fabs */

#include "SocketDevice.h"
#include "autogenPega.h"

/* ================================================================ */

char* BranchED::getAlignDataMsg(char *buffer,int buflen) /* Data alignment results */
{
    return QueryResponse(buffer,buflen,"AlignDataMsg?\n");
}

bool BranchED::getAutoResync() /* Auto Resync Enable */
{
    return QueryResponse_bool("AutoResync?\n");
}

void BranchED::setAutoResync(bool newValue) /* Auto Resync Enable */
{
    SendCommand("AutoResync %c\n",newValue?'T':'F');
}

double BranchED::getBitRateGHz() /* Bit Rate */
{
    return QueryResponse_double("BitRate?\n");
}

double BranchED::getCalibRateGHz() /* Calibration input Rate */
{
    return QueryResponse_double("CalibRate?\n");
}

double BranchED::getDelayPS() /* Delay */
{
    return QueryResponse_double("Delay?\n");
}

void BranchED::setDelayPS(double newValue) /* Delay */
{
    SendCommand("Delay %lf\n",newValue);
}

const char *BranchED::DetPatt_Strings[] =
{
    "AllZeros",
    "AllOnes",
    "Prbs7",
    "InvPrbs7",
    "Prbs11",
    "InvPrbs11",
    "Prbs13",
    "InvPrbs13",
    "Prbs15",
    "InvPrbs15",
    "Prbs20",
    "InvPrbs20",
    "Prbs23",
    "InvPrbs23",
    "Prbs31",
    "InvPrbs31",
    "Grab",
    "InvGrab",
    "None",
    "Unknown",
    0
};

BranchED::DetPatt BranchED::getDetPatt()
{
    return (DetPatt)QueryResponse_enum(DetPatt_Strings,"DetPatt?\n");
}

bool BranchED::getEnabled() /* Calibration channel enabled */
{
    return QueryResponse_bool("Enabled?\n");
}

void BranchED::setEnabled(bool newValue) /* Calibration channel enabled */
{
    SendCommand("Enabled %c\n",newValue?'T':'F');
}

double BranchED::getEyeRateGHz() /* Eye Rate */
{
    return QueryResponse_double("EyeRate?\n");
}

const char *BranchED::EyeSubrate_Strings[] =
{
    "DivBy1",
    "DivBy2",
    "DivBy4",
    "DivBy8",
    0
};

BranchED::EyeSubrate BranchED::getEyeSubrate()
{
    return (EyeSubrate)QueryResponse_enum(EyeSubrate_Strings,"EyeSubrate?\n");
}

void BranchED::setEyeSubrate(EyeSubrate newValue )
{
    SendCommand("EyeSubrate \"%s\"\n",EyeSubrate_Strings[(int)newValue]);
}

const char *BranchED::GrabLen_Strings[] =
{
    "32",
    "64",
    "96",
    "128",
    "160",
    "192",
    0
};

BranchED::GrabLen BranchED::getGrabLen()
{
    return (GrabLen)QueryResponse_enum(GrabLen_Strings,"GrabLen?\n");
}

void BranchED::setGrabLen(GrabLen newValue )
{
    SendCommand("GrabLen \"%s\"\n",GrabLen_Strings[(int)newValue]);
}

char* BranchED::getGrabPatt(char *buffer,int buflen) /* Grabbed pattern 32-bit word hex values */
{
    return QueryResponse(buffer,buflen,"GrabPatt?\n");
}

bool BranchED::getInProgress() /* Aligning in progress */
{
    return QueryResponse_bool("InProgress?\n");
}

bool BranchED::getInSync() /* In Sync Flag */
{
    return QueryResponse_bool("InSync?\n");
}

bool BranchED::getMonitor() /* Pattern change and data rate monitoring enable */
{
    return QueryResponse_bool("Monitor?\n");
}

void BranchED::setMonitor(bool newValue) /* Pattern change and data rate monitoring enable */
{
    SendCommand("Monitor %c\n",newValue?'T':'F');
}

const char *BranchED::Patt_Strings[] =
{
    "AllZeros",
    "AllOnes",
    "Prbs7",
    "InvPrbs7",
    "Prbs11",
    "InvPrbs11",
    "Prbs13",
    "InvPrbs13",
    "Prbs15",
    "InvPrbs15",
    "Prbs20",
    "InvPrbs20",
    "Prbs23",
    "InvPrbs23",
    "Prbs31",
    "InvPrbs31",
    "Grab",
    "Auto",
    "Unknown",
    0
};

BranchED::Patt BranchED::getPatt()
{
    return (Patt)QueryResponse_enum(Patt_Strings,"Patt?\n");
}

void BranchED::setPatt(Patt newValue )
{
    SendCommand("Patt \"%s\"\n",Patt_Strings[(int)newValue]);
}

int BranchED::getResyncThresh() /* Resync Threshold */
{
    return QueryResponse_int("ResyncThresh?\n");
}

void BranchED::setResyncThresh(int newValue) /* Resync Threshold */
{
    SendCommand("ResyncThresh %d\n",newValue);
}

double BranchED::getTermDCLevelMV() /* Termination DC Level */
{
    return QueryResponse_double("TermDCLevel?\n");
}

void BranchED::setTermDCLevelMV(double newValue) /* Termination DC Level */
{
    SendCommand("TermDCLevel %lf\n",newValue);
}

const char *BranchED::TermType_Strings[] =
{
    "DC",
    "AC",
    0
};

BranchED::TermType BranchED::getTermType()
{
    return (TermType)QueryResponse_enum(TermType_Strings,"TermType?\n");
}

void BranchED::setTermType(TermType newValue )
{
    SendCommand("TermType \"%s\"\n",TermType_Strings[(int)newValue]);
}

double BranchED::getThreshMV() /* Threshold */
{
    return QueryResponse_double("Thresh?\n");
}

void BranchED::setThreshMV(double newValue) /* Threshold */
{
    SendCommand("Thresh %lf\n",newValue);
}

bool BranchED::getUsingEye() /* Using Eye Diagramming */
{
    return QueryResponse_bool("UsingEye?\n");
}


const char *BranchED::AlignBy_Strings[] =
{ "Time","Volts","All","PrbsVolts","PrbsAll",0};

void BranchED::AlignData(AlignBy alignType ) /* Perform data alignment, parameter: Time, Volts, All (Dflt), PrbsVolts, PrbsAll */
{
    SendCommand("AlignData %s\n",AlignBy_Strings[(int)alignType] );

	double now = SocketDevice::timestamp();
	double begin_time = now;
	double timeout = now + 30.0;

	while( now < timeout && QueryResponse_bool( "InProgress?\n")==true )
	{
		usleep(500*1000);
		now = SocketDevice::timestamp();

		if(getDebugging())
			fprintf(stderr,"Aligning %.1lf\n", now-begin_time);
	}

	if( now >=timeout )
		throw "[Timeout_During_Alignment]";

	char buffer[4096];
	QueryResponse(buffer,4096,"AlignDataMsg?\n");

	/* Responds with:          */
	/*    "Aligning ..."       */
	/*    "Success, 999 mV pp" */
	/*    "[Error_Message]"    */

	static const char *SUCCESS_PREFIX = "SUCCESS";
	//static const char *ALIGNING_PREFIX = "ALIGNING" ;

	if( strncasecmp( buffer, SUCCESS_PREFIX, strlen(SUCCESS_PREFIX) ) )
	{
		static char static_buffer[256] ;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wformat-overflow"
#pragma GCC diagnostic ignored "-Wformat-truncation"
		snprintf( static_buffer,256,"[%s]", buffer );
#pragma GCC diagnostic pop

		throw( (const char *)static_buffer );
	}
}

void BranchED::Resync() /* Manual Resync */
{
    SendCommand("Resync\n");
}

/* ================================================================ */

const char *BranchEDSampler::DataSource_Strings[] =
{
    "Ch0",
    "Ch1",
    0
};

BranchEDSampler::DataSource BranchEDSampler::getDataSource()
{
    return (DataSource)QueryResponse_enum(DataSource_Strings,"DataSource?\n");
}

void BranchEDSampler::setDataSource(DataSource newValue )
{
    SendCommand("DataSource \"%s\"\n",DataSource_Strings[(int)newValue]);
}

double BranchEDSampler::getDelayRangePS() /* Sampler delay range */
{
    return QueryResponse_double("DelayRange?\n");
}

double BranchEDSampler::getDelaysPS(int index) /* Sampler delay values by index (0=Cal 1=Deferred) */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("Delays[%d]?\n",index);
}

void BranchEDSampler::setDelaysPS(int index,double newValue) /* Sampler delay values by index (0=Cal 1=Deferred) */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("Delays[%d] %lf\n",index,newValue);
}

const char *BranchEDSampler::HControl_Strings[] =
{
    "ClockDelay",
    "NegDataDelay",
    "ClockMinusDataDelay",
    0
};

BranchEDSampler::HControl BranchEDSampler::getHControl()
{
    return (HControl)QueryResponse_enum(HControl_Strings,"HControl?\n");
}

void BranchEDSampler::setHControl(HControl newValue )
{
    SendCommand("HControl \"%s\"\n",HControl_Strings[(int)newValue]);
}

const char *BranchEDSampler::Mode_Strings[] =
{
    "CalInput",
    "DeferredEye",
    0
};

BranchEDSampler::Mode BranchEDSampler::getMode()
{
    return (Mode)QueryResponse_enum(Mode_Strings,"Mode?\n");
}

void BranchEDSampler::setMode(Mode newValue )
{
    SendCommand("Mode \"%s\"\n",Mode_Strings[(int)newValue]);
}

double BranchEDSampler::getTimePS() /* Sample time */
{
    return QueryResponse_double("Time?\n");
}

void BranchEDSampler::setTimePS(double newValue) /* Sample time */
{
    SendCommand("Time %lf\n",newValue);
}

const char *BranchEDSampler::VControl_Strings[] =
{
    "Ch0Pos",
    "Ch0Neg",
    "Ch1Pos",
    "Ch1Neg",
    0
};

BranchEDSampler::VControl BranchEDSampler::getVControl()
{
    return (VControl)QueryResponse_enum(VControl_Strings,"VControl?\n");
}

void BranchEDSampler::setVControl(VControl newValue )
{
    SendCommand("VControl \"%s\"\n",VControl_Strings[(int)newValue]);
}

double BranchEDSampler::getVoltsMV() /* Sampler voltage */
{
    return QueryResponse_double("Volts?\n");
}

void BranchEDSampler::setVoltsMV(double newValue) /* Sampler voltage */
{
    SendCommand("Volts %lf\n",newValue);
}

double BranchEDSampler::getVoltsMaxMV() /* Sample voltage maximum */
{
    return QueryResponse_double("VoltsMax?\n");
}

double BranchEDSampler::getVoltsMinMV() /* Sample voltage minimum */
{
    return QueryResponse_double("VoltsMin?\n");
}

/* ================================================================ */

double BranchErr::getABER() /* Accumulated BER Result */
{
    return QueryResponse_double("ABER?\n");
}

char* BranchErr::getBerReport(char *buffer,int buflen) /* Ber report of 15 things */
{
    return QueryResponse(buffer,buflen,"BerReport?\n");
}

char *BranchErr::getBinary(int *pcount) /* Binary Data - Must free() return value */
{
    return QueryBinaryResponse(pcount,"Binary?\n");
}

void BranchErr::setBinary(char *buffer,int count) /* Binary Data */
{
    SendBinaryCommand(buffer,count,"Binary\n");
}

long long BranchErr::getBits() /* Bit Count Result */
{
    return QueryResponse_int64("Bits?\n");
}

double BranchErr::getElapsedSeconds() /* Elapsed Time Seconds */
{
    return QueryResponse_double("Elapsed?\n");
}

long long BranchErr::getErrors() /* Bit Errors Count Result */
{
    return QueryResponse_int64("Errors?\n");
}

double BranchErr::getIBER() /* Instantaneous BER Result */
{
    return QueryResponse_double("IBER?\n");
}

long long BranchErr::getResyncCount() /* Resync Count */
{
    return QueryResponse_int64("ResyncCount?\n");
}

const char *BranchErr::Running_Strings[] =
{
    "Stop",
    "Run",
    "RunOnce",
    0
};

BranchErr::Running BranchErr::getRunning()
{
    return (Running)QueryResponse_enum(Running_Strings,"Running?\n");
}

int BranchErr::getSequence() /* Run Sequence */
{
    return QueryResponse_int("Sequence?\n");
}

int BranchErr::getSerial() /* Serial Number of Integration */
{
    return QueryResponse_int("Serial?\n");
}

char* BranchErr::Csv(char *buffer,int buflen) /* PegaED Csv, Todo:add arguments */
{
    fprintf(stderr,"BranchErr::Csv(), Todo: add arguments if needed\n");
    return QueryResponse(buffer,buflen,"Csv?\n");
}

char* BranchErr::Csv2(char *buffer,int buflen) /* PegaErr Csv, Todo:add arguments */
{
    fprintf(stderr,"BranchErr::Csv2(), Todo: add arguments if needed\n");
    return QueryResponse(buffer,buflen,"Csv2?\n");
}

void BranchErr::Fit() /* PegaED Chart Fit, Todo:add arguments */
{
    fprintf(stderr,"BranchErr::Fit(), Todo: add arguments if needed\n");
    SendCommand("Fit\n");
}

void BranchErr::Reset() /* Reset position, Todo:add arguments */
{
    fprintf(stderr,"BranchErr::Reset(), Todo: add arguments if needed\n");
    SendCommand("Reset\n");
}

/* ================================================================ */

const char *BranchErrCfg::BitsFmt_Strings[] =
{
    "Scientific",
    "Decimal",
    0
};

BranchErrCfg::BitsFmt BranchErrCfg::getBitsFmt()
{
    return (BitsFmt)QueryResponse_enum(BitsFmt_Strings,"BitsFmt?\n");
}

void BranchErrCfg::setBitsFmt(BitsFmt newValue )
{
    SendCommand("BitsFmt \"%s\"\n",BitsFmt_Strings[(int)newValue]);
}

double BranchErrCfg::getIntervalSeconds() /* Update interval */
{
    return QueryResponse_double("Interval?\n");
}

void BranchErrCfg::setIntervalSeconds(double newValue) /* Update interval */
{
    SendCommand("Interval %lf\n",newValue);
}

int BranchErrCfg::getReclen() /* Record Length */
{
    return QueryResponse_int("Reclen?\n");
}

void BranchErrCfg::setReclen(int newValue) /* Record Length */
{
    SendCommand("Reclen %d\n",newValue);
}

bool BranchErrCfg::getShowSettings() /* Show Settings */
{
    return QueryResponse_bool("ShowSettings?\n");
}

void BranchErrCfg::setShowSettings(bool newValue) /* Show Settings */
{
    SendCommand("ShowSettings %c\n",newValue?'T':'F');
}

bool BranchErrCfg::getShowStripSettings() /* Show Strip Chart Settings */
{
    return QueryResponse_bool("ShowStripSettings?\n");
}

void BranchErrCfg::setShowStripSettings(bool newValue) /* Show Strip Chart Settings */
{
    SendCommand("ShowStripSettings %c\n",newValue?'T':'F');
}

/* ================================================================ */

double BranchErrChart::getBottomLogBER() /* Chart Bottom */
{
    return QueryResponse_double("Bottom?\n");
}

void BranchErrChart::setBottomLogBER(double newValue) /* Chart Bottom */
{
    SendCommand("Bottom %lf\n",newValue);
}

bool BranchErrChart::getCursAvail(int index) /* Chart Cursor Available */
{
    if(index<0||index>=11) throw "[Index_Out_Of_Range]";
    return QueryResponse_bool("CursAvail[%d]?\n",index);
}

bool BranchErrChart::getCursEnabled(int index) /* Chart Cursor Enabled */
{
    if(index<0||index>=11) throw "[Index_Out_Of_Range]";
    return QueryResponse_bool("CursEnabled[%d]?\n",index);
}

void BranchErrChart::setCursEnabled(int index,bool newValue) /* Chart Cursor Enabled */
{
    if(index<0||index>=11) throw "[Index_Out_Of_Range]";
    SendCommand("CursEnabled[%d] %c\n",index,newValue?'T':'F');
}

char* BranchErrChart::getCursLabel(int index,char *buffer,int buflen) /* Chart Cursor Label */
{
    if(index<0||index>=11) throw "[Index_Out_Of_Range]";
    return QueryResponse(buffer,buflen,"CursLabel[%d]?\n",index);
}

double BranchErrChart::getCursValue(int index) /* Chart Cursor Value */
{
    if(index<0||index>=11) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("CursValue[%d]?\n",index);
}

void BranchErrChart::setCursValue(int index,double newValue) /* Chart Cursor Value */
{
    if(index<0||index>=11) throw "[Index_Out_Of_Range]";
    SendCommand("CursValue[%d] %lf\n",index,newValue);
}

double BranchErrChart::getHeightLogBER() /* Chart Height */
{
    return QueryResponse_double("Height?\n");
}

void BranchErrChart::setHeightLogBER(double newValue) /* Chart Height */
{
    SendCommand("Height %lf\n",newValue);
}

double BranchErrChart::getLeftSeconds() /* Chart Left */
{
    return QueryResponse_double("Left?\n");
}

void BranchErrChart::setLeftSeconds(double newValue) /* Chart Left */
{
    SendCommand("Left %lf\n",newValue);
}

double BranchErrChart::getLimits(int index) /* Chart Limits (LRBT) */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("Limits[%d]?\n",index);
}

bool BranchErrChart::getLocked() /* Chart Locked */
{
    return QueryResponse_bool("Locked?\n");
}

void BranchErrChart::setLocked(bool newValue) /* Chart Locked */
{
    SendCommand("Locked %c\n",newValue?'T':'F');
}

bool BranchErrChart::getLogscale() /* Chart LogScale */
{
    return QueryResponse_bool("Logscale?\n");
}

void BranchErrChart::setLogscale(bool newValue) /* Chart LogScale */
{
    SendCommand("Logscale %c\n",newValue?'T':'F');
}

const char *BranchErrChart::Scroll_Strings[] =
{
    "None",
    "X1",
    "X2",
    "X3",
    "X4",
    "DX12",
    "DX34",
    "XPan",
    "XScale",
    "Y1",
    "Y2",
    "Y3",
    "Y4",
    "DY12",
    "DY34",
    "YPan",
    "YScale",
    "P1",
    "P2",
    "P3",
    0
};

BranchErrChart::Scroll BranchErrChart::getScroll()
{
    return (Scroll)QueryResponse_enum(Scroll_Strings,"Scroll?\n");
}

void BranchErrChart::setScroll(Scroll newValue )
{
    SendCommand("Scroll \"%s\"\n",Scroll_Strings[(int)newValue]);
}

bool BranchErrChart::getShowMemory() /* Show memories */
{
    return QueryResponse_bool("ShowMemory?\n");
}

void BranchErrChart::setShowMemory(bool newValue) /* Show memories */
{
    SendCommand("ShowMemory %c\n",newValue?'T':'F');
}

bool BranchErrChart::getShowOverlays() /* Show overlays */
{
    return QueryResponse_bool("ShowOverlays?\n");
}

void BranchErrChart::setShowOverlays(bool newValue) /* Show overlays */
{
    SendCommand("ShowOverlays %c\n",newValue?'T':'F');
}

char* BranchErrChart::getTitle(char *buffer,int buflen) /* Chart Title */
{
    return QueryResponse(buffer,buflen,"Title?\n");
}

double BranchErrChart::getWidthSeconds() /* Chart Width */
{
    return QueryResponse_double("Width?\n");
}

void BranchErrChart::setWidthSeconds(double newValue) /* Chart Width */
{
    SendCommand("Width %lf\n",newValue);
}

/* ================================================================ */

char *BranchEye::getBinary(int *pcount) /* Binary Data - Must free() return value */
{
    return QueryBinaryResponse(pcount,"Binary?\n");
}

void BranchEye::setBinary(char *buffer,int count) /* Binary Data */
{
    SendBinaryCommand(buffer,count,"Binary\n");
}

double BranchEye::getElapsedSeconds() /* Elapsed Time Seconds */
{
    return QueryResponse_double("Elapsed?\n");
}

const char *BranchEye::Running_Strings[] =
{
    "Stop",
    "Run",
    "RunOnce",
    0
};

BranchEye::Running BranchEye::getRunning()
{
    return (Running)QueryResponse_enum(Running_Strings,"Running?\n");
}

int BranchEye::getSequence() /* Run Sequence */
{
    return QueryResponse_int("Sequence?\n");
}

bool BranchEye::getShowSettings() /* Show gui settings panel */
{
    return QueryResponse_bool("ShowSettings?\n");
}

void BranchEye::setShowSettings(bool newValue) /* Show gui settings panel */
{
    SendCommand("ShowSettings %c\n",newValue?'T':'F');
}

void BranchEye::Fit() /* Fit chart, Todo:add arguments */
{
    fprintf(stderr,"BranchEye::Fit(), Todo: add arguments if needed\n");
    SendCommand("Fit\n");
}

char* BranchEye::Jpg(char *buffer,int buflen) /* PegaEye Jpg Image, Todo:add arguments */
{
    fprintf(stderr,"BranchEye::Jpg(), Todo: add arguments if needed\n");
    return QueryResponse(buffer,buflen,"Jpg?\n");
}

void BranchEye::Reset() /* Reset position, Todo:add arguments */
{
    fprintf(stderr,"BranchEye::Reset(), Todo: add arguments if needed\n");
    SendCommand("Reset\n");
}

/* ================================================================ */

double BranchEyeCfg::getBottom() /* Acquisition Voltage bottom */
{
    return QueryResponse_double("Bottom?\n");
}

double BranchEyeCfg::getBright() /* Image Brightness */
{
    return QueryResponse_double("Bright?\n");
}

void BranchEyeCfg::setBright(double newValue) /* Image Brightness */
{
    SendCommand("Bright %lf\n",newValue);
}

int BranchEyeCfg::getColumns() /* Columns in Image */
{
    return QueryResponse_int("Columns?\n");
}

void BranchEyeCfg::setColumns(int newValue) /* Columns in Image */
{
    SendCommand("Columns %d\n",newValue);
}

int BranchEyeCfg::getDelaySettleUSec() /* Delay Settle Time */
{
    return QueryResponse_int("DelaySettle?\n");
}

void BranchEyeCfg::setDelaySettleUSec(int newValue) /* Delay Settle Time */
{
    SendCommand("DelaySettle %d\n",newValue);
}

double BranchEyeCfg::getDepthBits() /* E2 Depth */
{
    return QueryResponse_double("Depth?\n");
}

void BranchEyeCfg::setDepthBits(double newValue) /* E2 Depth */
{
    SendCommand("Depth %lf\n",newValue);
}

int BranchEyeCfg::getDivisions(int index) /* Number of divisions H,V */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_int("Divisions[%d]?\n",index);
}

void BranchEyeCfg::setDivisions(int index,int newValue) /* Number of divisions H,V */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("Divisions[%d] %d\n",index,newValue);
}

bool BranchEyeCfg::getEyeSync() /* Eye Sync mode */
{
    return QueryResponse_bool("EyeSync?\n");
}

double BranchEyeCfg::getFloorNoSync() /* Floor threshold for No-Sync mode (500K) */
{
    return QueryResponse_double("FloorNoSync?\n");
}

void BranchEyeCfg::setFloorNoSync(double newValue) /* Floor threshold for No-Sync mode (500K) */
{
    SendCommand("FloorNoSync %lf\n",newValue);
}

double BranchEyeCfg::getFloorSync() /* Floor threshold for Sync mode (500K) */
{
    return QueryResponse_double("FloorSync?\n");
}

void BranchEyeCfg::setFloorSync(double newValue) /* Floor threshold for Sync mode (500K) */
{
    SendCommand("FloorSync %lf\n",newValue);
}

double BranchEyeCfg::getHeight() /* Acquisition Voltage height */
{
    return QueryResponse_double("Height?\n");
}

double BranchEyeCfg::getOffset() /* Acquisition Time offset */
{
    return QueryResponse_double("Offset?\n");
}

double BranchEyeCfg::getPerDiv(int index) /* Span per division */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("PerDiv[%d]?\n",index);
}

void BranchEyeCfg::setPerDiv(int index,double newValue) /* Span per division */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("PerDiv[%d] %lf\n",index,newValue);
}

int BranchEyeCfg::getPersist() /* Persistence */
{
    return QueryResponse_int("Persist?\n");
}

void BranchEyeCfg::setPersist(int newValue) /* Persistence */
{
    SendCommand("Persist %d\n",newValue);
}

int BranchEyeCfg::getRows() /* Rows in Image */
{
    return QueryResponse_int("Rows?\n");
}

void BranchEyeCfg::setRows(int newValue) /* Rows in Image */
{
    SendCommand("Rows %d\n",newValue);
}

double BranchEyeCfg::getScalePcnt() /* Scale ratio percentage */
{
    return QueryResponse_double("Scale?\n");
}

void BranchEyeCfg::setScalePcnt(double newValue) /* Scale ratio percentage */
{
    SendCommand("Scale %lf\n",newValue);
}

bool BranchEyeCfg::getShowRaw() /* Show Raw Data */
{
    return QueryResponse_bool("ShowRaw?\n");
}

void BranchEyeCfg::setShowRaw(bool newValue) /* Show Raw Data */
{
    SendCommand("ShowRaw %c\n",newValue?'T':'F');
}

double BranchEyeCfg::getSpan() /* Acquisition Time span */
{
    return QueryResponse_double("Span?\n");
}

int BranchEyeCfg::getThreshSettleUSec() /* Threshold Settle Time */
{
    return QueryResponse_int("ThreshSettle?\n");
}

void BranchEyeCfg::setThreshSettleUSec(int newValue) /* Threshold Settle Time */
{
    SendCommand("ThreshSettle %d\n",newValue);
}

bool BranchEyeCfg::getUseClip() /* Use Clipping for Floor level */
{
    return QueryResponse_bool("UseClip?\n");
}

void BranchEyeCfg::setUseClip(bool newValue) /* Use Clipping for Floor level */
{
    SendCommand("UseClip %c\n",newValue?'T':'F');
}

/* ================================================================ */

double BranchEyeChart::getBottomMV() /* Chart Bottom */
{
    return QueryResponse_double("Bottom?\n");
}

void BranchEyeChart::setBottomMV(double newValue) /* Chart Bottom */
{
    SendCommand("Bottom %lf\n",newValue);
}

bool BranchEyeChart::getCursAvail(int index) /* Chart Cursor Available */
{
    if(index<0||index>=11) throw "[Index_Out_Of_Range]";
    return QueryResponse_bool("CursAvail[%d]?\n",index);
}

bool BranchEyeChart::getCursEnabled(int index) /* Chart Cursor Enabled */
{
    if(index<0||index>=11) throw "[Index_Out_Of_Range]";
    return QueryResponse_bool("CursEnabled[%d]?\n",index);
}

void BranchEyeChart::setCursEnabled(int index,bool newValue) /* Chart Cursor Enabled */
{
    if(index<0||index>=11) throw "[Index_Out_Of_Range]";
    SendCommand("CursEnabled[%d] %c\n",index,newValue?'T':'F');
}

char* BranchEyeChart::getCursLabel(int index,char *buffer,int buflen) /* Chart Cursor Label */
{
    if(index<0||index>=11) throw "[Index_Out_Of_Range]";
    return QueryResponse(buffer,buflen,"CursLabel[%d]?\n",index);
}

double BranchEyeChart::getCursValue(int index) /* Chart Cursor Value */
{
    if(index<0||index>=11) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("CursValue[%d]?\n",index);
}

void BranchEyeChart::setCursValue(int index,double newValue) /* Chart Cursor Value */
{
    if(index<0||index>=11) throw "[Index_Out_Of_Range]";
    SendCommand("CursValue[%d] %lf\n",index,newValue);
}

double BranchEyeChart::getHeightMV() /* Chart Height */
{
    return QueryResponse_double("Height?\n");
}

void BranchEyeChart::setHeightMV(double newValue) /* Chart Height */
{
    SendCommand("Height %lf\n",newValue);
}

double BranchEyeChart::getLeftPS() /* Chart Left */
{
    return QueryResponse_double("Left?\n");
}

void BranchEyeChart::setLeftPS(double newValue) /* Chart Left */
{
    SendCommand("Left %lf\n",newValue);
}

double BranchEyeChart::getLimits(int index) /* Chart Limits (LRBT) */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("Limits[%d]?\n",index);
}

bool BranchEyeChart::getLocked() /* Chart Locked */
{
    return QueryResponse_bool("Locked?\n");
}

void BranchEyeChart::setLocked(bool newValue) /* Chart Locked */
{
    SendCommand("Locked %c\n",newValue?'T':'F');
}

bool BranchEyeChart::getLogscale() /* Chart LogScale */
{
    return QueryResponse_bool("Logscale?\n");
}

void BranchEyeChart::setLogscale(bool newValue) /* Chart LogScale */
{
    SendCommand("Logscale %c\n",newValue?'T':'F');
}

const char *BranchEyeChart::Scroll_Strings[] =
{
    "None",
    "X1",
    "X2",
    "X3",
    "X4",
    "DX12",
    "DX34",
    "XPan",
    "XScale",
    "Y1",
    "Y2",
    "Y3",
    "Y4",
    "DY12",
    "DY34",
    "YPan",
    "YScale",
    "P1",
    "P2",
    "P3",
    0
};

BranchEyeChart::Scroll BranchEyeChart::getScroll()
{
    return (Scroll)QueryResponse_enum(Scroll_Strings,"Scroll?\n");
}

void BranchEyeChart::setScroll(Scroll newValue )
{
    SendCommand("Scroll \"%s\"\n",Scroll_Strings[(int)newValue]);
}

bool BranchEyeChart::getShowMemory() /* Show memories */
{
    return QueryResponse_bool("ShowMemory?\n");
}

void BranchEyeChart::setShowMemory(bool newValue) /* Show memories */
{
    SendCommand("ShowMemory %c\n",newValue?'T':'F');
}

bool BranchEyeChart::getShowOverlays() /* Show overlays */
{
    return QueryResponse_bool("ShowOverlays?\n");
}

void BranchEyeChart::setShowOverlays(bool newValue) /* Show overlays */
{
    SendCommand("ShowOverlays %c\n",newValue?'T':'F');
}

char* BranchEyeChart::getTitle(char *buffer,int buflen) /* Chart Title */
{
    return QueryResponse(buffer,buflen,"Title?\n");
}

double BranchEyeChart::getWidthPS() /* Chart Width */
{
    return QueryResponse_double("Width?\n");
}

void BranchEyeChart::setWidthPS(double newValue) /* Chart Width */
{
    SendCommand("Width %lf\n",newValue);
}

/* ================================================================ */

bool BranchPG::getAllOn() /* Enable clock and both channels of data */
{
    return QueryResponse_bool("AllOn?\n");
}

void BranchPG::setAllOn(bool newValue) /* Enable clock and both channels of data */
{
    SendCommand("AllOn %c\n",newValue?'T':'F');
}

const char *BranchPG::Connectors_Strings[] =
{
    "Ch0Pos",
    "Ch1Pos",
    "Ch0Neg",
    "Ch1Neg",
    0
};

BranchPG::Connectors BranchPG::getConnectors(int index)
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return (Connectors)QueryResponse_enum(Connectors_Strings,"Connectors[%d]?\n",index);
}

void BranchPG::setConnectors(int index,Connectors newValue )
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    SendCommand("Connectors[%d] \"%s\"\n",index,Connectors_Strings[(int)newValue]);
}

double BranchPG::getDelayPS(int index) /* Delay */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("Delay[%d]?\n",index);
}

void BranchPG::setDelayPS(int index,double newValue) /* Delay */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("Delay[%d] %lf\n",index,newValue);
}

int BranchPG::getHwVersion() /* Hardware version */
{
    return QueryResponse_int("HwVersion?\n");
}

const char *BranchPG::LinkMode_Strings[] =
{
    "Ch0",
    "Ch1",
    "Unlinked",
    "Linked",
    "Interleaved",
    0
};

BranchPG::LinkMode BranchPG::getLinkMode()
{
    return (LinkMode)QueryResponse_enum(LinkMode_Strings,"LinkMode?\n");
}

void BranchPG::setLinkMode(LinkMode newValue )
{
    SendCommand("LinkMode \"%s\"\n",LinkMode_Strings[(int)newValue]);
}

bool BranchPG::getLinkTapChanges() /* Link Tap changes across channels */
{
    return QueryResponse_bool("LinkTapChanges?\n");
}

void BranchPG::setLinkTapChanges(bool newValue) /* Link Tap changes across channels */
{
    SendCommand("LinkTapChanges %c\n",newValue?'T':'F');
}

bool BranchPG::getMonitor() /* Frequency and Amp Current monitoring enable */
{
    return QueryResponse_bool("Monitor?\n");
}

void BranchPG::setMonitor(bool newValue) /* Frequency and Amp Current monitoring enable */
{
    SendCommand("Monitor %c\n",newValue?'T':'F');
}

double BranchPG::getOperatingRateGHz() /* Operating clock rate, -1 means not set */
{
    return QueryResponse_double("OperatingRate?\n");
}

void BranchPG::setOperatingRateGHz(double newValue) /* Operating clock rate, -1 means not set */
{
    SendCommand("OperatingRate %lf\n",newValue);
}

const char *BranchPG::Pattern_Strings[] =
{
    "Zeros",
    "Prbs7",
    "Prbs11",
    "Prbs13",
    "Prbs15",
    "Prbs20",
    "Prbs23",
    "Prbs31",
    "User",
    "Ones",
    "InvPrbs7",
    "InvPrbs11",
    "InvPrbs13",
    "InvPrbs15",
    "InvPrbs20",
    "InvPrbs23",
    "InvPrbs31",
    "InvUser",
    0
};

BranchPG::Pattern BranchPG::getPattern(int index)
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return (Pattern)QueryResponse_enum(Pattern_Strings,"Pattern[%d]?\n",index);
}

void BranchPG::setPattern(int index,Pattern newValue )
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("Pattern[%d] \"%s\"\n",index,Pattern_Strings[(int)newValue]);
}

int BranchPG::getPrbsBitOffset(int index) /* Pattern bit offset */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_int("PrbsBitOffset[%d]?\n",index);
}

void BranchPG::setPrbsBitOffset(int index,int newValue) /* Pattern bit offset */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("PrbsBitOffset[%d] %d\n",index,newValue);
}


/* notice clock rate is 1/2 data rate */
void BranchPG::WaitForClockToSettle( double targetClockGHz, double timeoutSec, double toleranceGHz )
{
	double now = SocketDevice::timestamp();
	double timeout = now + timeoutSec;
	double readGHz = getReadRateGHz();

	while( now<timeout )
	{
		if(getDebugging())
			fprintf(stderr,"Settle %.3lf GHz\n", readGHz );

		if( fabs(readGHz-targetClockGHz) <= toleranceGHz )
			break;

		usleep(500*1000);
		now = SocketDevice::timestamp();

		readGHz = getReadRateGHz();
	}

	if( now >=timeout )
		throw "[Timeout_During_Clock_Settle]";
}

double BranchPG::getReadRateGHz() /* Readback rate */
{
    return QueryResponse_double("ReadRate?\n");
}

bool BranchPG::getUseCombiner() /* Use PAM4 Combiner level settings */
{
    return QueryResponse_bool("UseCombiner?\n");
}

void BranchPG::setUseCombiner(bool newValue) /* Use PAM4 Combiner level settings */
{
    SendCommand("UseCombiner %c\n",newValue?'T':'F');
}

int BranchPG::getUserAvailableBitmask(int index) /* User Pattern pages available bit mask */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_int("UserAvailable[%d]?\n",index);
}

const char *BranchPG::UserPage_Strings[] =
{
    "PageA",
    "PageB",
    0
};

BranchPG::UserPage BranchPG::getUserPage(int index)
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return (UserPage)QueryResponse_enum(UserPage_Strings,"UserPage[%d]?\n",index);
}

void BranchPG::setUserPage(int index,UserPage newValue )
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("UserPage[%d] \"%s\"\n",index,UserPage_Strings[(int)newValue]);
}

void BranchPG::SetDefaults() /* Set defaults, Todo:add arguments */
{
    fprintf(stderr,"BranchPG::SetDefaults(), Todo: add arguments if needed\n");
    SendCommand("SetDefaults\n");
}

void BranchPG::UserPageFlip() /* User Page temporary flip, Todo:add arguments */
{
    fprintf(stderr,"BranchPG::UserPageFlip(), Todo: add arguments if needed\n");
    SendCommand("UserPageFlip\n");
}

/* ================================================================ */

double BranchPGAmp::getAmplMV(int index) /* Amp amplitude setting */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("Ampl[%d]?\n",index);
}

void BranchPGAmp::setAmplMV(int index,double newValue) /* Amp amplitude setting */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("Ampl[%d] %lf\n",index,newValue);
}

const char *BranchPGAmp::Coupling_Strings[] =
{
    "DC",
    "AC",
    0
};

BranchPGAmp::Coupling BranchPGAmp::getCoupling(int index)
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return (Coupling)QueryResponse_enum(Coupling_Strings,"Coupling[%d]?\n",index);
}

void BranchPGAmp::setCoupling(int index,Coupling newValue )
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    SendCommand("Coupling[%d] \"%s\"\n",index,Coupling_Strings[(int)newValue]);
}

double BranchPGAmp::getCrossPcnt(int index) /* Amp crossing point setting (10-90) */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("Cross[%d]?\n",index);
}

void BranchPGAmp::setCrossPcnt(int index,double newValue) /* Amp crossing point setting (10-90) */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("Cross[%d] %lf\n",index,newValue);
}

bool BranchPGAmp::getEnabled(int index) /* Amp enabled, not automatically restored */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_bool("Enabled[%d]?\n",index);
}

void BranchPGAmp::setEnabled(int index,bool newValue) /* Amp enabled, not automatically restored */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("Enabled[%d] %c\n",index,newValue?'T':'F');
}

double BranchPGAmp::getF2PS(int index) /* F2 setting */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("F2[%d]?\n",index);
}

void BranchPGAmp::setF2PS(int index,double newValue) /* F2 setting */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("F2[%d] %lf\n",index,newValue);
}

double BranchPGAmp::getF2MaxPS(int index) /* F2 maximum limit at this frequency */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("F2Max[%d]?\n",index);
}

void BranchPGAmp::setF2MaxPS(int index,double newValue) /* F2 maximum limit at this frequency */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("F2Max[%d] %lf\n",index,newValue);
}

double BranchPGAmp::getF2MinPS(int index) /* F2 minimum limit at this frequency */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("F2Min[%d]?\n",index);
}

void BranchPGAmp::setF2MinPS(int index,double newValue) /* F2 minimum limit at this frequency */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("F2Min[%d] %lf\n",index,newValue);
}

double BranchPGAmp::getOffsMV(int index) /* Amp VOffset */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("Offs[%d]?\n",index);
}

void BranchPGAmp::setOffsMV(int index,double newValue) /* Amp VOffset */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    SendCommand("Offs[%d] %lf\n",index,newValue);
}

/* ================================================================ */

double BranchPGCh0::getFinalTaps(int index) /* Final tap values for Ch-0 (1 Pre, 1 Cursor, 2 Post) */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("FinalTaps[%d]?\n",index);
}

double BranchPGCh0::getIntrinsicTaps(int index) /* Intrinsic tap values for Ch-0 (1 Pre, 1 Cursor, 2 Post) */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("IntrinsicTaps[%d]?\n",index);
}

void BranchPGCh0::setIntrinsicTaps(int index,double newValue) /* Intrinsic tap values for Ch-0 (1 Pre, 1 Cursor, 2 Post) */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    SendCommand("IntrinsicTaps[%d] %lf\n",index,newValue);
}

double BranchPGCh0::getTaps(int index) /* Tap values for Ch-0 (1 Pre, 1 Cursor, 2 Post) */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("Taps[%d]?\n",index);
}

void BranchPGCh0::setTaps(int index,double newValue) /* Tap values for Ch-0 (1 Pre, 1 Cursor, 2 Post) */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    SendCommand("Taps[%d] %lf\n",index,newValue);
}

/* ================================================================ */

double BranchPGCh1::getFinalTaps(int index) /* Final tap values for Ch-1 (1 Pre, 1 Cursor, 2 Post) */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("FinalTaps[%d]?\n",index);
}

double BranchPGCh1::getIntrinsicTaps(int index) /* Intrinsic tap values for Ch-1 (1 Pre, 1 Cursor, 2 Post) */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("IntrinsicTaps[%d]?\n",index);
}

void BranchPGCh1::setIntrinsicTaps(int index,double newValue) /* Intrinsic tap values for Ch-1 (1 Pre, 1 Cursor, 2 Post) */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    SendCommand("IntrinsicTaps[%d] %lf\n",index,newValue);
}

double BranchPGCh1::getTaps(int index) /* Tap values for Ch-1 (1 Pre, 1 Cursor, 2 Post) */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("Taps[%d]?\n",index);
}

void BranchPGCh1::setTaps(int index,double newValue) /* Tap values for Ch-1 (1 Pre, 1 Cursor, 2 Post) */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    SendCommand("Taps[%d] %lf\n",index,newValue);
}

/* ================================================================ */

double BranchPGDiag::getActualAmplMV(int index) /* Actual amplitude */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("ActualAmpl[%d]?\n",index);
}

int BranchPGDiag::getBangStatus(int index) /* Bang-bang status [0]=Adsantec, [1]=Euvis */
{
    if(index<0||index>=3) throw "[Index_Out_Of_Range]";
    return QueryResponse_int("BangStatus[%d]?\n",index);
}

double BranchPGDiag::getMarkDensity(int index) /* Mark Density */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("MarkDensity[%d]?\n",index);
}

double BranchPGDiag::getOpRateGHz(int index) /* Operating clock rate, -1 means not set */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("OpRate[%d]?\n",index);
}

void BranchPGDiag::setOpRateGHz(int index,double newValue) /* Operating clock rate, -1 means not set */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("OpRate[%d] %lf\n",index,newValue);
}

/* ================================================================ */

int BranchPGErr::getInterval128(int index) /* Error inject interval */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_int("Interval[%d]?\n",index);
}

void BranchPGErr::setInterval128(int index,int newValue) /* Error inject interval */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("Interval[%d] %d\n",index,newValue);
}

const char *BranchPGErr::Mode_Strings[] =
{
    "Single",
    "Repeat",
    0
};

BranchPGErr::Mode BranchPGErr::getMode(int index)
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return (Mode)QueryResponse_enum(Mode_Strings,"Mode[%d]?\n",index);
}

void BranchPGErr::setMode(int index,Mode newValue )
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("Mode[%d] \"%s\"\n",index,Mode_Strings[(int)newValue]);
}

double BranchPGErr::getRepeatBER(int index) /* Error inject repeat BER */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("RepeatBER[%d]?\n",index);
}

const char *BranchPGErr::Type_Strings[] =
{
    "None",
    "Err1Bit",
    "Err2Bit",
    "Err3Bit",
    "Err4Bit",
    "Err5Bit",
    "Err10Bit",
    "Err32Bit",
    "Err64Bit",
    "Err128Bit",
    "SepBy1",
    "SepBy2",
    0
};

BranchPGErr::Type BranchPGErr::getType(int index)
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return (Type)QueryResponse_enum(Type_Strings,"Type[%d]?\n",index);
}

void BranchPGErr::setType(int index,Type newValue )
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("Type[%d] \"%s\"\n",index,Type_Strings[(int)newValue]);
}

void BranchPGErr::Single() /* Do single error inject, Todo:add arguments */
{
    fprintf(stderr,"BranchPGErr::Single(), Todo: add arguments if needed\n");
    SendCommand("Single\n");
}

/* ================================================================ */

double BranchPGPam::getAmplMV() /* Pam4 Combiner amplitude */
{
    return QueryResponse_double("Ampl?\n");
}

void BranchPGPam::setAmplMV(double newValue) /* Pam4 Combiner amplitude */
{
    SendCommand("Ampl %lf\n",newValue);
}

double BranchPGPam::getDelayPS() /* Pam4 common delay */
{
    return QueryResponse_double("Delay?\n");
}

void BranchPGPam::setDelayPS(double newValue) /* Pam4 common delay */
{
    SendCommand("Delay %lf\n",newValue);
}

double BranchPGPam::getDelayAlignPS() /* Pam4 Combiner delay alignment */
{
    return QueryResponse_double("DelayAlign?\n");
}

void BranchPGPam::setDelayAlignPS(double newValue) /* Pam4 Combiner delay alignment */
{
    SendCommand("DelayAlign %lf\n",newValue);
}

double BranchPGPam::getOffsMV(int index) /* Pam4 Combiner offset */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("Offs[%d]?\n",index);
}

void BranchPGPam::setOffsMV(int index,double newValue) /* Pam4 Combiner offset */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("Offs[%d] %lf\n",index,newValue);
}

/* ================================================================ */

double BranchPGTerm::getDCLevelMV(int index) /* Termination DC Level */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("DCLevel[%d]?\n",index);
}

void BranchPGTerm::setDCLevelMV(int index,double newValue) /* Termination DC Level */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    SendCommand("DCLevel[%d] %lf\n",index,newValue);
}

double BranchPGTerm::getImpedanceOhms(int index) /* Termination Impedance */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("Impedance[%d]?\n",index);
}

void BranchPGTerm::setImpedanceOhms(int index,double newValue) /* Termination Impedance */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    SendCommand("Impedance[%d] %lf\n",index,newValue);
}

bool BranchPGTerm::getLinkPosNeg(int index) /* Link positive and negative legs for offset and term */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_bool("LinkPosNeg[%d]?\n",index);
}

void BranchPGTerm::setLinkPosNeg(int index,bool newValue) /* Link positive and negative legs for offset and term */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("LinkPosNeg[%d] %c\n",index,newValue?'T':'F');
}

const char *BranchPGTerm::Type_Strings[] =
{
    "DC",
    "AC",
    0
};

BranchPGTerm::Type BranchPGTerm::getType(int index)
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return (Type)QueryResponse_enum(Type_Strings,"Type[%d]?\n",index);
}

void BranchPGTerm::setType(int index,Type newValue )
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    SendCommand("Type[%d] \"%s\"\n",index,Type_Strings[(int)newValue]);
}

/* ================================================================ */

int BranchPGTrig::getIndexBits(int index) /* Trigger index */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse_int("Index[%d]?\n",index);
}

void BranchPGTrig::setIndexBits(int index,int newValue) /* Trigger index */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("Index[%d] %d\n",index,newValue);
}

const char *BranchPGTrig::Type_Strings[] =
{
    "Pattern",
    "Clock64",
    0
};

BranchPGTrig::Type BranchPGTrig::getType(int index)
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return (Type)QueryResponse_enum(Type_Strings,"Type[%d]?\n",index);
}

void BranchPGTrig::setType(int index,Type newValue )
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("Type[%d] \"%s\"\n",index,Type_Strings[(int)newValue]);
}


/* ================================================================ */

double BranchTub::getConfBER() /* Confidence BER */
{
    return QueryResponse_double("ConfBER?\n");
}

void BranchTub::setConfBER(double newValue) /* Confidence BER */
{
    SendCommand("ConfBER %lf\n",newValue);
}

int BranchTub::getConfErrors() /* Number of sufficient errors in BER measurement */
{
    return QueryResponse_int("ConfErrors?\n");
}

double BranchTub::getConfLevel() /* Confidence Level */
{
    return QueryResponse_double("ConfLevel?\n");
}

void BranchTub::setConfLevel(double newValue) /* Confidence Level */
{
    SendCommand("ConfLevel %lf\n",newValue);
}

double BranchTub::getElapsedSeconds() /* Elapsed Time Seconds */
{
    return QueryResponse_double("Elapsed?\n");
}

double BranchTub::getExtrapBER() /* Extrapolation depth BER level */
{
    return QueryResponse_double("ExtrapBER?\n");
}

void BranchTub::setExtrapBER(double newValue) /* Extrapolation depth BER level */
{
    SendCommand("ExtrapBER %lf\n",newValue);
}

double BranchTub::getFitHighBER() /* High BER level for extrapolation basis */
{
    return QueryResponse_double("FitHighBER?\n");
}

void BranchTub::setFitHighBER(double newValue) /* High BER level for extrapolation basis */
{
    SendCommand("FitHighBER %lf\n",newValue);
}

double BranchTub::getMeasureBER() /* Measurement BER level */
{
    return QueryResponse_double("MeasureBER?\n");
}

void BranchTub::setMeasureBER(double newValue) /* Measurement BER level */
{
    SendCommand("MeasureBER %lf\n",newValue);
}

char *BranchTub::getMeta(int *pcount) /* Packed chart meta information binary data - Must free() return value */
{
    return QueryBinaryResponse(pcount,"Meta?\n");
}

void BranchTub::setMeta(char *buffer,int count) /* Packed chart meta information binary data */
{
    SendBinaryCommand(buffer,count,"Meta\n");
}

int BranchTub::getMetaSEQ() /* Chart Meta sequence number */
{
    return QueryResponse_int("MetaSEQ?\n");
}

int BranchTub::getPointCount() /* Number of points in result */
{
    return QueryResponse_int("PointCount?\n");
}

int BranchTub::getProgress100Pcnt() /* Progress 0 to 100 */
{
    return QueryResponse_int("Progress100?\n");
}

double BranchTub::getResolutionPS() /* Resolution of time increments */
{
    return QueryResponse_double("Resolution?\n");
}

void BranchTub::setResolutionPS(double newValue) /* Resolution of time increments */
{
    SendCommand("Resolution %lf\n",newValue);
}

const char *BranchTub::Running_Strings[] =
{
    "Stop",
    "Run",
    "RunOnce",
    0
};

BranchTub::Running BranchTub::getRunning()
{
    return (Running)QueryResponse_enum(Running_Strings,"Running?\n");
}

int BranchTub::getSequence() /* Run Sequence */
{
    return QueryResponse_int("Sequence?\n");
}

bool BranchTub::getShowResults() /* Show gui results panel */
{
    return QueryResponse_bool("ShowResults?\n");
}

void BranchTub::setShowResults(bool newValue) /* Show gui results panel */
{
    SendCommand("ShowResults %c\n",newValue?'T':'F');
}

bool BranchTub::getShowSettings() /* Show gui settings panel */
{
    return QueryResponse_bool("ShowSettings?\n");
}

void BranchTub::setShowSettings(bool newValue) /* Show gui settings panel */
{
    SendCommand("ShowSettings %c\n",newValue?'T':'F');
}

char* BranchTub::getStatusMsg(char *buffer,int buflen) /* Tub status message */
{
    return QueryResponse(buffer,buflen,"StatusMsg?\n");
}

double BranchTub::getSuffBits() /* Confidence Bits based on confidence settings */
{
    return QueryResponse_double("SuffBits?\n");
}

const char *BranchTub::TubType_Strings[] =
{
    "Tub",
    "Peak",
    0
};

BranchTub::TubType BranchTub::getTubType()
{
    return (TubType)QueryResponse_enum(TubType_Strings,"TubType?\n");
}

void BranchTub::setTubType(TubType newValue )
{
    SendCommand("TubType \"%s\"\n",TubType_Strings[(int)newValue]);
}

int BranchTub::getWkgSEQ() /* Working Serial number */
{
    return QueryResponse_int("WkgSEQ?\n");
}

char* BranchTub::Csv(char *buffer,int buflen) /* PegaTub Csv, Todo:add arguments */
{
    fprintf(stderr,"BranchTub::Csv(), Todo: add arguments if needed\n");
    return QueryResponse(buffer,buflen,"Csv?\n");
}

char *BranchTub::FetchPoints() /* Fetch points - Must free() return value, Todo:add arguments */
{
    fprintf(stderr,"BranchTub::FetchPoints(), Todo: add arguments if needed\n");
    return QueryBinaryResponse(0,"FetchPoints\n");
}

char *BranchTub::FetchResults() /* Fetch results - Must free() return value */
{
    return QueryBinaryResponse(0,"FetchResults\n");
}

char *BranchTub::FetchWkg() /* Fetch working values - Must free() return value, Todo:add arguments */
{
    fprintf(stderr,"BranchTub::FetchWkg(), Todo: add arguments if needed\n");
    return QueryBinaryResponse(0,"FetchWkg\n");
}

void BranchTub::Fit() /* PegaTub Chart Fit */
{
    SendCommand("Fit\n");
}

void BranchTub::Reset() /* Reset position, Todo:add arguments */
{
    SendCommand("Reset\n");
}

/* ================================================================ */

const char *BranchTubChart::AxisY_Strings[] =
{
    "BER",
    "Q",
    0
};

BranchTubChart::AxisY BranchTubChart::getAxisY()
{
    return (AxisY)QueryResponse_enum(AxisY_Strings,"AxisY?\n");
}

void BranchTubChart::setAxisY(AxisY newValue )
{
    SendCommand("AxisY \"%s\"\n",AxisY_Strings[(int)newValue]);
}

double BranchTubChart::getBottom() /* Chart Bottom */
{
    return QueryResponse_double("Bottom?\n");
}

void BranchTubChart::setBottom(double newValue) /* Chart Bottom */
{
    SendCommand("Bottom %lf\n",newValue);
}

bool BranchTubChart::getCursAvail(int index) /* Chart Cursor Available */
{
    if(index<0||index>=11) throw "[Index_Out_Of_Range]";
    return QueryResponse_bool("CursAvail[%d]?\n",index);
}

bool BranchTubChart::getCursEnabled(int index) /* Chart Cursor Enabled */
{
    if(index<0||index>=11) throw "[Index_Out_Of_Range]";
    return QueryResponse_bool("CursEnabled[%d]?\n",index);
}

void BranchTubChart::setCursEnabled(int index,bool newValue) /* Chart Cursor Enabled */
{
    if(index<0||index>=11) throw "[Index_Out_Of_Range]";
    SendCommand("CursEnabled[%d] %c\n",index,newValue?'T':'F');
}

char* BranchTubChart::getCursLabel(int index,char *buffer,int buflen) /* Chart Cursor Label */
{
    if(index<0||index>=11) throw "[Index_Out_Of_Range]";
    return QueryResponse(buffer,buflen,"CursLabel[%d]?\n",index);
}

double BranchTubChart::getCursValue(int index) /* Chart Cursor Value */
{
    if(index<0||index>=11) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("CursValue[%d]?\n",index);
}

void BranchTubChart::setCursValue(int index,double newValue) /* Chart Cursor Value */
{
    if(index<0||index>=11) throw "[Index_Out_Of_Range]";
    SendCommand("CursValue[%d] %lf\n",index,newValue);
}

double BranchTubChart::getHeight() /* Chart Height */
{
    return QueryResponse_double("Height?\n");
}

void BranchTubChart::setHeight(double newValue) /* Chart Height */
{
    SendCommand("Height %lf\n",newValue);
}

double BranchTubChart::getLeftPS() /* Chart Left */
{
    return QueryResponse_double("Left?\n");
}

void BranchTubChart::setLeftPS(double newValue) /* Chart Left */
{
    SendCommand("Left %lf\n",newValue);
}

double BranchTubChart::getLimits(int index) /* Chart Limits (LRBT) */
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return QueryResponse_double("Limits[%d]?\n",index);
}

bool BranchTubChart::getLocked() /* Chart Locked */
{
    return QueryResponse_bool("Locked?\n");
}

void BranchTubChart::setLocked(bool newValue) /* Chart Locked */
{
    SendCommand("Locked %c\n",newValue?'T':'F');
}

bool BranchTubChart::getLogscale() /* Chart LogScale */
{
    return QueryResponse_bool("Logscale?\n");
}

void BranchTubChart::setLogscale(bool newValue) /* Chart LogScale */
{
    SendCommand("Logscale %c\n",newValue?'T':'F');
}

const char *BranchTubChart::Scroll_Strings[] =
{
    "None",
    "X1",
    "X2",
    "X3",
    "X4",
    "DX12",
    "DX34",
    "XPan",
    "XScale",
    "Y1",
    "Y2",
    "Y3",
    "Y4",
    "DY12",
    "DY34",
    "YPan",
    "YScale",
    "P1",
    "P2",
    "P3",
    0
};

BranchTubChart::Scroll BranchTubChart::getScroll()
{
    return (Scroll)QueryResponse_enum(Scroll_Strings,"Scroll?\n");
}

void BranchTubChart::setScroll(Scroll newValue )
{
    SendCommand("Scroll \"%s\"\n",Scroll_Strings[(int)newValue]);
}

bool BranchTubChart::getShowMemory() /* Show memories */
{
    return QueryResponse_bool("ShowMemory?\n");
}

void BranchTubChart::setShowMemory(bool newValue) /* Show memories */
{
    SendCommand("ShowMemory %c\n",newValue?'T':'F');
}

bool BranchTubChart::getShowOverlays() /* Show overlays */
{
    return QueryResponse_bool("ShowOverlays?\n");
}

void BranchTubChart::setShowOverlays(bool newValue) /* Show overlays */
{
    SendCommand("ShowOverlays %c\n",newValue?'T':'F');
}

char* BranchTubChart::getTitle(char *buffer,int buflen) /* Chart Title */
{
    return QueryResponse(buffer,buflen,"Title?\n");
}

double BranchTubChart::getWidthPS() /* Chart Width */
{
    return QueryResponse_double("Width?\n");
}

void BranchTubChart::setWidthPS(double newValue) /* Chart Width */
{
    SendCommand("Width %lf\n",newValue);
}

/* ================================================================ */


