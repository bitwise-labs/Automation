/* autogenCommon.h */
//================================================================================
// BOOST SOFTWARE LICENSE
//
// Copyright 2020 BitWise Laboratories Inc.
// Author.......Jim Waschura
// Contact......info@bitwiselabs.com
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.
//================================================================================

#ifndef AUTOGEN_COMMON_H
#define AUTOGEN_COMMON_H

#include "AutomationExtender.h"
#include "AutomationInterface.h"

/* ================================ */

class BranchConst: /* Constants */
	public AutomationExtender
{
	public:
	BranchConst(AutomationInterface *baseDevice,const char *prefix) :
		AutomationExtender(baseDevice,prefix) {}
	virtual ~BranchConst() {}

	char* getOptions(char *buffer,int buflen); /* Option Code */
	char* getSN(char *buffer,int buflen); /* Serial Number */
};


/* ================================ */

class BranchApp: /* Applications */
    public AutomationExtender
{
    public:
    BranchApp(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchApp() {}

    char* getList(char *buffer,int buflen); /* List of all applications */
    char* getRunActive(char *buffer,int buflen); /* List of active run objects */
    char* getRunDurLimit(char *buffer,int buflen); /* Run Duration Limit */
    void setRunDurLimit( const char* newValue);
    char* getRunList(char *buffer,int buflen); /* List of all run objects */
    char* getRunState(char *buffer,int buflen); /* List of all run object states */
    int getSequence(); /* Gui Sequence */
    bool getShowNav(); /* Show Navigation Toolbar */
    void setShowNav( bool newValue);
    bool getShowText(); /* Show Text on GUI */
    void setShowText( bool newValue);
    char* getTab(char *buffer,int buflen); /* Application Tab */
    void setTab( const char* newValue);
    void Clear(); /* Clear [<active-appname-list-no-commas>], Todo:add arguments */
    void GuiReset(); /* Gui Reset Tabs, Todo:add arguments */
    void Refresh(); /* Gui Refresh, Todo:add arguments */
    void Run(bool runOnceFlag=false); /* Run [Once] [<active-runobj-list-no-commas>] */
    void Stop(); /* Stop [<running-runobj-list-no-commas>], Todo:add arguments */
};

/* ================================ */

class BranchFile: /* File System Access */
    public AutomationExtender
{
    public:
    BranchFile(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchFile() {}

    char* getDir(char *buffer,int buflen); /* Current Directory */
    void setDir( const char* newValue);
    char* Checksum(char *buffer,int buflen,char *filepath); /* Checksum File, Todo:add arguments */
    void Copy(char *frompath, char *topath); /* Copy File, Todo:add arguments */
    void Del(char *filepath); /* Delete File, Todo:add arguments */
    char* Exists(char *buffer,int buflen,char *filepath); /* File Exists, Todo:add arguments */
    char *Fetch(char *filepath,int *pcount=0); /* Fetch File - Must free() return value, Todo:add arguments */
    void Length(char *filepath); /* File Length, Todo:add arguments */
    char *List(char *dirpath); /* List Directory - Must free() return value, Todo:add arguments */
    void Rename(char *frompath, char *topath); /* Rename File, Todo:add arguments */
    void XferBuffer(); /* Transmit next buffer to device-requires count, optional checksum, Todo:add arguments */
    void XferDoneGet(); /* Indicates completion of get operation, Todo:add arguments */
    void XferDonePut(); /* Indicates completion of send operation, Todo:add arguments */
    void XferGet(); /* Get file for transfer-respond filename, length, date, time, Todo:add arguments */
    void XferNext(); /* Retrieve next buffer-respond three u32 values, Todo:add arguments */
    void XferPut(); /* Put file-requires filepath and optional modification date and time, Todo:add arguments */
    void XferResend(); /* Retrieve last buffer--respond three u32 values, Todo:add arguments */
    void XferSameBuffer(); /* Re-transmit same buffer to device-requires count, optional checksum, Todo:add arguments */
};


/* ================================ */

class BranchPatt: /* User Patterns */
    public AutomationExtender
{
    public:
    BranchPatt(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchPatt() {}

    char* getFile(int index,char *buffer,int buflen); /* User pattern filename */
    char* getFolder(char *buffer,int buflen); /* Current folder */
    void setFolder( const char* newValue);

    enum class GuiCh
    {
        Ch0,
        Ch1,
        Dual
    };
    static const char *GuiCh_Strings[];

    GuiCh getGuiCh();
    void setGuiCh( GuiCh newValue);

    enum class GuiFormat
    {
        Hex,
        Decimal,
        Octal,
        Binary
    };
    static const char *GuiFormat_Strings[];

    GuiFormat getGuiFormat();
    void setGuiFormat( GuiFormat newValue);
    int getGuiSymbols(); /* Gui number of symbols */
    void setGuiSymbols( int newValue);
    int getGuiSymbolSize(); /* Gui bits per symbol */
    void setGuiSymbolSize( int newValue);

    enum class GuiType
    {
        All,
        Pattern,
        Playlist
    };
    static const char *GuiType_Strings[];

    GuiType getGuiType();
    void setGuiType( GuiType newValue);
    int getRestoreBitShift(int index); /* Restore bit shift */
    void setRestoreBitShift(int index, int newValue);
    char* getRestoreFile(int index,char *buffer,int buflen); /* Restore user pattern files */
    void setRestoreFile(int index, const char* newValue);
    char* getRootFolder(char *buffer,int buflen); /* User Patterns root folder */
    char* getStatusMsg(char *buffer,int buflen); /* Status message */
    char* getVerifyMsg(char *buffer,int buflen); /* Verify message */
    void ClearStatusMsg(); /* Clear status message, Todo:add arguments */
    void ClearVerifyMsg(); /* Clear verify message, Todo:add arguments */
    void Copy(); /* File copy, Todo:add arguments */
    void Delete(); /* File delete, Todo:add arguments */

    enum class PatternChannel
	{
    	Ch0,
		Ch1,
		Dual
	};
    static const char *PatternChannel_Strings[];

    void Deploy( PatternChannel ch, const char *filename, int bitShift=0 ); /* Deploy pattern */
    char *Fetch(int *pcount=0); /* Fetch file - Must free() return value, Todo:add arguments */
    char *FetchDir(); /* Fetch directory - Must free() return value, Todo:add arguments */
    void Grab(); /* Grab pattern, Todo:add arguments */
    void NewFolder(); /* New folder, Todo:add arguments */
    void Rename(); /* File rename, Todo:add arguments */
    void Save(); /* File save, Todo:add arguments */
    void Verify(); /* Verify file, Todo:add arguments */
};

/* ================================ */

class BranchSys: /* System */
    public AutomationExtender
{
    public:
    BranchSys(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchSys() {}

    char* getBuild(char *buffer,int buflen); /* Software Build */
    char* getCheckDNS(char *buffer,int buflen); /* DNS Check of bitwiselaboratories.com */
    char* getCompile(char *buffer,int buflen); /* Compile type */
    char* getGateway(char *buffer,int buflen); /* Gateway */
    char* getHostname(char *buffer,int buflen); /* Hostname */
    char* getIP(char *buffer,int buflen); /* IP Address */
    char* getNickname(char *buffer,int buflen); /* System nickname */
    void setNickname( const char* newValue);
    double getPmuTempC(); /* PMU Temperature */
    char* getProtoVer(char *buffer,int buflen); /* Protocol Version */
    bool getShowSettings(); /* Show Settings */
    void setShowSettings( bool newValue);
    int getUsers(); /* Number of users */
};


/* ================================ */

class BranchSyn: /* Clock source control */
    public AutomationExtender
{
    public:
    BranchSyn(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchSyn() {}

    double getClockRateGHz(); /* Internal clock rate */
    void setClockRateGHz( double newValue);
    double getDataRateGbps(); /* Doubled clock rate */
    void setDataRateGbps( double newValue);

    enum class Dest
    {
        Ch0,
        Ch1,
        Calib,
        Output
    };
    static const char *Dest_Strings[];

    Dest getDest(int index);
    void setDest(int index, Dest newValue);

    enum class DivCalib
    {
        Div2,
        Div4,
        Div8,
        Div16
    };
    static const char *DivCalib_Strings[];

    DivCalib getDivCalib();
    void setDivCalib( DivCalib newValue);

    enum class DivOutput
    {
        Div2,
        Div4,
        Div8,
        Div16
    };
    static const char *DivOutput_Strings[];

    DivOutput getDivOutput();
    void setDivOutput( DivOutput newValue);
    int getHwVersion(); /* Hardware version */

    enum class Led
    {
        Auto,
        Green,
        Red,
        Off
    };
    static const char *Led_Strings[];

    Led getLed(int index);
    void setLed(int index, Led newValue);
    bool getLockDetect(); /* Synthesizer Lock detected */
    double getOpRateGHz(); /* Operating clock rate, -1 means not set */
    void setOpRateGHz( double newValue);

    enum class RefSource
    {
        IntRef,
        ExtRef
    };
    static const char *RefSource_Strings[];

    RefSource getRefSource();
    void setRefSource( RefSource newValue);

    enum class Source
    {
        Internal,
        ExtA,
        ExtB
    };
    static const char *Source_Strings[];

    Source getSource(int index);
    void setSource(int index, Source newValue);
    void Map(); /* Map clock source to destination(s), Todo:add arguments */
};



#endif // AUTOGEN_COMMON_H


