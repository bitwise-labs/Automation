/* autogenAccessory.h */
//================================================================================
// BOOST SOFTWARE LICENSE
//
// Copyright 2020 BitWise Laboratories Inc.
// Author.......Jim Waschura
// Contact......info@bitwiselabs.com
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.
//================================================================================

#ifndef AUTOGEN_ACCESSORY_H
#define AUTOGEN_ACCESSORY_H

#include "autogenCommon.h"


/* ================================ */

class BranchAccDDRCTC: /* CTC2 Board category */
	public AutomationExtender
{
	public:
	BranchAccDDRCTC(AutomationInterface *baseDevice,const char *prefix) :
		AutomationExtender(baseDevice,prefix) {}
	virtual ~BranchAccDDRCTC() {}

	void DramMPC(); /* DramMPC devaddr devchan rank addr data, Todo:add arguments */
	void DramMRR(); /* DramMRR devaddr devchan rank addr, Todo:add arguments */
	void DramMRW(); /* DramMRW devaddr devchan rank addr data, Todo:add arguments */
	void DramNOP(); /* DramNOP devaddr devchan rank, Todo:add arguments */
	void I2cWriteByte(); /* I2cWriteByte devaddr addr byte, Todo:add arguments */
	void ReadByte(); /* ReadByte devaddr devchan addr, Todo:add arguments */
	void ReadDword(); /* ReadDword devaddr devchan addr, Todo:add arguments */
	void SetGpio(); /* SetGpio [#] ... <on|off>  (pins 0-16, only 5 supported), Todo:add arguments */
	void WriteByte(); /* WriteByte devaddr devchan addr byte, Todo:add arguments */
	void WriteDword(); /* WriteDword devaddr devchan addr byte1 byte2 byte3 byte4 (msb first), Todo:add arguments */
	void WriteWord(); /* WriteWord devaddr devchan addr byte1 byte2 (msb first), Todo:add arguments */
};

/* ================================ */

class BranchAccDDRDFE: /* DFE category */
    public AutomationExtender
{
    public:
    BranchAccDDRDFE(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchAccDDRDFE() {}

    bool getEnables(int index); /* DFE Tap enable values */
    void setEnables(int index, bool newValue);

    enum class Gain
    {
        _m6dB,
        _m4dB,
        _m2dB,
        _0dB,
        _2dB,
        _4dB,
        _6dB
    };
    static const char *Gain_Strings[];

    Gain getGain();
    void setGain( Gain newValue);
    double getTapsMV(int index); /* DFE Tap values */
    void setTapsMV(int index, double newValue);
    void Program(); /* Program DFE with current settings, Todo:add arguments */
};

/* ================================ */

class BranchAccDDRI2C: /* I2C Access */
    public AutomationExtender
{
    public:
    BranchAccDDRI2C(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchAccDDRI2C() {}

    int getAux(); /* High 6 bits of control register */
    void setAux( int newValue);
    void Read(); /* Read bytes, Todo:add arguments */
    void ReadBYTE(); /* Read byte using special format, Todo:add arguments */
    void ReadDWORD(); /* Read DWORD using special format, Todo:add arguments */
    void ReadHost(); /* Read Host bytes, Todo:add arguments */
    void ReadWORD(); /* Read WORD using special format, Todo:add arguments */
    void Write(); /* Write bytes, Todo:add arguments */
    void WriteBYTE(); /* Write byte using special format, Todo:add arguments */
    void WriteDWORD(); /* Write DWORD using special format (DWORD must be hex), Todo:add arguments */
    void WriteWORD(); /* Write WORD using special format (WORD must be hex), Todo:add arguments */
};

/* ================================ */

class BranchAccDDRRef: /* Reference clock category */
    public AutomationExtender
{
    public:
    BranchAccDDRRef(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchAccDDRRef() {}

    double getAmplMV(); /* Reference clock amplitude */
    void setAmplMV( double newValue);

    enum class Coupling
    {
        DC,
        AC
    };
    static const char *Coupling_Strings[];

    Coupling getCoupling();
    void setCoupling( Coupling newValue);
    double getDCLevelMV(); /* Reference Termination DC Level */
    void setDCLevelMV( double newValue);
    double getDelayPS(); /* Ref clock delay */
    void setDelayPS( double newValue);
    double getImpedanceOhms(); /* Reference Termination Impedance */
    void setImpedanceOhms( double newValue);
    bool getInvert(); /* Reference clock invert */
    void setInvert( bool newValue);
    bool getLink(); /* Reference DC offsets linked */
    void setLink( bool newValue);
    double getOffsetNegMV(); /* Reference clock offset negative */
    void setOffsetNegMV( double newValue);
    double getOffsetPosMV(); /* Reference clock offset */
    void setOffsetPosMV( double newValue);

    enum class TermType
    {
        DC,
        AC
    };
    static const char *TermType_Strings[];

    TermType getTermType();
    void setTermType( TermType newValue);
};

/* ================================ */

class BranchAccDDRStress: /* Stress category */
    public AutomationExtender
{
    public:
    BranchAccDDRStress(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchAccDDRStress() {}

    double getOpRateGbps(); /* Operating rate */
    void setOpRateGbps( double newValue);
    bool getRJEnabled(); /* RJ Enabled */
    void setRJEnabled( bool newValue);
    double getRJLevelPSrms(); /* RJ Level RMS */
    void setRJLevelPSrms( double newValue);
    double getSIAmplMV(); /* SI Amplitude */
    void setSIAmplMV( double newValue);
    bool getSIEnabled(); /* SI Enabled */
    void setSIEnabled( bool newValue);
    double getSIFreqMHz(); /* SI Frequency */
    void setSIFreqMHz( double newValue);
    bool getSJEnabled(); /* SJ Enabled */
    void setSJEnabled( bool newValue);
    double getSJFreqMHz(); /* SJ Frequency */
    void setSJFreqMHz( double newValue);
    double getSJLevelPSpp(); /* SJ Level */
    void setSJLevelPSpp( double newValue);
};

/* ================================ */

class BranchAccDDR: /* DDR5 accessory */
    public AutomationExtender
{
    public:

    BranchConst Const;
    BranchAccDDRCTC CTC;
    BranchAccDDRDFE DFE;
    BranchAccDDRI2C I2C;
    BranchAccDDRRef  Ref;
    BranchAccDDRStress Stress;

    BranchAccDDR(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix),
	    Const(this,"Const:"),
	    CTC(this,"CTC:"),
	    DFE(this,"DFE:"),
	    I2C(this,"I2C:"),
	    Ref(this,"Ref:"),
	    Stress(this,"Stress:")  {}
    virtual ~BranchAccDDR() {}


    enum class CardType
    {
        RDIMM,
        LRDIMM,
        COMBO
    };
    static const char *CardType_Strings[];

    CardType getCardType();
    void setCardType( CardType newValue);

    enum class Channel
    {
        ChA,
        ChB
    };
    static const char *Channel_Strings[];

    Channel getChannel();
    void setChannel( Channel newValue);

    enum class ConnectClock
    {
        ClockSignals,
        DataSignals,
        CommandSignals,
        CK,
        DQS0_A,
        DQS1_A,
        DQS2_A,
        DQS3_A,
        DQS4_A,
        DQS5_A,
        DQS6_A,
        DQS7_A,
        DQS8_A,
        DQS9_A,
        DQS0_B,
        DQS1_B,
        DQS2_B,
        DQS3_B,
        DQS4_B,
        DQS5_B,
        DQS6_B,
        DQS7_B,
        DQS8_B,
        DQS9_B,
        DQ0_A,
        DQ1_A,
        DQ2_A,
        DQ3_A,
        DQ4_A,
        DQ5_A,
        DQ6_A,
        DQ7_A,
        DQ8_A,
        DQ9_A,
        DQ10_A,
        DQ11_A,
        DQ12_A,
        DQ13_A,
        DQ14_A,
        DQ15_A,
        DQ16_A,
        DQ17_A,
        DQ18_A,
        DQ19_A,
        DQ20_A,
        DQ21_A,
        DQ22_A,
        DQ23_A,
        DQ24_A,
        DQ25_A,
        DQ26_A,
        DQ27_A,
        DQ28_A,
        DQ29_A,
        DQ30_A,
        DQ31_A,
        DQ0_B,
        DQ1_B,
        DQ2_B,
        DQ3_B,
        DQ4_B,
        DQ5_B,
        DQ6_B,
        DQ7_B,
        DQ8_B,
        DQ9_B,
        DQ10_B,
        DQ11_B,
        DQ12_B,
        DQ13_B,
        DQ14_B,
        DQ15_B,
        DQ16_B,
        DQ17_B,
        DQ18_B,
        DQ19_B,
        DQ20_B,
        DQ21_B,
        DQ22_B,
        DQ23_B,
        DQ24_B,
        DQ25_B,
        DQ26_B,
        DQ27_B,
        DQ28_B,
        DQ29_B,
        DQ30_B,
        DQ31_B,
        CA0_A,
        CA1_A,
        CA2_A,
        CA3_A,
        CA4_A,
        CA5_A,
        CA6_A,
        CA0_B,
        CA1_B,
        CA2_B,
        CA3_B,
        CA4_B,
        CA5_B,
        CA6_B
    };
    static const char *ConnectClock_Strings[];

    ConnectClock getConnectClock();

    enum class ConnectData
    {
        ClockSignals,
        DataSignals,
        CommandSignals,
        CK,
        DQS0_A,
        DQS1_A,
        DQS2_A,
        DQS3_A,
        DQS4_A,
        DQS5_A,
        DQS6_A,
        DQS7_A,
        DQS8_A,
        DQS9_A,
        DQS0_B,
        DQS1_B,
        DQS2_B,
        DQS3_B,
        DQS4_B,
        DQS5_B,
        DQS6_B,
        DQS7_B,
        DQS8_B,
        DQS9_B,
        DQ0_A,
        DQ1_A,
        DQ2_A,
        DQ3_A,
        DQ4_A,
        DQ5_A,
        DQ6_A,
        DQ7_A,
        DQ8_A,
        DQ9_A,
        DQ10_A,
        DQ11_A,
        DQ12_A,
        DQ13_A,
        DQ14_A,
        DQ15_A,
        DQ16_A,
        DQ17_A,
        DQ18_A,
        DQ19_A,
        DQ20_A,
        DQ21_A,
        DQ22_A,
        DQ23_A,
        DQ24_A,
        DQ25_A,
        DQ26_A,
        DQ27_A,
        DQ28_A,
        DQ29_A,
        DQ30_A,
        DQ31_A,
        DQ0_B,
        DQ1_B,
        DQ2_B,
        DQ3_B,
        DQ4_B,
        DQ5_B,
        DQ6_B,
        DQ7_B,
        DQ8_B,
        DQ9_B,
        DQ10_B,
        DQ11_B,
        DQ12_B,
        DQ13_B,
        DQ14_B,
        DQ15_B,
        DQ16_B,
        DQ17_B,
        DQ18_B,
        DQ19_B,
        DQ20_B,
        DQ21_B,
        DQ22_B,
        DQ23_B,
        DQ24_B,
        DQ25_B,
        DQ26_B,
        DQ27_B,
        DQ28_B,
        DQ29_B,
        DQ30_B,
        DQ31_B,
        CA0_A,
        CA1_A,
        CA2_A,
        CA3_A,
        CA4_A,
        CA5_A,
        CA6_A,
        CA0_B,
        CA1_B,
        CA2_B,
        CA3_B,
        CA4_B,
        CA5_B,
        CA6_B
    };
    static const char *ConnectData_Strings[];

    ConnectData getConnectData();

    enum class Device
    {
        DRAM,
        RCD,
        DB
    };
    static const char *Device_Strings[];

    Device getDevice();
    void setDevice( Device newValue);

    enum class DramType
    {
        _1RX4,
        _1RX8,
        _2RX4,
        _2RX8
    };
    static const char *DramType_Strings[];

    DramType getDramType();
    void setDramType( DramType newValue);

    enum class Host
    {
        Host0,
        Host1,
        Host2,
        Host3,
        Host4,
        Host5,
        Host6,
        Host7
    };
    static const char *Host_Strings[];

    Host getHost();
    void setHost( Host newValue);
    bool getInProgress(); /* Loopback in progress */

    enum class Lane
    {
        DQ0_A,
        DQ1_A,
        DQ2_A,
        DQ3_A,
        DQ4_A,
        DQ5_A,
        DQ6_A,
        DQ7_A,
        DQ8_A,
        DQ9_A,
        DQ10_A,
        DQ11_A,
        DQ12_A,
        DQ13_A,
        DQ14_A,
        DQ15_A,
        DQ16_A,
        DQ17_A,
        DQ18_A,
        DQ19_A,
        DQ20_A,
        DQ21_A,
        DQ22_A,
        DQ23_A,
        DQ24_A,
        DQ25_A,
        DQ26_A,
        DQ27_A,
        DQ28_A,
        DQ29_A,
        DQ30_A,
        DQ31_A,
        DQ0_B,
        DQ1_B,
        DQ2_B,
        DQ3_B,
        DQ4_B,
        DQ5_B,
        DQ6_B,
        DQ7_B,
        DQ8_B,
        DQ9_B,
        DQ10_B,
        DQ11_B,
        DQ12_B,
        DQ13_B,
        DQ14_B,
        DQ15_B,
        DQ16_B,
        DQ17_B,
        DQ18_B,
        DQ19_B,
        DQ20_B,
        DQ21_B,
        DQ22_B,
        DQ23_B,
        DQ24_B,
        DQ25_B,
        DQ26_B,
        DQ27_B,
        DQ28_B,
        DQ29_B,
        DQ30_B,
        DQ31_B,
        CA0_A,
        CA1_A,
        CA2_A,
        CA3_A,
        CA4_A,
        CA5_A,
        CA6_A,
        CA0_B,
        CA1_B,
        CA2_B,
        CA3_B,
        CA4_B,
        CA5_B,
        CA6_B
    };
    static const char *Lane_Strings[];

    Lane getLane();
    void setLane( Lane newValue);
    char* getLoopbackStatus(char *buffer,int buflen); /* Loopback status */
    bool getPdaEarlyClocking(); /* PDA Enumerate before clocking (reqd for Micron loopback) */
    void setPdaEarlyClocking( bool newValue);

    enum class Phase
    {
        PhaseA,
        PhaseB,
        PhaseC,
        PhaseD
    };
    static const char *Phase_Strings[];

    Phase getPhase();
    void setPhase( Phase newValue);

    enum class Rank
    {
        R0,
        R1
    };
    static const char *Rank_Strings[];

    Rank getRank();
    void setRank( Rank newValue);

    enum class Speed
    {
        DDR5m3200,
        DDR5m3600,
        DDR5m4000,
        DDR5m4400,
        DDR5m4800,
        DDR5m5200,
        DDR5m5600,
        DDR5m6000,
        DDR5m6400
    };
    static const char *Speed_Strings[];

    Speed getSpeed();
    void setSpeed( Speed newValue);
    void FetchDevices(); /* Fetch list of devices currently available, Todo:add arguments */
    void FetchLanes(); /* Fetch list of lanes currently available, Todo:add arguments */
    void FetchPhases(); /* Fetch list of phases currently available, Todo:add arguments */
    void Loopback(); /* Start loopback (asynchronous), Todo:add arguments */
    void LoopbackCancel(); /* Loopback cancel, Todo:add arguments */
    void PowerOn(); /* Power-on MIC, Todo:add arguments */
    void ProgramPhase(); /* Program Phase DRAM+RCD, Todo:add arguments */
};

/* ================================ */

 class BranchAccPUL: /* Pulser accessory */
     public AutomationExtender
 {
     public:
	 BranchConst Const;
     BranchAccPUL(AutomationInterface *baseDevice,const char *prefix) :
         AutomationExtender(baseDevice,prefix),
		 Const(this,"Const:") {}
     virtual ~BranchAccPUL() {}

     double getAmplMV(); /* Pulse amplitude */
     void setAmplMV( double newValue);
     double getDiffSkewPS(); /* Differential Skew */
     void setDiffSkewPS( double newValue);
     bool getNegEnabled(); /* Negative leg enabled */
     void setNegEnabled( bool newValue);
     bool getPosEnabled(); /* Positive leg enabled */
     void setPosEnabled( bool newValue);
     double getTrigRateGHz(); /* Trigger rate */
     void setTrigRateGHz( double newValue);

     enum class Width
     {
         _1,
         _2,
         _4,
         _8,
         _16
     };
     static const char *Width_Strings[];

     Width getWidth();
     void setWidth( Width newValue);
 };

 /* ================================ */

 class BranchAcc: /* Accessory connector */
     public AutomationExtender
 {
     public:
 	BranchAccDDR DDR;
 	BranchAccPUL PUL;

     BranchAcc(AutomationInterface *baseDevice,const char *prefix) :
         AutomationExtender(baseDevice,prefix),
			DDR(this,"DDR:"),
			PUL(this,"PUL:") {}
     virtual ~BranchAcc() {}

     bool getIsAttached(); /* Probe is attached */

     enum class Type
     {
         None,
         DDR5,
         Pulser
     };
     static const char *Type_Strings[];

     Type getType();
     void setType( Type newValue);
 };


#endif // AUTOGEN_ACCESSORY_H


