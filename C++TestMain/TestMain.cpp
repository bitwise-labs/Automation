//================================================================================
// BOOST SOFTWARE LICENSE
//
// Copyright 2020 BitWise Laboratories Inc.
// Author.......Jim Waschura
// Contact......info@bitwiselabs.com
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.
//================================================================================

#include <stdio.h>
#include <unistd.h> /* usleep */
#include <stdlib.h> /* free */
#include <math.h> /* log10 */

#include "PegaDevice.h"

char *IPAddress = (char*) "192.168.1.176:923";
void test_001(char *ip_address );
void test_002(char *ip_address, bool stopOnError );
void test_003(char *ip_address, bool stopOnError, double stepGHz );

int main( int argc, char *argv[] )
{
	setbuf(stdout, NULL); /* disable stdout buffering */
	printf("Test Main, Version 1.0\n");

	bool stopOnError=false;
	double stepGHz=0.5;
	char *ip[32];
	int ipCount=0;

	while( *(++argv) )
		if( !strcmp( *argv, "-stop") )
			stopOnError=true;
		else if( !strcmp( *argv, "-step") )
			stepGHz=atof(*(++argv));
		else if( ipCount<32 )
			ip[ipCount++] = *argv;
		else
		{
			printf("Too many IP addresses, maximum is 32\n");
			exit(0);
		}

	if( ipCount==0 || stepGHz<=0.0 )
	{
		printf("Usage:  TestMain [options] IP0 IP1 ... IPn\n");
		printf("Options:  -stop ..... stop on first error\n");
		printf("          -step X ... set step-size (dflt 0.5)\n" );
	}

	try
	{
		for( int n=0; n<ipCount; n++ )
		{
			//test_001(ip[n]);
			//test_002(ip[n],stopOnError);
			test_003(ip[n],stopOnError,stepGHz);
		}
	}
	catch(const char*msg)
	{
		printf("\nError: %s\n", msg );
	}

	return 0;
}

void test_001(char *ip_address )
{
	printf("Test Main\n");

	PegaDevice Pega;

	Pega.Connect( ip_address );
	Pega.ED.setDebugging(true);

	char buffer[4096];
	printf("Serial number.....%s\n", Pega.Const.getSN( buffer, 4096 )) ;
	printf("Build.............%s\n", Pega.Sys.getBuild( buffer, 4096 )) ;
	printf("Nickname..........%s\n", Pega.Sys.getNickname( buffer, 4096 )) ;

	//================================================================================
	//================================================================================

	Pega.PG.Amp.setAmplMV(0,500.0);
	Pega.PG.Amp.setAmplMV(1,500.0);

	Pega.Patt.Deploy(BranchPatt::PatternChannel::Ch0, "10.patt");
	Pega.Patt.Deploy(BranchPatt::PatternChannel::Ch1, "11110000.patt");
	Pega.PG.setPattern(0,BranchPG::Pattern::Prbs7);
	Pega.PG.setPattern(1,BranchPG::Pattern::Prbs15);
	Pega.PG.setAllOn(true);
	Pega.App.setTab("TUB");
	Pega.Stop();

	Pega.ED.AlignData(BranchED::AlignBy::All);

	Pega.RunSingle();

	static const double TIMEOUT_SEC=300.0;
	double now = SocketDevice::timestamp();
	double timeout = now + TIMEOUT_SEC;

	while( now<timeout && Pega.getIsRunning() )
	{
		usleep( 200*1000 ); /* poll 5 times per second */
		now=SocketDevice::timestamp();

		int progress = Pega.Tub.getProgress100Pcnt();
		printf("Tub progress: %d%%   \r", progress );
	}

	printf("\n");

	Pega.Stop();

	char DirBuffer[4096];
	Pega.File.getDir(DirBuffer,4096);
	printf("DIR=\"%s\"\n", DirBuffer );

	if( now>=timeout )
		throw "[Stop_Timeout]";

	Pega.Tub.getStatusMsg( buffer, 4096 );
	printf("TUB STATUS: %s\n", buffer );

	char *results = Pega.Tub.FetchResults();
	if( results!=0 )
	{
		printf("\nRESULTS:\n%s\n",results);
		free(results);
	}

	printf("Tub RJ......%.3lf ps\n",
		BitwiseDevice::unpackDoubleByKey(results,"RJ")
	);

	printf("Accessory...%s\n", BranchAcc::Type_Strings[ (int)Pega.Acc.getType()] );

	if( Pega.Acc.getType()==BranchAcc::Type::DDR5 )
	{
		printf("DDR S/N.....%s\n", Pega.Acc.DDR.Const.getSN(buffer,4096));
		printf("SJ Level....%.3lf\n", Pega.Acc.DDR.Stress.getSJLevelPSpp() );
	}

	printf("PG Term Impedance.....Ch0=%.3lf\n", Pega.PG.Term.getImpedanceOhms(0) );
	printf("PG Term Impedance.....Ch1=%.3lf\n", Pega.PG.Term.getImpedanceOhms(1) );

	Pega.Disconnect();
}

void test_002(char *ip_address, bool stopOnError )
{
	printf("Pega Frequency Sweep\n");

	PegaDevice Pega;

	Pega.Connect( ip_address );
	Pega.ED.setDebugging(true);
	Pega.PG.setDebugging(true);

	char buffer[4096];
	printf("Serial number.....%s\n", Pega.Const.getSN( buffer, 4096 )) ;
	printf("Build.............%s\n", Pega.Sys.getBuild( buffer, 4096 )) ;
	printf("Nickname..........%s\n", Pega.Sys.getNickname( buffer, 4096 )) ;

	//================================================================================
	//================================================================================
	Pega.Stop();

	Pega.RestoreConfiguration("[factory]");
	Pega.App.setTab("BERT");
	Pega.PG.Amp.setAmplMV(0,500.0);
	Pega.PG.Amp.setAmplMV(1,500.0);

	Pega.PG.setPattern(0,BranchPG::Pattern::Prbs7);
	Pega.PG.setPattern(1,BranchPG::Pattern::Prbs31);

	Pega.Syn.setSource(0,BranchSyn::Source::Internal);
	Pega.Syn.setSource(1,BranchSyn::Source::Internal);

	Pega.PG.setAllOn(true);

	Pega.ED.setEnabled(true);
	Pega.ED.Sampler.setMode(BranchEDSampler::Mode::CalInput);
	Pega.ED.setEyeSubrate(BranchED::EyeSubrate::DivBy1) ;
	Pega.ED.setAutoResync(true);
	Pega.ED.setPatt(BranchED::Patt::Auto);

	static int CALNUM[] = {2,4,8,16,0};
	static BranchSyn::DivCalib CALDIV[] = {
		BranchSyn::DivCalib::Div2,
		BranchSyn::DivCalib::Div4,
		BranchSyn::DivCalib::Div8,
		BranchSyn::DivCalib::Div16
	};

	static const double STARTGHZ=1.0;
	static const double ENDGHZ=28.0;
	static const double STEPGHZ=0.5;
	static const double MAX_CALIB_GHZ=3.0;

	int noSync=0;
	int nonZeroBER=0;
	char SyncErrors[4096];
	char BERErrors[4096];
	SyncErrors[0]=0;
	BERErrors[0]=0;

	for( double dataRateGHz = STARTGHZ; dataRateGHz<=ENDGHZ; dataRateGHz += STEPGHZ )
	{
		printf("=============================== Test Data Rate: %.3lf GHz\n", dataRateGHz );

		int nIndex=0;
		while( CALNUM[nIndex]!=0 )
		{
			if( dataRateGHz/(double)CALNUM[nIndex] <= MAX_CALIB_GHZ )
				break;
			nIndex++;
		}

		if( CALNUM[nIndex]==0 )
			throw "[Unable_To_Find_Matching_Calib_GHz]";

		double clockRateGHz=dataRateGHz/2.0;
		printf("Set DDR Clock Rate to: %.3lf GHz\n", clockRateGHz );
		Pega.Syn.setClockRateGHz(clockRateGHz);

		printf("Set calib divider to: %s\n", BranchSyn::DivCalib_Strings[nIndex] );
		Pega.Syn.setDivCalib(CALDIV[nIndex]);

		printf("Wait for clock to settle\n");
		Pega.PG.WaitForClockToSettle(clockRateGHz);

		printf("Read calib rate: %.3lf GHz\n", Pega.ED.getCalibRateGHz() );

		printf("Align Data\n");

		Pega.ED.AlignData(BranchED::AlignBy::All);
		char buffer[1024];
		Pega.ED.getAlignDataMsg( buffer, 1024 );
		printf("Align status: %s\n", buffer );

		bool inSyncFlag = Pega.ED.getInSync();

		if( inSyncFlag )
		{
			printf("Sync....Yes\n");
			printf("Patt....%s\n", BranchED::Patt_Strings[ (int)Pega.ED.getDetPatt() ] );

			Pega.App.Clear();
			Pega.App.Run();
			usleep(5*1000*1000); // five seconds
			Pega.App.Stop();

			printf("Bits....%.0lf\n", (double)Pega.Err.getBits());
			printf("Errors..%.0lf\n", (double)Pega.Err.getErrors());

			double BER = Pega.Err.getABER();
			printf("BER.....%.3le\n", BER );
			if( BER!=0.0 )
			{
				printf("ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR\n");
				nonZeroBER++;
				snprintf(BERErrors+strlen(BERErrors),4096-strlen(BERErrors),"%.3lf ", dataRateGHz );

				if(stopOnError)
					throw "[Non_Zero_BER_Error]";
			}

		}
		else
		{
			printf("Sync....No\n");
			printf("Patt....%s\n", BranchED::Patt_Strings[ (int)Pega.ED.getDetPatt() ] );
			printf("ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR ERR\n");
			noSync++;
			snprintf(SyncErrors+strlen(SyncErrors),4096-strlen(SyncErrors),"%.3lf ", dataRateGHz );
			if(stopOnError)
				throw "[No_Syc_Error]";

		}
	}

	printf("===============================\n");
	printf("Tests complete.  NoSyncErrs=%d,  NonZeroBER=%d\n", noSync, nonZeroBER );
	if( noSync>0 )
		printf("Sync Errors: %s\n", SyncErrors );
	if( nonZeroBER>0 )
		printf("Non-zero BER Errors: %s\n", BERErrors );

	Pega.Disconnect();
}

void test_003(char *ip_address, bool stopOnError, double stepGHz )
{

	if( ip_address==0 || ip_address[0]==0 || stepGHz<=0.0 )
		throw "[Invalid_Parameter]";

	PegaDevice Pega;

	Pega.Connect( ip_address );
//	Pega.ED.setDebugging(true);
//	Pega.PG.setDebugging(true);

	char serialNumber[1024];
	Pega.Const.getSN( serialNumber, 1024 );

	char buffer[4096];
	printf("PEGA FREQUENCY SWEEP\n");
	printf("IP Address........%s\n", ip_address );
	printf("StopOnError.......%c\n", stopOnError?'T':'F');
	printf("Serial number.....%s\n", serialNumber ) ;
	printf("Step GHz..........%.3lf\n", stepGHz );
	printf("Build.............%s\n", Pega.Sys.getBuild( buffer, 4096 )) ;

	//================================================================================
	//================================================================================
	Pega.Stop();

	Pega.RestoreConfiguration("[factory]");
	Pega.PG.Amp.setAmplMV(0,500.0);
	Pega.PG.Amp.setAmplMV(1,500.0);

	Pega.PG.setPattern(0,BranchPG::Pattern::Prbs7);
	Pega.PG.setPattern(1,BranchPG::Pattern::Prbs31);

	Pega.Syn.setSource(0,BranchSyn::Source::Internal);
	Pega.Syn.setSource(1,BranchSyn::Source::Internal);
	Pega.PG.setAllOn(true);

	Pega.ED.setEnabled(true);
	Pega.ED.Sampler.setMode(BranchEDSampler::Mode::CalInput);
	Pega.ED.setEyeSubrate(BranchED::EyeSubrate::DivBy1) ;
	Pega.ED.setAutoResync(true);
	Pega.ED.setPatt(BranchED::Patt::Auto);

	Pega.Tub.setResolutionPS(0.25);

	static int CALNUM[] = {2,4,8,16,0};
	static BranchSyn::DivCalib CALDIV[] = {
		BranchSyn::DivCalib::Div2,
		BranchSyn::DivCalib::Div4,
		BranchSyn::DivCalib::Div8,
		BranchSyn::DivCalib::Div16
	};

	static const double STARTGHZ=1.0;
	static const double ENDGHZ=28.0;
	//static const double STEPGHZ=0.5;
	static const double MAX_CALIB_GHZ=3.0;

printf("=================================================================================\n");
printf("SN,Gbps,CalDiv,Align,Thresh,Delay,Sync,Errors,Resyncs,BER,LogBER,RJ,EWC,TubStatus\n");

	for( double dataRateGHz = STARTGHZ; dataRateGHz<=ENDGHZ; dataRateGHz += stepGHz )
	{

		int nIndex=0;
		while( CALNUM[nIndex]!=0 )
		{
			if( dataRateGHz/(double)CALNUM[nIndex] <= MAX_CALIB_GHZ )
				break;
			nIndex++;
		}

		if( CALNUM[nIndex]==0 )
			throw "[Unable_To_Find_Matching_Calib_GHz]";

		double clockRateGHz=dataRateGHz/2.0;
		Pega.Syn.setClockRateGHz(clockRateGHz);
		Pega.Syn.setDivCalib(CALDIV[nIndex]);


		Pega.PG.WaitForClockToSettle(clockRateGHz);

		Pega.ED.AlignData(BranchED::AlignBy::All);

		char alignStatus[1024];

		Pega.ED.getAlignDataMsg( alignStatus, 1024 );

printf("%s", serialNumber);
printf(",%.2lf", dataRateGHz );
printf(",%s", BranchSyn::DivCalib_Strings[(int)CALDIV[nIndex]]);
printf(",\"%s\"", alignStatus );
printf(",%.1lf",Pega.ED.Sampler.getVoltsMV());
printf(",%.1lf", Pega.ED.Sampler.getTimePS());

		if( stopOnError && strncasecmp(alignStatus,"Success",7) )
			throw "[Stop_On_No_Alignment]" ;

		//======================================================================
		Pega.App.Stop();
		Pega.App.setTab("BERT");
		Pega.App.Clear();

		bool inSyncFlag = Pega.ED.getInSync();

		Pega.App.Run();
		usleep(5*1000*1000); // run for five seconds
		Pega.App.Stop();

		double ERRS = (int)Pega.Err.getErrors();
		int RC = (int) Pega.Err.getResyncCount();
		double BER = Pega.Err.getABER();

printf(",%s", inSyncFlag?"Yes":"NoSync");
printf(",%.0lf", ERRS);
printf(",%d", RC );
printf(",%.2le", BER );
printf(",%.2lf", BER==0.0?0.0:log10(BER));

		if( stopOnError && !inSyncFlag )
			throw "[Stop_On_No_Sync]" ;

		if(  stopOnError && (RC>0 || ERRS>0.0)  )
			throw "[Stop_On_Errors]" ;

		//======================================================================

		Pega.App.Stop();
		Pega.App.setTab("TUB");
		Pega.App.Clear();

		Pega.RunSingle();
		Pega.WaitForRunToComplete(300.0);

		char tubStatusMessage[4096];
		Pega.Tub.getStatusMsg( tubStatusMessage, 4096 );

		char *results = Pega.Tub.FetchResults();
		double RJ=BitwiseDevice::unpackDoubleByKey(results,"RJ");
		double EWC=BitwiseDevice::unpackDoubleByKey(results,"EWC");
		free(results);

printf(",%.3lf", RJ );
printf(",%.1lf", EWC );
printf(",\"%s\"", tubStatusMessage );
printf("\n");

		if(  stopOnError && (RJ==0.0) && dataRateGHz>=4.0 )
			throw "[Stop_On_Bad_Tub]" ;
	}

	printf("\n");

	Pega.Disconnect();
}





