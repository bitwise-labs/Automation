/* autogenAccessory.h */
//================================================================================
// BOOST SOFTWARE LICENSE
//
// Copyright 2020 BitWise Laboratories Inc.
// Author.......Jim Waschura
// Contact......info@bitwiselabs.com
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.
//================================================================================

#ifndef AUTOGEN_ACCESSORY_H
#define AUTOGEN_ACCESSORY_H

#include "autogenCommon.h"


/* ================================ */

class BranchAccDDRCTC: /* CTC2 Board category */
	public AutomationExtender
{
	public:
	BranchAccDDRCTC(AutomationInterface *baseDevice,const char *prefix) :
		AutomationExtender(baseDevice,prefix) {}
	virtual ~BranchAccDDRCTC() {}

	void DramMPC( int devaddr, int channel, int rank, int data ); /* devaddr(0-3F), channel(0-1), rank(0-1), data(0-FF) */
	void DramMRR( int devaddr, int channel, int rank, int address ); /* devaddr(0-3F), channel(0-1) rank(0-1), address(0-FF) */
	void DramMRW( int devaddr, int channel, int rank, int address, int data); /* devaddr(0-3F), channel(0-1), rank(0-1), address(0-FF), data(0-FF) */
	void DramNOP( int devaddr, int channel, int rank ); /* devaddr(0-3F), channel(0-1), rank(0-1) */
	void I2cWriteByte( int devaddr, int address, int value ); /* devaddr(0-3F), address(0-FF), value(0-FF) */
	int I2cReadByte( int devaddr, int address ); /* devaddr(0-3F), address(0-FF) */
	int ReadByte(int devaddr, int channel, int address ); /* devaddr(0-3F), channel(0-1), address(0-FFFF, 256-byte pages) */
	int ReadDword(int devaddr, int channel, int address ); /* devaddr(0-3F), channel(0-1), address(0-FFFF, 256-byte pages) */
	void SetGpio(int pin, bool value); /* pin 0-15, value T/F */
	void WriteByte(int devaddr, int channel, int address, int value ); /*  devaddr(0-3F), channel(0-1), address(0-FFFF, 256-byte pages), value (0-FF) */
	void WriteDword(int devaddr, int channel, int address, int value ); /* devaddr(0-3F), channel(0-1), address(0-FFFF, 256-byte pages), value (0-FFFFFFFF) */
	void WriteWord(int devaddr, int channel, int address, int value ); /* devaddr(0-3F), channel(0-1), address(0-FFFF, 256-byte pages), value (0-FFFF) */
};

/* ================================ */

class BranchAccDDRDFE: /* DFE category */
    public AutomationExtender
{
    public:
    BranchAccDDRDFE(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchAccDDRDFE() {}

    bool getEnables(int index); /* DFE Tap enable values */
    void setEnables(int index, bool newValue);

    enum class Gain
    {
        _m6dB,
        _m4dB,
        _m2dB,
        _0dB,
        _2dB,
        _4dB,
        _6dB
    };
    static const char *Gain_Strings[];

    Gain getGain();
    void setGain( Gain newValue);
    double getTapsMV(int index); /* DFE Tap values */
    void setTapsMV(int index, double newValue);
    void Program(); /* Program DFE with current settings,*/
};

/* ================================ */

class BranchAccDDRI2C: /* I2C Access */
    public AutomationExtender
{
    public:
    BranchAccDDRI2C(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchAccDDRI2C() {}

    int getAux(); /* High 6 bits of control register */
    void setAux( int newValue);
    void Write(int device, int address, int count, uint8_t *src); /* Write bytes */
    uint8_t *Read(int device, int address, int count, uint8_t *dest); /* Read bytes*/
    uint8_t *ReadHost(int device, int address, int count, uint8_t *dest); /* Read Host bytes */

    uint8_t ReadBYTE(int device, int channel, int page, int address); /* Read byte using special format  */
    uint32_t ReadDWORD(int device, int channel, int page, int address); /* Read DWORD using special format */
    uint16_t ReadWORD(int device, int channel, int page, int address); /* Read WORD using special format */

    void WriteBYTE(int device, int channel, int page, int address, uint8_t data); /* Write byte using special format */
    void WriteDWORD(int device, int channel, int page, int address, uint32_t data); /* Write DWORD using special format */
    void WriteWORD(int device, int channel, int page, int address, uint16_t data); /* Write WORD using special format*/
};

/* ================================ */

class BranchAccDDRRef: /* Reference clock category */
    public AutomationExtender
{
    public:
    BranchAccDDRRef(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchAccDDRRef() {}

    double getAmplMV(); /* Reference clock amplitude */
    void setAmplMV( double newValue);

    enum class Coupling
    {
        DC,
        AC
    };
    static const char *Coupling_Strings[];

    Coupling getCoupling();
    void setCoupling( Coupling newValue);
    double getDCLevelMV(); /* Reference Termination DC Level */
    void setDCLevelMV( double newValue);
    double getDelayPS(); /* Ref clock delay */
    void setDelayPS( double newValue);
    double getImpedanceOhms(); /* Reference Termination Impedance */
    void setImpedanceOhms( double newValue);
    bool getInvert(); /* Reference clock invert */
    void setInvert( bool newValue);
    bool getLink(); /* Reference DC offsets linked */
    void setLink( bool newValue);
    double getOffsetNegMV(); /* Reference clock offset negative */
    void setOffsetNegMV( double newValue);
    double getOffsetPosMV(); /* Reference clock offset */
    void setOffsetPosMV( double newValue);

    enum class TermType
    {
        DC,
        AC
    };
    static const char *TermType_Strings[];

    TermType getTermType();
    void setTermType( TermType newValue);
};

/* ================================ */

class BranchAccDDRStress: /* Stress category */
    public AutomationExtender
{
    public:
    BranchAccDDRStress(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchAccDDRStress() {}

    double getOpRateGbps(); /* Operating rate */
    void setOpRateGbps( double newValue);
    bool getRJEnabled(); /* RJ Enabled */
    void setRJEnabled( bool newValue);
    double getRJLevelPSrms(); /* RJ Level RMS */
    void setRJLevelPSrms( double newValue);
    double getSIAmplMV(); /* SI Amplitude */
    void setSIAmplMV( double newValue);
    bool getSIEnabled(); /* SI Enabled */
    void setSIEnabled( bool newValue);
    double getSIFreqMHz(); /* SI Frequency */
    void setSIFreqMHz( double newValue);
    bool getSJEnabled(); /* SJ Enabled */
    void setSJEnabled( bool newValue);
    double getSJFreqMHz(); /* SJ Frequency */
    void setSJFreqMHz( double newValue);
    double getSJLevelPSpp(); /* SJ Level */
    void setSJLevelPSpp( double newValue);
};

/* ================================ */

class BranchAccDDRTerm: /* Termination category */
        public AutomationExtender
    {
        public:
        BranchAccDDRTerm(AutomationInterface *baseDevice,const char *prefix) :
            AutomationExtender(baseDevice,prefix) {}
        virtual ~BranchAccDDRTerm() {}

        enum class CA
        {
            Off,
            _480Ohm,
            _240Ohm,
            _80Ohm,
            _60Ohm,
            _40Ohm
        };
        static const char *CA_Strings[];

        CA getCA(int index);
        void setCA(int index, CA newValue);

        enum class CK
        {
            Off,
            _480Ohm,
            _240Ohm,
            _80Ohm,
            _60Ohm,
            _40Ohm
        };
        static const char *CK_Strings[];

        CK getCK(int index);
        void setCK(int index, CK newValue);

        enum class DQ
        {
            Off,
            _240Ohm,
            _120Ohm,
            _80Ohm,
            _60Ohm,
            _48Ohm,
            _40Ohm,
            _34Ohm
        };
        static const char *DQ_Strings[];

        DQ getDQ(int index);
        void setDQ( int index,DQ newValue);

        enum class DQS
        {
            Off,
            _240Ohm,
            _120Ohm,
            _80Ohm,
            _60Ohm,
            _48Ohm,
            _40Ohm,
            _34Ohm
        };
        static const char *DQS_Strings[];

        DQS getDQS(int index);
        void setDQS( int index,DQS newValue);
        void Program(); /* Program Terminations */
    };

	/* ================================= */

class BranchAccDDRLB: /* Loopback category */
        public AutomationExtender
    {
        public:
        BranchAccDDRLB(AutomationInterface *baseDevice,const char *prefix) :
            AutomationExtender(baseDevice,prefix) {}
        virtual ~BranchAccDDRLB() {}

        void Start(); /* Start loopback (asynchronous) */
        void Cancel(); /* Loopback cancel */
        char* getStatus(char *buffer,int buflen); /* Loopback status */

        int getLogSEQ();
        void ClearLog();
        char *FetchLog(); /* Fetch log - Must free() return value */
    };

/* ================================= */

class BranchAccDDRTools: /* Tools category */
    public AutomationExtender
{
    public:
	BranchAccDDRTools(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchAccDDRTools() {}

    double getDQOffsMV();
    void setDQOffsMV(double newValue);

    double getDQSOffsMV();
    void setDQSOffsMV(double newValue);

    double getEyeDelayPS();
    void setEyeDelayPS(double newValue);

    double getEyeThreshMV();
    void setEyeThreshMV(double newValue);

    enum class AlignBy
    {
        Both,
        Time,
        Volts
    };
    static const char *AlignBy_Strings[];

    void AutoCenter(BranchAccDDRTools::AlignBy argument);
    void AutoDQ();
    void AutoDQS();

    void Cancel();
    char* getStatus(char *buffer,int buflen); /* Tools status */

    int getLogSEQ();
    void ClearLog();
    char *FetchLog(); /* Fetch tools log - Must free() return value */
};


	/* ================================= */


class BranchAccDDR: /* DDR5 accessory */
    public AutomationExtender
{
    public:

    BranchConst Const;
    BranchAccDDRCTC CTC;
    BranchAccDDRDFE DFE;
    BranchAccDDRI2C I2C;
    BranchAccDDRRef  Ref;
    BranchAccDDRStress Stress;
    BranchAccDDRTerm Term;
    BranchAccDDRLB LB;
    BranchAccDDRTools Tools;

    BranchAccDDR(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix),
	    Const(this,"Const:"),
	    CTC(this,"CTC:"),
	    DFE(this,"DFE:"),
	    I2C(this,"I2C:"),
	    Ref(this,"Ref:"),
	    Stress(this,"Stress:"),
		Term(this,"Term:"),
		LB(this,"LB:"),
		Tools(this,"Tools:") {}
    virtual ~BranchAccDDR() {}

    enum class CardType
    {
        RDIMM,
        LRDIMM,
        COMBO
    };
    static const char *CardType_Strings[];

    CardType getCardType();
    void setCardType( CardType newValue);

    enum class Channel
    {
        ChA,
        ChB
    };
    static const char *Channel_Strings[];

    Channel getChannel();
    void setChannel( Channel newValue);

    enum class ConnectClock
    {
        ClockSignals,
        DataSignals,
        CommandSignals,
        CK,
        DQS0_A,
        DQS1_A,
        DQS2_A,
        DQS3_A,
        DQS4_A,
        DQS5_A,
        DQS6_A,
        DQS7_A,
        DQS8_A,
        DQS9_A,
        DQS0_B,
        DQS1_B,
        DQS2_B,
        DQS3_B,
        DQS4_B,
        DQS5_B,
        DQS6_B,
        DQS7_B,
        DQS8_B,
        DQS9_B,
        DQ0_A,
        DQ1_A,
        DQ2_A,
        DQ3_A,
        DQ4_A,
        DQ5_A,
        DQ6_A,
        DQ7_A,
        DQ8_A,
        DQ9_A,
        DQ10_A,
        DQ11_A,
        DQ12_A,
        DQ13_A,
        DQ14_A,
        DQ15_A,
        DQ16_A,
        DQ17_A,
        DQ18_A,
        DQ19_A,
        DQ20_A,
        DQ21_A,
        DQ22_A,
        DQ23_A,
        DQ24_A,
        DQ25_A,
        DQ26_A,
        DQ27_A,
        DQ28_A,
        DQ29_A,
        DQ30_A,
        DQ31_A,
        DQ0_B,
        DQ1_B,
        DQ2_B,
        DQ3_B,
        DQ4_B,
        DQ5_B,
        DQ6_B,
        DQ7_B,
        DQ8_B,
        DQ9_B,
        DQ10_B,
        DQ11_B,
        DQ12_B,
        DQ13_B,
        DQ14_B,
        DQ15_B,
        DQ16_B,
        DQ17_B,
        DQ18_B,
        DQ19_B,
        DQ20_B,
        DQ21_B,
        DQ22_B,
        DQ23_B,
        DQ24_B,
        DQ25_B,
        DQ26_B,
        DQ27_B,
        DQ28_B,
        DQ29_B,
        DQ30_B,
        DQ31_B,
        CA0_A,
        CA1_A,
        CA2_A,
        CA3_A,
        CA4_A,
        CA5_A,
        CA6_A,
        CA0_B,
        CA1_B,
        CA2_B,
        CA3_B,
        CA4_B,
        CA5_B,
        CA6_B
    };
    static const char *ConnectClock_Strings[];

    ConnectClock getConnectClock();

    enum class ConnectData
    {
        ClockSignals,
        DataSignals,
        CommandSignals,
        CK,
        DQS0_A,
        DQS1_A,
        DQS2_A,
        DQS3_A,
        DQS4_A,
        DQS5_A,
        DQS6_A,
        DQS7_A,
        DQS8_A,
        DQS9_A,
        DQS0_B,
        DQS1_B,
        DQS2_B,
        DQS3_B,
        DQS4_B,
        DQS5_B,
        DQS6_B,
        DQS7_B,
        DQS8_B,
        DQS9_B,
        DQ0_A,
        DQ1_A,
        DQ2_A,
        DQ3_A,
        DQ4_A,
        DQ5_A,
        DQ6_A,
        DQ7_A,
        DQ8_A,
        DQ9_A,
        DQ10_A,
        DQ11_A,
        DQ12_A,
        DQ13_A,
        DQ14_A,
        DQ15_A,
        DQ16_A,
        DQ17_A,
        DQ18_A,
        DQ19_A,
        DQ20_A,
        DQ21_A,
        DQ22_A,
        DQ23_A,
        DQ24_A,
        DQ25_A,
        DQ26_A,
        DQ27_A,
        DQ28_A,
        DQ29_A,
        DQ30_A,
        DQ31_A,
        DQ0_B,
        DQ1_B,
        DQ2_B,
        DQ3_B,
        DQ4_B,
        DQ5_B,
        DQ6_B,
        DQ7_B,
        DQ8_B,
        DQ9_B,
        DQ10_B,
        DQ11_B,
        DQ12_B,
        DQ13_B,
        DQ14_B,
        DQ15_B,
        DQ16_B,
        DQ17_B,
        DQ18_B,
        DQ19_B,
        DQ20_B,
        DQ21_B,
        DQ22_B,
        DQ23_B,
        DQ24_B,
        DQ25_B,
        DQ26_B,
        DQ27_B,
        DQ28_B,
        DQ29_B,
        DQ30_B,
        DQ31_B,
        CA0_A,
        CA1_A,
        CA2_A,
        CA3_A,
        CA4_A,
        CA5_A,
        CA6_A,
        CA0_B,
        CA1_B,
        CA2_B,
        CA3_B,
        CA4_B,
        CA5_B,
        CA6_B
    };
    static const char *ConnectData_Strings[];

    ConnectData getConnectData();

    enum class Device
    {
        DRAM,
        RCD,
        DB
    };
    static const char *Device_Strings[];

    Device getDevice();
    void setDevice( Device newValue);

    enum class DramType
    {
        _1RX4,
        _1RX8,
        _2RX4,
        _2RX8
    };
    static const char *DramType_Strings[];

    DramType getDramType();
    void setDramType( DramType newValue);

    enum class Host
    {
        Host0,
        Host1,
        Host2,
        Host3,
        Host4,
        Host5,
        Host6,
        Host7
    };
    static const char *Host_Strings[];

    Host getHost();
    void setHost( Host newValue);
    Host getRCDHost();
    void setRCDHost( Host newValue);
    Host getGpioHost();
    void setGpioHost( Host newValue);

    enum class Lane
    {
        DQ0_A,
        DQ1_A,
        DQ2_A,
        DQ3_A,
        DQ4_A,
        DQ5_A,
        DQ6_A,
        DQ7_A,
        DQ8_A,
        DQ9_A,
        DQ10_A,
        DQ11_A,
        DQ12_A,
        DQ13_A,
        DQ14_A,
        DQ15_A,
        DQ16_A,
        DQ17_A,
        DQ18_A,
        DQ19_A,
        DQ20_A,
        DQ21_A,
        DQ22_A,
        DQ23_A,
        DQ24_A,
        DQ25_A,
        DQ26_A,
        DQ27_A,
        DQ28_A,
        DQ29_A,
        DQ30_A,
        DQ31_A,
        DQ0_B,
        DQ1_B,
        DQ2_B,
        DQ3_B,
        DQ4_B,
        DQ5_B,
        DQ6_B,
        DQ7_B,
        DQ8_B,
        DQ9_B,
        DQ10_B,
        DQ11_B,
        DQ12_B,
        DQ13_B,
        DQ14_B,
        DQ15_B,
        DQ16_B,
        DQ17_B,
        DQ18_B,
        DQ19_B,
        DQ20_B,
        DQ21_B,
        DQ22_B,
        DQ23_B,
        DQ24_B,
        DQ25_B,
        DQ26_B,
        DQ27_B,
        DQ28_B,
        DQ29_B,
        DQ30_B,
        DQ31_B,
        CA0_A,
        CA1_A,
        CA2_A,
        CA3_A,
        CA4_A,
        CA5_A,
        CA6_A,
        CA0_B,
        CA1_B,
        CA2_B,
        CA3_B,
        CA4_B,
        CA5_B,
        CA6_B
    };
    static const char *Lane_Strings[];

    Lane getLane();
    void setLane( Lane newValue);
    bool getPdaEarlyClocking(); /* PDA Enumerate before clocking (reqd for Micron loopback) */
    void setPdaEarlyClocking( bool newValue);

    enum class Phase
    {
        PhaseA,
        PhaseB,
        PhaseC,
        PhaseD
    };
    static const char *Phase_Strings[];

    Phase getPhase();
    void setPhase( Phase newValue);

    enum class Rank
    {
        R0,
        R1
    };
    static const char *Rank_Strings[];

    Rank getRank();
    void setRank( Rank newValue);

    enum class Speed
    {
        DDR5m3200,
        DDR5m3600,
        DDR5m4000,
        DDR5m4400,
        DDR5m4800,
        DDR5m5200,
        DDR5m5600,
        DDR5m6000,
        DDR5m6400
    };
    static const char *Speed_Strings[];

    Speed getSpeed();
    void setSpeed( Speed newValue);
    char *FetchDevices(); /* Fetch list of devices currently available - Must free() return value. */
    char *FetchLanes(); /* Fetch list of lanes currently available - Must free() return value. */
    char *FetchPhases(); /* Fetch list of phases currently available - Must free() return value. */

    enum class PowerOp
	{
    	pwrOn,
		pwerOff,
		pwrReset
	};

    static const char *PowerOp_Strings[];

    void PowerOn( PowerOp arg = PowerOp::pwrReset ); /* Power-on MIC. */
    void ProgramPhase(); /* Program Phase DRAM+RCD */
};

/* ================================ */

 class BranchAccPUL: /* Pulser accessory */
     public AutomationExtender
 {
     public:
	 BranchConst Const;
     BranchAccPUL(AutomationInterface *baseDevice,const char *prefix) :
         AutomationExtender(baseDevice,prefix),
		 Const(this,"Const:") {}
     virtual ~BranchAccPUL() {}

     double getAmplMV(); /* Pulse amplitude */
     void setAmplMV( double newValue);
     double getDiffSkewPS(); /* Differential Skew */
     void setDiffSkewPS( double newValue);
     bool getNegEnabled(); /* Negative leg enabled */
     void setNegEnabled( bool newValue);
     bool getPosEnabled(); /* Positive leg enabled */
     void setPosEnabled( bool newValue);
     double getTrigRateGHz(); /* Trigger rate */
     void setTrigRateGHz( double newValue);

     enum class Width
     {
         _1,
         _2,
         _4,
         _8,
         _16
     };
     static const char *Width_Strings[];

     Width getWidth();
     void setWidth( Width newValue);
 };

 /* ================================ */

 class BranchAcc: /* Accessory connector */
     public AutomationExtender
 {
     public:
 	BranchAccDDR DDR;
 	BranchAccPUL PUL;

     BranchAcc(AutomationInterface *baseDevice,const char *prefix) :
         AutomationExtender(baseDevice,prefix),
			DDR(this,"DDR:"),
			PUL(this,"PUL:") {}
     virtual ~BranchAcc() {}

     bool getIsAttached(); /* Probe is attached */

     enum class Type
     {
         None,
         DDR5,
         Pulser
     };
     static const char *Type_Strings[];

     Type getType();
     void setType( Type newValue);
 };


#endif // AUTOGEN_ACCESSORY_H


