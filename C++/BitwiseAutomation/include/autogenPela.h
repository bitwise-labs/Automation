/* autogenPela.h */
//================================================================================
// BOOST SOFTWARE LICENSE
//
// Copyright 2020 BitWise Laboratories Inc.
// Author.......Jim Waschura
// Contact......info@bitwiselabs.com
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.
//================================================================================

#ifndef AUTOGEN_PELA_H
#define AUTOGEN_PELA_H

#include "autogenCommon.h"
#include "autogenAccessory.h"

/* ================================ */

class BranchBasic: /* Basic ELA Application */
    public AutomationExtender
{
    public:
    BranchBasic(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchBasic() {}

    char* getBasicReport(char *buffer,int buflen); /* Basic Ela report of 24 things */
    long long getBits(int index); /* Bit Count Result */
    double getCapturePcnt(int index); /* Capture rate */
    double getCBER(int index); /* Captured BER */
    double getCSER(int index); /* Captured SER */
    bool getEnabled(int index); /* Enable processor */
    long long getErrors(int index); /* Bit Errors Count Result */

    enum class Pattern
    {
        AllZeros,
        AllOnes,
        Prbs7,
        InvPrbs7,
        Prbs11,
        InvPrbs11,
        Prbs13,
        InvPrbs13,
        Prbs15,
        InvPrbs15,
        Prbs20,
        InvPrbs20,
        Prbs23,
        InvPrbs23,
        Prbs31,
        InvPrbs31,
        RamGrab,
        InvRamGrab,
        RamShift,
        InvRamShift,
        None,
        Unknown
    };
    static const char *Pattern_Strings[];

    Pattern getPattern(int index);
    bool getPhaseFound(int index); /* Pattern Phase Found */
    int getResyncCount(int index); /* Resync Count Result */

    enum class Status
    {
        NotAvail,
        Disabled,
        Stopped,
        Running
    };
    static const char *Status_Strings[];

    Status getStatus(int index);
    int getSymbolSizeBits(int index); /* Symbol Size */
};

/* ================================ */

class BranchBlockChannel: /* Channel Category */
	public AutomationExtender
{
	public:
	BranchBlockChannel(AutomationInterface *baseDevice,const char *prefix) :
		AutomationExtender(baseDevice,prefix) {}
	virtual ~BranchBlockChannel() {}

	char *getBinary(int *pcount=0); /* Packed histogram binary data, char[] - Must free() return value */
	int getBins(); /* Histogram bin count */
	void setBins( int newValue);
	int getBlockSize(); /* Block Size */
	double getBottom(); /* Chart Bottom */
	void setBottom( double newValue);
	bool getCursAvail(int index); /* Chart Cursor Available */
	bool getCursEnabled(int index); /* Chart Cursor Enabled */
	void setCursEnabled(int index, bool newValue);
	char* getCursLabel(int index,char *buffer,int buflen); /* Chart Cursor Label */
	double getCursValue(int index); /* Chart Cursor Value */
	void setCursValue(int index, double newValue);
	bool getEnabled(); /* Enable processor */
	double getHeight(); /* Chart Height */
	void setHeight( double newValue);
	int getHistory(); /* Histogram history length */
	void setHistory( int newValue);
	char* getHReport(char *buffer,int buflen); /* Report-Pop,Ovrflw,Min,Max,Start,End,HistryLen */
	int getHSeq(); /* Histogram Sequence number */
	double getLeft(); /* Chart Left */
	void setLeft( double newValue);
	double getLimits(int index); /* Chart Limits (LRBT) */
	bool getLocked(); /* Chart Locked */
	void setLocked( bool newValue);
	bool getLogscale(); /* Chart LogScale */
	void setLogscale( bool newValue);
	double getOffset(); /* Histogram bin offset */
	void setOffset( double newValue);
	char* getReport(char *buffer,int buflen); /* Report-Total,Squelched,Processed,InErr,Max,Avg,Rate */
	double getResol(); /* Histogram bin resolution */
	void setResol( double newValue);

	enum class Scroll
	{
		None,
		X1,
		X2,
		X3,
		X4,
		DX12,
		DX34,
		XPan,
		XScale,
		Y1,
		Y2,
		Y3,
		Y4,
		DY12,
		DY34,
		YPan,
		YScale,
		P1,
		P2,
		P3
	};
	static const char *Scroll_Strings[];

	Scroll getScroll();
	void setScroll( Scroll newValue);
	bool getShowMemory(); /* Show memories */
	void setShowMemory( bool newValue);
	bool getShowOverlays(); /* Show overlays */
	void setShowOverlays( bool newValue);
	bool getShowSettings(); /* Show Settings */
	void setShowSettings( bool newValue);

	enum class Status
	{
		NotAvail,
		Disabled,
		Stopped,
		Running
	};
	static const char *Status_Strings[];

	Status getStatus();
	char* getTitle(char *buffer,int buflen); /* Chart Title */
	double getWidth(); /* Chart Width */
	void setWidth( double newValue);
	char* Csv(char *buffer,int buflen, const char *optFilename=NULL); /* Download CSV File*/
	void Fit(); /* Fit chart to data */
	void Reset(); /* Reset chart */
	void MapRange(double fromValue, double toValue); /* Map histogram to fit range,*/
};
/* ================================ */

class BranchBlock: /* Block ELA Application */
    public AutomationExtender
{
    public:
	BranchBlockChannel Ch0;
	BranchBlockChannel Ch1;
	BranchBlockChannel Cmb;

    BranchBlock(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix),
		Ch0(this,"Ch0:"),
		Ch1(this,"Ch1:"),
		Cmb(this,"Cmb:") {}
    virtual ~BranchBlock() {}
};

/* ================================ */

class BranchBurstChannel: /* Channel Category */
	public AutomationExtender
{
	public:
	BranchBurstChannel(AutomationInterface *baseDevice,const char *prefix) :
		AutomationExtender(baseDevice,prefix) {}
	virtual ~BranchBurstChannel() {}

	char *getBinary(int *pcount=0); /* Packed histogram binary data, char[] - Must free() return value */
	int getBins(); /* Histogram bin count */
	void setBins( int newValue);
	double getBottom(); /* Chart Bottom */
	void setBottom( double newValue);
	bool getCursAvail(int index); /* Chart Cursor Available */
	bool getCursEnabled(int index); /* Chart Cursor Enabled */
	void setCursEnabled(int index, bool newValue);
	char* getCursLabel(int index,char *buffer,int buflen); /* Chart Cursor Label */
	double getCursValue(int index); /* Chart Cursor Value */
	void setCursValue(int index, double newValue);
	bool getEnabled(); /* Enable processor */
	double getHeight(); /* Chart Height */
	void setHeight( double newValue);
	int getHistory(); /* Histogram history length */
	void setHistory( int newValue);
	char* getHReport(char *buffer,int buflen); /* Report-Pop,Ovrflw,Min,Max,Start,End,HistryLen */
	int getHSeq(); /* Histogram Sequence number */
	double getLeft(); /* Chart Left */
	void setLeft( double newValue);
	double getLimits(int index); /* Chart Limits (LRBT) */
	bool getLocked(); /* Chart Locked */
	void setLocked( bool newValue);
	bool getLogscale(); /* Chart LogScale */
	void setLogscale( bool newValue);
	double getOffset(); /* Histogram bin offset */
	void setOffset( double newValue);
	double getResol(); /* Histogram bin resolution */
	void setResol( double newValue);

	enum class Scroll
	{
		None,
		X1,
		X2,
		X3,
		X4,
		DX12,
		DX34,
		XPan,
		XScale,
		Y1,
		Y2,
		Y3,
		Y4,
		DY12,
		DY34,
		YPan,
		YScale,
		P1,
		P2,
		P3
	};
	static const char *Scroll_Strings[];

	Scroll getScroll();
	void setScroll( Scroll newValue);
	int getSeparation(); /* Minimum Efi */
	void setSeparation( int newValue);
	bool getShowMemory(); /* Show memories */
	void setShowMemory( bool newValue);
	bool getShowOverlays(); /* Show overlays */
	void setShowOverlays( bool newValue);
	bool getShowSettings(); /* Show Settings */
	void setShowSettings( bool newValue);

	enum class Status
	{
		NotAvail,
		Disabled,
		Stopped,
		Running
	};
	static const char *Status_Strings[];

	Status getStatus();
	char* getTitle(char *buffer,int buflen); /* Chart Title */
	double getWidth(); /* Chart Width */
	void setWidth( double newValue);
	char* Csv(char *buffer,int buflen, const char *optFilename=NULL); /* Download CSV File*/
	void Fit(); /* Fit chart to data*/
	void Reset(); /* Reset chart */
	void MapRange(double fromValue, double toValue); /* Map histogram to fit range,*/
};

/* ================================ */

class BranchBurst: /* Burst ELA Application */
    public AutomationExtender
{
    public:
	BranchBurstChannel Ch0;
	BranchBurstChannel Ch1;
	BranchBurstChannel Cmb;

    BranchBurst(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix),
		Ch0(this,"Ch0:"),
		Ch1(this,"Ch1:"),
		Cmb(this,"Cmb:") {}
    virtual ~BranchBurst() {}
};

/* ================================ */

class BranchData: /* Data Application */
    public AutomationExtender
{
    public:
    BranchData(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchData() {}

    enum class BitsFmt
    {
        Scientific,
        Decimal
    };
    static const char *BitsFmt_Strings[];

    BitsFmt getBitsFmt();
    void setBitsFmt( BitsFmt newValue);
    double getDataRateGHz(); /* Data Rate */

    enum class DataLinkMode
    {
        Ch0,
        Ch1,
        Unlinked,
        Interleaved
    };
    static const char *DataLinkMode_Strings[];

    DataLinkMode getDataLinkMode();
    bool getDataShowAllCh(); /* Data Show All Channels */
    double getElapsedSeconds(); /* Elapsed Time Seconds */

    enum class Running
    {
        Stop,
        Run,
        RunOnce
    };
    static const char *Running_Strings[];

    Running getRunning();
    int getSequence(); /* Run Sequence */
    bool getShowSettings(); /* Show Settings */
    void setShowSettings( bool newValue);
    int getSymbolSizeBits(int index); /* Global bits per symbol */
    void setSymbolSizeBits(int index, int newValue);
    double getTransferBytessec(); /* Bytes per second */
    char* Csv(char *buffer,int buflen, const char *optFilename=NULL); /* Save ELA Results in CSV file */
    long long getCommonBits(); /* Common bit count */
    int getCommonBuffers(); /* Number of buffers */
    bool getCommonEnabled(); /* Common Enable processor */
    double getCommonMarkDensityPcnt(); /* Common mark density */
    long long getCommonMarks(); /* Common mark count */

    enum class CommonStatus
    {
        NotAvail,
        Disabled,
        Stopped,
        Running
    };
    static const char *CommonStatus_Strings[];

    CommonStatus getCommonStatus();
};

/* ================================ */

class BranchPelaED: /* Pela Error Detector Access */
    public AutomationExtender
{
    public:
    BranchPelaED(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchPelaED() {}

    char* getAutoClockMsg(char *buffer,int buflen); /* Autoset clock results */
    char* getAutoDataMsg(char *buffer,int buflen); /* Autoset data results */
    bool getAutoResync(int index); /* Auto Resync Enable */
    void setAutoResync(int index, bool newValue);

    enum class AuxIn1
    {
        Marker
    };
    static const char *AuxIn1_Strings[];

    AuxIn1 getAuxIn1();
    void setAuxIn1( AuxIn1 newValue);

    enum class AuxIn2
    {
        Blanking
    };
    static const char *AuxIn2_Strings[];

    AuxIn2 getAuxIn2();
    void setAuxIn2( AuxIn2 newValue);

    enum class AuxOut1
    {
        Ch0Pattern,
        Ch1Pattern,
        Ch0Error,
        Ch1Error,
        AnyError,
        WordClock,
        AuxLoopback,
        Off
    };
    static const char *AuxOut1_Strings[];

    AuxOut1 getAuxOut1();
    void setAuxOut1( AuxOut1 newValue);

    enum class AuxOut2
    {
        Ch0Pattern,
        Ch1Pattern,
        Ch0Error,
        Ch1Error,
        AnyError,
        WordClock,
        AuxLoopback,
        Off
    };
    static const char *AuxOut2_Strings[];

    AuxOut2 getAuxOut2();
    void setAuxOut2( AuxOut2 newValue);
    double getDataRateGHz(); /* Data Rate */
    double getClockRateGHz(); /* Input Clock Rate */
    double getClockThreshMV(); /* Clock threshold */
    void setClockThreshMV( double newValue);

    enum class ClockType
    {
        Fullrate,
        Halfrate
    };
    static const char *ClockType_Strings[];

    ClockType getClockType();
    void setClockType( ClockType newValue);
    double getDelayPS(int index); /* Delay */
    void setDelayPS(int index, double newValue);

    enum class DetPatt
    {
        AllZeros,
        AllOnes,
        Prbs7,
        InvPrbs7,
        Prbs11,
        InvPrbs11,
        Prbs13,
        InvPrbs13,
        Prbs15,
        InvPrbs15,
        Prbs20,
        InvPrbs20,
        Prbs23,
        InvPrbs23,
        Prbs31,
        InvPrbs31,
        RamGrab,
        InvRamGrab,
        RamShift,
        InvRamShift,
        None,
        Unknown
    };
    static const char *DetPatt_Strings[];

    DetPatt getDetPatt(int index);
    int getDetShift(int index); /* Detected Shift */
    bool getGrayCode(); /* Using Gray Coding (MSB=Ch1, LSB=Ch0) */
    void setGrayCode( bool newValue);
    bool getInSync(int index); /* In Sync Flag */

    enum class LinkMode
    {
        Ch0,
        Ch1,
        Unlinked,
        Interleaved
    };
    static const char *LinkMode_Strings[];

    LinkMode getLinkMode();
    void setLinkMode( LinkMode newValue);
    int getManualAmount(int index); /* Manual Shift Amount */
    void setManualAmount(int index, int newValue);
    bool getManualShift(); /* Manual Shift Enable */
    void setManualShift( bool newValue);
    double getOperatingRateGHz(); /* Operating Clock Rate */

    enum class Patt
    {
        AllZeros,
        AllOnes,
        Prbs7,
        InvPrbs7,
        Prbs11,
        InvPrbs11,
        Prbs13,
        InvPrbs13,
        Prbs15,
        InvPrbs15,
        Prbs20,
        InvPrbs20,
        Prbs23,
        InvPrbs23,
        Prbs31,
        InvPrbs31,
        RamGrab,
        InvRamGrab,
        RamShift,
        InvRamShift,
        Auto,
        Unknown
    };
    static const char *Patt_Strings[];

    Patt getPatt(int index);
    void setPatt(int index, Patt newValue);
    int getResyncThresh(int index); /* Resync Threshold */
    void setResyncThresh(int index, int newValue);
    bool getShowAllCh(); /* Show All Channels */
    void setShowAllCh( bool newValue);
    double getThreshMV(int index); /* Threshold */
    void setThreshMV(int index, double newValue);
    int getUserWordsWords(int index); /* User words */
    void setUserWordsWords(int index, int newValue);
    bool getUsingEye(); /* Using Eye Diagramming */

    void ResetClock(); /* Reset Clocking */

    enum class EDChannels
    {
        All,
        Ch0,
        Ch1,
    };
    static const char *EDChannels_Strings[];

    void AutosetData(EDChannels ch = EDChannels::All); /* Perform Data Autoset */
    void Resync(EDChannels ch = EDChannels::All); /* Manual Resync */
    void SetDefaults(EDChannels ch = EDChannels::All); /* Set Channel Defaults, */
};

/* ================================ */

class BranchEfiChannel: /* Channel Category */
	public AutomationExtender
{
	public:
	BranchEfiChannel(AutomationInterface *baseDevice,const char *prefix) :
		AutomationExtender(baseDevice,prefix) {}
	virtual ~BranchEfiChannel() {}

	char *getBinary(int *pcount=0); /* Packed histogram binary data, char[] - Must free() return value */
	int getBins(); /* Histogram bin count */
	void setBins( int newValue);
	double getBottom(); /* Chart Bottom */
	void setBottom( double newValue);
	bool getCursAvail(int index); /* Chart Cursor Available */
	bool getCursEnabled(int index); /* Chart Cursor Enabled */
	void setCursEnabled(int index, bool newValue);
	char* getCursLabel(int index,char *buffer,int buflen); /* Chart Cursor Label */
	double getCursValue(int index); /* Chart Cursor Value */
	void setCursValue(int index, double newValue);
	bool getEnabled(); /* Enable processor */
	double getHeight(); /* Chart Height */
	void setHeight( double newValue);
	int getHistory(); /* Histogram history length */
	void setHistory( int newValue);
	char* getHReport(char *buffer,int buflen); /* Report-Pop,Ovrflw,Min,Max,Start,End,HistryLen */
	int getHSeq(); /* Histogram Sequence number */
	double getLeft(); /* Chart Left */
	void setLeft( double newValue);
	double getLimits(int index); /* Chart Limits (LRBT) */
	bool getLocked(); /* Chart Locked */
	void setLocked( bool newValue);
	bool getLogscale(); /* Chart LogScale */
	void setLogscale( bool newValue);
	double getOffset(); /* Histogram bin offset */
	void setOffset( double newValue);
	double getResol(); /* Histogram bin resolution */
	void setResol( double newValue);

	enum class Scroll
	{
		None,
		X1,
		X2,
		X3,
		X4,
		DX12,
		DX34,
		XPan,
		XScale,
		Y1,
		Y2,
		Y3,
		Y4,
		DY12,
		DY34,
		YPan,
		YScale,
		P1,
		P2,
		P3
	};
	static const char *Scroll_Strings[];

	Scroll getScroll();
	void setScroll( Scroll newValue);
	bool getShowMemory(); /* Show memories */
	void setShowMemory( bool newValue);
	bool getShowOverlays(); /* Show overlays */
	void setShowOverlays( bool newValue);
	bool getShowSettings(); /* Show Settings */
	void setShowSettings( bool newValue);

	enum class Status
	{
		NotAvail,
		Disabled,
		Stopped,
		Running
	};
	static const char *Status_Strings[];

	Status getStatus();
	char* getTitle(char *buffer,int buflen); /* Chart Title */
	double getWidth(); /* Chart Width */
	void setWidth( double newValue);
	char* Csv(char *buffer,int buflen, const char *optFilename=NULL); /* Download CSV File */
	void Fit(); /* Fit chart to data,  */
	void Reset(); /* Reset chart, */
	void MapRange(double fromValue, double toValue); /* Map histogram to fit range,*/
};

/* ================================ */

class BranchEfi: /* Efi ELA Application */
    public AutomationExtender
{
    public:
	BranchEfiChannel Ch0;
	BranchEfiChannel Ch1;
	BranchEfiChannel Cmb;

    BranchEfi(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix),
		Ch0(this,"Ch0:"),
		Ch1(this,"Ch1:"),
		Cmb(this,"Cmb") {}
    virtual ~BranchEfi() {}

};

/* ================================ */

class BranchEla: /* Pela ELA Application */
    public AutomationExtender
{
    public:
    BranchEla(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchEla() {}

    enum class BitOrder
    {
        MsbFirst,
        LsbFirst
    };
    static const char *BitOrder_Strings[];

    BitOrder getBitOrder();
    void setBitOrder( BitOrder newValue);

    enum class BitsFmt
    {
        Scientific,
        Decimal
    };
    static const char *BitsFmt_Strings[];

    BitsFmt getBitsFmt();
    void setBitsFmt( BitsFmt newValue);
    int getBlockSizeSymbols(int index); /* Global symbols per block */
    void setBlockSizeSymbols(int index, int newValue);
    double getElaDataRateGHz(); /* Ela Data Rate */

    enum class ElaLinkMode
    {
        Ch0,
        Ch1,
        Unlinked,
        Interleaved
    };
    static const char *ElaLinkMode_Strings[];

    ElaLinkMode getElaLinkMode();
    double getElapsedSeconds(); /* Elapsed Time Seconds */
    char* getElaReport(char *buffer,int buflen); /* Ela report of 10 things */
    bool getElaShowAllCh(); /* Ela Show All Channels */
    char* getFile(char *buffer,int buflen); /* Ela Filename */
    void setFile( const char* newValue);
    int getLimitMBMB(); /* File Limit MB */
    void setLimitMBMB( int newValue);
    bool getRecordOnly(); /* ELA Record Only flag */
    void setRecordOnly( bool newValue);

    enum class Running
    {
        Stop,
        Run,
        RunOnce
    };
    static const char *Running_Strings[];

    Running getRunning();
    int getSequence(); /* Run Sequence */
    bool getShowSettings(); /* Show Settings */
    void setShowSettings( bool newValue);
    double getSizeMBMB(); /* File size MB */
    int getSymbolSizeBits(int index); /* Global bits per symbol */
    void setSymbolSizeBits(int index, int newValue);
    double getTransferBytessec(); /* Bytes per second */
    char* Csv(char *buffer,int buflen, const char *optFilename=NULL); /* Save ELA Results in CSV file */
    double getCommonCapturePcnt(); /* Common Capture percentage */
    bool getCommonEnabled(); /* Common Enable processor */
    int getCommonEvents(int index); /* Event Count M,R,S,B,P */
    long long getCommonLongRecords(); /* Long Record Count */
    long long getCommonMediumRecords(); /* Medium Record Count */
    bool getCommonResyncLev(); /* Resynchronization Level */
    long long getCommonShortRecords(); /* Short Record Count */

    enum class CommonStatus
    {
        NotAvail,
        Disabled,
        Stopped,
        Running
    };
    static const char *CommonStatus_Strings[];

    CommonStatus getCommonStatus();
};

/* ================================ */

class BranchErrCfg: /* Configuration */
    public AutomationExtender
{
    public:
    BranchErrCfg(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchErrCfg() {}

    double getIntervalSeconds(); /* Update interval */
    void setIntervalSeconds( double newValue);
    int getReclen(); /* Record Length */
    void setReclen( int newValue);
};

/* ================================ */

class BranchErrChart: /* Chart View */
    public AutomationExtender
{
    public:
    BranchErrChart(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchErrChart() {}

    double getBottomLogBER(); /* Chart Bottom */
    void setBottomLogBER( double newValue);
    bool getCursAvail(int index); /* Chart Cursor Available */
    bool getCursEnabled(int index); /* Chart Cursor Enabled */
    void setCursEnabled(int index, bool newValue);
    char* getCursLabel(int index,char *buffer,int buflen); /* Chart Cursor Label */
    double getCursValue(int index); /* Chart Cursor Value */
    void setCursValue(int index, double newValue);
    double getHeightLogBER(); /* Chart Height */
    void setHeightLogBER( double newValue);
    double getLeftSeconds(); /* Chart Left */
    void setLeftSeconds( double newValue);
    double getLimits(int index); /* Chart Limits (LRBT) */
    bool getLocked(); /* Chart Locked */
    void setLocked( bool newValue);
    bool getLogscale(); /* Chart LogScale */
    void setLogscale( bool newValue);

    enum class Scroll
    {
        None,
        X1,
        X2,
        X3,
        X4,
        DX12,
        DX34,
        XPan,
        XScale,
        Y1,
        Y2,
        Y3,
        Y4,
        DY12,
        DY34,
        YPan,
        YScale,
        P1,
        P2,
        P3
    };
    static const char *Scroll_Strings[];

    Scroll getScroll();
    void setScroll( Scroll newValue);
    bool getShowMemory(); /* Show memories */
    void setShowMemory( bool newValue);
    bool getShowOverlays(); /* Show overlays */
    void setShowOverlays( bool newValue);
    char* getTitle(char *buffer,int buflen); /* Chart Title */
    double getWidthSeconds(); /* Chart Width */
    void setWidthSeconds( double newValue);
};

/* ================================ */

class BranchErr: /* Error Rate Application */
    public AutomationExtender
{
    public:
	BranchErrCfg Cfg;
	BranchErrChart Chart;

    BranchErr(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix),
		Cfg(this,"Cfg:"),
		Chart(this,"Chart:") {}
    virtual ~BranchErr() {}

    double getABER(int index); /* Accumulated BER Result */
    char* getBerReport(char *buffer,int buflen); /* Ber report of 15 things */
    char *getBinary(int *pcount=0); /* Binary Data, float[] - Must free() return value */
    long long getBits(int index); /* Bit Count Result */

    enum class BitsFmt
    {
        Scientific,
        Decimal
    };
    static const char *BitsFmt_Strings[];

    BitsFmt getBitsFmt();
    void setBitsFmt( BitsFmt newValue);
    double getElapsedSeconds(); /* Elapsed Time Seconds */
    long long getErrors(int index); /* Bit Errors Count Result */
    double getIBER(int index); /* Instantaneous BER Result */
    long long getResyncCount(int index); /* Resync Count */

    enum class Running
    {
        Stop,
        Run,
        RunOnce
    };
    static const char *Running_Strings[];

    Running getRunning();
    int getSequence(); /* Run Sequence */
    int getSerial(); /* Serial Number of Integration */
    bool getShowSettings(); /* Show Settings */
    void setShowSettings( bool newValue);
    bool getShowStripSettings(); /* Show Strip Chart Settings */
    void setShowStripSettings( bool newValue);
    char* Csv(char *buffer,int buflen, const char *optFilename=NULL); /* PelaED Csv */
    char* Csv2(char *buffer,int buflen, const char *optFilename=NULL); /* PelaErr Csv */
    void Fit(); /* PelaED Chart Fit, */
    void Reset(); /* Reset position, */
};

/* ================================ */

class BranchMaxTChannel: /* Channel Category */
public AutomationExtender
{
	public:
	BranchMaxTChannel(AutomationInterface *baseDevice,const char *prefix) :
		AutomationExtender(baseDevice,prefix) {}
	virtual ~BranchMaxTChannel() {}

	char *getBinary(int *pcount=0); /* Binary Data, float[] - Must free() return value */
	int getBlockSize(); /* Block Size */
	double getBottom(); /* Chart Bottom */
	void setBottom( double newValue);
	bool getCursAvail(int index); /* Chart Cursor Available */
	bool getCursEnabled(int index); /* Chart Cursor Enabled */
	void setCursEnabled(int index, bool newValue);
	char* getCursLabel(int index,char *buffer,int buflen); /* Chart Cursor Label */
	double getCursValue(int index); /* Chart Cursor Value */
	void setCursValue(int index, double newValue);
	bool getEnabled(); /* Enable processor */
	double getHeight(); /* Chart Height */
	void setHeight( double newValue);
	double getIntervalSeconds(); /* Update interval */
	void setIntervalSeconds( double newValue);
	double getLeft(); /* Chart Left */
	void setLeft( double newValue);
	double getLimits(int index); /* Chart Limits (LRBT) */
	bool getLocked(); /* Chart Locked */
	void setLocked( bool newValue);
	bool getLogscale(); /* Chart LogScale */
	void setLogscale( bool newValue);
	int getReclen(); /* Record Length */
	void setReclen( int newValue);
	char* getReport(char *buffer,int buflen); /* Report-TotalBlocks */

	enum class Scroll
	{
		None,
		X1,
		X2,
		X3,
		X4,
		DX12,
		DX34,
		XPan,
		XScale,
		Y1,
		Y2,
		Y3,
		Y4,
		DY12,
		DY34,
		YPan,
		YScale,
		P1,
		P2,
		P3
	};
	static const char *Scroll_Strings[];

	Scroll getScroll();
	void setScroll( Scroll newValue);
	int getSerial(); /* Serial Number of Integration */
	bool getShowMemory(); /* Show memories */
	void setShowMemory( bool newValue);
	bool getShowOverlays(); /* Show overlays */
	void setShowOverlays( bool newValue);
	bool getShowSettings(); /* Show Settings */
	void setShowSettings( bool newValue);

	enum class Status
	{
		NotAvail,
		Disabled,
		Stopped,
		Running
	};
	static const char *Status_Strings[];

	Status getStatus();
	char* getTitle(char *buffer,int buflen); /* Chart Title */
	double getWidth(); /* Chart Width */
	void setWidth( double newValue);
	char* Csv(char *buffer,int buflen, const char *optFilename=NULL); /* Download CSV File */
	void Fit(); /* Fit chart to data, */
};

/* ================================ */

class BranchMaxT: /* MaxT ELA Application */
    public AutomationExtender
{
    public:
    BranchMaxTChannel Ch0;
    BranchMaxTChannel Ch1;
    BranchMaxTChannel Cmb;

    BranchMaxT(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix),
		Ch0(this,"Ch0:"),
		Ch1(this,"Ch1:"),
		Cmb(this,"Cmb:")
    {}
    virtual ~BranchMaxT() {}
};

/* ================================ */

class BranchModChannel: /* Channel Category */
	public AutomationExtender
{
	public:
	BranchModChannel(AutomationInterface *baseDevice,const char *prefix) :
		AutomationExtender(baseDevice,prefix) {}
	virtual ~BranchModChannel() {}

	char *getBinary(int *pcount=0); /* Packed histogram binary data, char[] - Must free() return value */
	int getBins(); /* Histogram bin count */
	void setBins( int newValue);
	double getBottom(); /* Chart Bottom */
	void setBottom( double newValue);
	bool getCursAvail(int index); /* Chart Cursor Available */
	bool getCursEnabled(int index); /* Chart Cursor Enabled */
	void setCursEnabled(int index, bool newValue);
	char* getCursLabel(int index,char *buffer,int buflen); /* Chart Cursor Label */
	double getCursValue(int index); /* Chart Cursor Value */
	void setCursValue(int index, double newValue);
	bool getEnabled(); /* Enable processor */
	double getHeight(); /* Chart Height */
	void setHeight( double newValue);
	int getHistory(); /* Histogram history length */
	void setHistory( int newValue);
	char* getHReport(char *buffer,int buflen); /* Report-Pop,Ovrflw,Min,Max,Start,End,HistryLen */
	int getHSeq(); /* Histogram Sequence number */
	double getLeft(); /* Chart Left */
	void setLeft( double newValue);
	double getLimits(int index); /* Chart Limits (LRBT) */
	bool getLocked(); /* Chart Locked */
	void setLocked( bool newValue);
	bool getLogscale(); /* Chart LogScale */
	void setLogscale( bool newValue);
	int getModSize(); /* Modulo Size */
	void setModSize( int newValue);

	enum class ModType
	{
		Pattern,
		Manual
	};
	static const char *ModType_Strings[];

	ModType getModType();
	void setModType( ModType newValue);
	double getOffset(); /* Histogram bin offset */
	void setOffset( double newValue);
	char* getPattern(char *buffer,int buflen); /* Pattern Type */
	char* getReport(char *buffer,int buflen); /* Report-ModSize,ModPattern */
	double getResol(); /* Histogram bin resolution */
	void setResol( double newValue);

	enum class Scroll
	{
		None,
		X1,
		X2,
		X3,
		X4,
		DX12,
		DX34,
		XPan,
		XScale,
		Y1,
		Y2,
		Y3,
		Y4,
		DY12,
		DY34,
		YPan,
		YScale,
		P1,
		P2,
		P3
	};
	static const char *Scroll_Strings[];

	Scroll getScroll();
	void setScroll( Scroll newValue);
	int getSeed(); /* Pattern Seed */
	bool getShowMemory(); /* Show memories */
	void setShowMemory( bool newValue);
	bool getShowOverlays(); /* Show overlays */
	void setShowOverlays( bool newValue);
	bool getShowSettings(); /* Show Settings */
	void setShowSettings( bool newValue);

	enum class Status
	{
		NotAvail,
		Disabled,
		Stopped,
		Running
	};
	static const char *Status_Strings[];

	Status getStatus();
	char* getTitle(char *buffer,int buflen); /* Chart Title */
	double getWidth(); /* Chart Width */
	void setWidth( double newValue);
	char* Csv(char *buffer,int buflen, const char *optFilename=NULL); /* Download CSV File */
	void Fit(); /* Fit chart to data,  */
	void Reset(); /* Reset chart, */
	void MapRange(double fromValue, double toValue); /* Map histogram to fit range,*/
};

/* ================================ */

class BranchMod: /* Modulo ELA Application */
	public AutomationExtender
{
	public:
    	BranchModChannel Ch0;
    	BranchModChannel Ch1;
    	BranchModChannel Cmb;

	BranchMod(AutomationInterface *baseDevice,const char *prefix) :
		AutomationExtender(baseDevice,prefix),
		Ch0(this,"Ch0:"),
		Ch1(this,"Ch1:"),
		Cmb(this,"Cmb:")
    	{}
	virtual ~BranchMod() {}

};

/* ================================ */

class BranchRLenChannel: /* Channel Category */
	public AutomationExtender
{
	public:
	BranchRLenChannel(AutomationInterface *baseDevice,const char *prefix) :
		AutomationExtender(baseDevice,prefix) {}
	virtual ~BranchRLenChannel() {}

	char *getBinary(int *pcount=0); /* Histogram binary data, u32[] - Must free() return value */
	long long getBitPop(); /* Bit population */
	double getBottom(); /* Chart Bottom */
	void setBottom( double newValue);
	bool getCursAvail(int index); /* Chart Cursor Available */
	bool getCursEnabled(int index); /* Chart Cursor Enabled */
	void setCursEnabled(int index, bool newValue);
	char* getCursLabel(int index,char *buffer,int buflen); /* Chart Cursor Label */
	double getCursValue(int index); /* Chart Cursor Value */
	void setCursValue(int index, double newValue);
	bool getEnabled(); /* Enable processor */
	double getHeight(); /* Chart Height */
	void setHeight( double newValue);
	double getLeft(); /* Chart Left */
	void setLeft( double newValue);
	double getLimits(int index); /* Chart Limits (LRBT) */
	bool getLocked(); /* Chart Locked */
	void setLocked( bool newValue);
	bool getLogscale(); /* Chart LogScale */
	void setLogscale( bool newValue);

	enum class RunType
	{
		Space,
		Mark
	};
	static const char *RunType_Strings[];

	RunType getRunType();
	void setRunType( RunType newValue);

	enum class Scroll
	{
		None,
		X1,
		X2,
		X3,
		X4,
		DX12,
		DX34,
		XPan,
		XScale,
		Y1,
		Y2,
		Y3,
		Y4,
		DY12,
		DY34,
		YPan,
		YScale,
		P1,
		P2,
		P3
	};
	static const char *Scroll_Strings[];

	Scroll getScroll();
	void setScroll( Scroll newValue);
	bool getShowMemory(); /* Show memories */
	void setShowMemory( bool newValue);
	bool getShowOverlays(); /* Show overlays */
	void setShowOverlays( bool newValue);
	bool getShowSettings(); /* Show Settings */
	void setShowSettings( bool newValue);

	enum class Status
	{
		NotAvail,
		Disabled,
		Stopped,
		Running
	};
	static const char *Status_Strings[];

	Status getStatus();
	char* getTitle(char *buffer,int buflen); /* Chart Title */
	int getUsed(); /* Number Used */
	double getWidth(); /* Chart Width */
	void setWidth( double newValue);
	char* Csv(char *buffer,int buflen, const char *optFilename=NULL); /* Download CSV File */
	void Fit(); /* Fit chart to data, */
	void Reset(); /* Reset chart,  */
};

/* ================================ */

class BranchRLen: /* Data Run Length Application */
    public AutomationExtender
{
    public:
	BranchRLenChannel Ch0;
	BranchRLenChannel Ch1;
	BranchRLenChannel Cmb;

    BranchRLen(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix),
		Ch0(this,"Ch0:"),
		Ch1(this,"Ch1:"),
		Cmb(this,"Cmb:") {}
    virtual ~BranchRLen() {}
};

/* ================================ */

class BranchStat: /* Data application statistics Application */
    public AutomationExtender
{
    public:
    BranchStat(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchStat() {}

    long long getBits(int index); /* Bit Count Result */
    bool getEnabled(int index); /* Enable processor */
    double getMarkDensityPcnt(int index); /* Mark Density results */
    long long getMarks(int index); /* Marks Count Result */
    char* getReport(char *buffer,int buflen); /* Statistics report */

    enum class Status
    {
        NotAvail,
        Disabled,
        Stopped,
        Running
    };
    static const char *Status_Strings[];

    Status getStatus(int index);
};

/* ================================ */

class BranchWanderChannel: /* Channel Category */
	public AutomationExtender
{
	public:
	BranchWanderChannel(AutomationInterface *baseDevice,const char *prefix) :
		AutomationExtender(baseDevice,prefix) {}
	virtual ~BranchWanderChannel() {}

	char *getBinary(int *pcount=0); /* Histogram binary data, u32[] - Must free() return value */
	long long getBitPop(); /* Bit population */
	double getBottom(); /* Chart Bottom */
	void setBottom( double newValue);
	bool getCursAvail(int index); /* Chart Cursor Available */
	bool getCursEnabled(int index); /* Chart Cursor Enabled */
	void setCursEnabled(int index, bool newValue);
	char* getCursLabel(int index,char *buffer,int buflen); /* Chart Cursor Label */
	double getCursValue(int index); /* Chart Cursor Value */
	void setCursValue(int index, double newValue);
	bool getEnabled(); /* Enable processor */
	double getHeight(); /* Chart Height */
	void setHeight( double newValue);
	double getLargestPcnt(); /* Largest disparity */
	double getLeft(); /* Chart Left */
	void setLeft( double newValue);
	double getLimits(int index); /* Chart Limits (LRBT) */
	bool getLocked(); /* Chart Locked */
	void setLocked( bool newValue);
	bool getLogscale(); /* Chart LogScale */
	void setLogscale( bool newValue);

	enum class Mode
	{
		TwoLevel,
		FourLevel
	};
	static const char *Mode_Strings[];

	Mode getMode();
	void setMode( Mode newValue);

	enum class Order
	{
		MsbFirst,
		LsbFirst
	};
	static const char *Order_Strings[];

	Order getOrder();
	void setOrder( Order newValue);

	enum class Scroll
	{
		None,
		X1,
		X2,
		X3,
		X4,
		DX12,
		DX34,
		XPan,
		XScale,
		Y1,
		Y2,
		Y3,
		Y4,
		DY12,
		DY34,
		YPan,
		YScale,
		P1,
		P2,
		P3
	};
	static const char *Scroll_Strings[];

	Scroll getScroll();
	void setScroll( Scroll newValue);
	bool getShowMemory(); /* Show memories */
	void setShowMemory( bool newValue);
	bool getShowOverlays(); /* Show overlays */
	void setShowOverlays( bool newValue);
	bool getShowSettings(); /* Show Settings */
	void setShowSettings( bool newValue);
	double getSmallestPcnt(); /* Smallest disparity */

	enum class Status
	{
		NotAvail,
		Disabled,
		Stopped,
		Running
	};
	static const char *Status_Strings[];

	Status getStatus();
	char* getTitle(char *buffer,int buflen); /* Chart Title */
	double getWidth(); /* Chart Width */
	void setWidth( double newValue);
	int getWindowBits(); /* Bit window */
	void setWindowBits( int newValue);
	char* Csv(char *buffer,int buflen, const char *optFilename=NULL); /* Download CSV File */
	void Fit(); /* Fit chart to data, */
	void Reset(); /* Reset chart,  */
};

/* ================================ */

class BranchWander: /* Data Wander Application */
    public AutomationExtender
{
    public:
	BranchWanderChannel Ch0;
	BranchWanderChannel Ch1;
	BranchWanderChannel Cmb;

    BranchWander(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix),
		Ch0(this,"Ch0:"),
		Ch1(this,"Ch1:"),
		Cmb(this,"Cmb:") {}
    virtual ~BranchWander() {}
};

/* ================================ */

class BranchPelaEyeCfg: /* Configuration Settings */
    public AutomationExtender
{
    public:
    BranchPelaEyeCfg(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchPelaEyeCfg() {}

    double getBottom(); /* Acquisition Voltage bottom */
    double getBright(); /* Image Brightness */
    void setBright( double newValue);
    int getColumns(); /* Columns in Image */
    void setColumns( int newValue);
    int getDelaySettleUSec(); /* Delay Settle Time */
    void setDelaySettleUSec( int newValue);
    double getDepthBits(); /* E2 Depth */
    void setDepthBits( double newValue);
    int getDivisions(int index); /* Number of divisions H,V */
    void setDivisions(int index, int newValue);
    bool getEyeSync(); /* Eye Sync mode */
    double getFloorNoSync(); /* Floor threshold for No-Sync mode (500K) */
    void setFloorNoSync( double newValue);
    double getFloorSync(); /* Floor threshold for Sync mode (500K) */
    void setFloorSync( double newValue);
    double getHeight(); /* Acquisition Voltage height */
    double getOffset(); /* Acquisition Time offset */
    double getPerDiv(int index); /* Span per division */
    void setPerDiv(int index, double newValue);
    int getPersist(); /* Persistence */
    void setPersist( int newValue);
    int getRows(); /* Rows in Image */
    void setRows( int newValue);
    bool getShowRaw(); /* Show Raw Data */
    void setShowRaw( bool newValue);
    double getSpan(); /* Acquisition Time span */
    int getThreshSettleUSec(); /* Threshold Settle Time */
    void setThreshSettleUSec( int newValue);
    bool getUseClip(); /* Use Clipping for Floor level */
    void setUseClip( bool newValue);
};

/* ================================ */

class BranchPelaEyeChannel: /* Eye Channel */
    public AutomationExtender
{
    public:
    BranchPelaEyeChannel(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchPelaEyeChannel() {}

    char *getBinary(int *pcount=0); /* Binary Data, char[] - Must free() return value */
    double getScalePcnt(); /* Scale ratio percentage */
    void setScalePcnt( double newValue);
    bool getShow(); /* Show trace */
    void setShow( bool newValue);
    double getTimeOffsPS(); /* Time Offset */
    void setTimeOffsPS( double newValue);
    double getVoltOffsMV(); /* Volt Offset */
    void setVoltOffsMV( double newValue);
    char* Jpg(char *buffer,int buflen, const char *optFilename=NULL); /* PelaEye Jpg Image */
};

/* ================================ */

class BranchPelaEyeChart: /* Chart View */
    public AutomationExtender
{
    public:
    BranchPelaEyeChart(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix) {}
    virtual ~BranchPelaEyeChart() {}

    double getBottomMV(); /* Chart Bottom */
    void setBottomMV( double newValue);
    bool getCursAvail(int index); /* Chart Cursor Available */
    bool getCursEnabled(int index); /* Chart Cursor Enabled */
    void setCursEnabled(int index, bool newValue);
    char* getCursLabel(int index,char *buffer,int buflen); /* Chart Cursor Label */
    double getCursValue(int index); /* Chart Cursor Value */
    void setCursValue(int index, double newValue);
    double getHeightMV(); /* Chart Height */
    void setHeightMV( double newValue);
    double getLeftPS(); /* Chart Left */
    void setLeftPS( double newValue);
    double getLimits(int index); /* Chart Limits (LRBT) */
    bool getLocked(); /* Chart Locked */
    void setLocked( bool newValue);
    bool getLogscale(); /* Chart LogScale */
    void setLogscale( bool newValue);

    enum class Scroll
    {
        None,
        X1,
        X2,
        X3,
        X4,
        DX12,
        DX34,
        XPan,
        XScale,
        Y1,
        Y2,
        Y3,
        Y4,
        DY12,
        DY34,
        YPan,
        YScale,
        P1,
        P2,
        P3
    };
    static const char *Scroll_Strings[];

    Scroll getScroll();
    void setScroll( Scroll newValue);
    bool getShowMemory(); /* Show memories */
    void setShowMemory( bool newValue);
    bool getShowOverlays(); /* Show overlays */
    void setShowOverlays( bool newValue);
    char* getTitle(char *buffer,int buflen); /* Chart Title */
    double getWidthPS(); /* Chart Width */
    void setWidthPS( double newValue);
};

/* ================================ */

class BranchPelaEye: /* Pela Eye Application */
    public AutomationExtender
{
    public:
	BranchPelaEyeCfg Cfg;
	BranchPelaEyeChart Chart;
	BranchPelaEyeChannel Ch0;
	BranchPelaEyeChannel Ch1;

    BranchPelaEye(AutomationInterface *baseDevice,const char *prefix) :
        AutomationExtender(baseDevice,prefix),
		Cfg(this,"Cfg:"),
		Chart(this,"Chart:"),
		Ch0(this,"Ch0:"),
		Ch1(this,"Ch1") {}
    virtual ~BranchPelaEye() {}

    double getElapsedSeconds(); /* Elapsed Time Seconds */

    enum class Running
    {
        Stop,
        Run,
        RunOnce
    };
    static const char *Running_Strings[];

    Running getRunning();
    int getSequence(); /* Run Sequence */
    bool getShowSettings(); /* Show gui settings panel */
    void setShowSettings( bool newValue);
    void Fit(); /* Fit chart,  */
    void Reset(); /* Reset position,*/
};

/* ================================ */

#endif // AUTOGEN_PELA_H
