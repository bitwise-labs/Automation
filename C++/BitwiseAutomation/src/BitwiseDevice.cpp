/* BitwiseDevice.cpp */
//================================================================================
// BOOST SOFTWARE LICENSE
//
// Copyright 2020 BitWise Laboratories Inc.
// Author.......Jim Waschura
// Contact......info@bitwiselabs.com
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.
//================================================================================

#include <stdarg.h> /* va_list, va_start, va_end */
#include <stdio.h> /* vsnprintf,snprintf,fprintf */
#include <string.h> /* strcmp, strtok */
#include <unistd.h> /* usleep */
#include <stdlib.h> /* malloc, free */
#include <sys/stat.h> /* stat */
#include <utime.h> /* utimbuf */

#include "BitwiseDevice.h"

//================================================================================
//================================================================================

void BitwiseDevice::Connect( const char *ipaddress, int port )
{
	base::Connect(ipaddress,port);
}

//================================================================================
//================================================================================

int BitwiseDevice::unpackIntegerByKey(const char *str, const char *key )
{
	char buffer[1024];
	unpackValueByKey( buffer, 1024, str, key );
	int retn=0.0;
	if( sscanf(buffer,"%i",&retn) != 1)
		throw "[No_Integer_Found]";
	return retn;
}

double BitwiseDevice::unpackDoubleByKey(const char *str, const char *key )
{
	char buffer[1024];
	unpackValueByKey( buffer, 1024, str, key );
	double retn=0.0;
	if( sscanf(buffer,"%lf",&retn) != 1)
		throw "[No_Double_Found]";
	return retn;
}

char *BitwiseDevice::unpackValueByKey( char *buffer, int buflen, const char *str, const char *key )
{
	int keylen=0;
	if( key==0|| (keylen=strlen(key))<1 )
		throw("[Invalid_Key]");
	if( buffer==0||buflen<1 )
		throw "[Invalid_Buffer]";

	char *ptr = (char*)malloc( strlen(str)+1 ); /* buffer because strtok changes contents */
	bool found=false;

	try
	{
		memcpy( ptr, str, strlen(str)+1 );
		char *tok = strtok(ptr,"\n");

		while( tok && !found )
		{
			if(!strncmp(tok,key,keylen) && (int)strlen(tok)>keylen &&
				(tok[keylen]==' '||tok[keylen]=='\t'||tok[keylen]=='='||tok[keylen]==',' ) )
			{
				snprintf(buffer,buflen,"%s",tok+keylen+1);
				found=true;
			}
			tok = strtok(0,"\n");
		}
		free(ptr);
	}
	catch(...)
	{
		free(ptr);
		throw;
	}

	if( !found )
		throw "[Key_Not_Found]";

	return buffer;
}

//================================================================================
//================================================================================

/* add error-checking to SendCommand */
void BitwiseDevice::SendCommand( const char *command, ... )
{
	char outBuffer[4096+4] = "stc;";
	va_list argptr;
	va_start(argptr,command);

	vsnprintf(outBuffer+4,4096,command,argptr);
	va_end(argptr);

#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"BitwiseDevice::SendCommand(), command: %s", outBuffer );
#endif

	base::SendCommand(outBuffer);

	char inBuffer[4096];
	base::QueryResponse(inBuffer,4096,(char*)"st?\n");

#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"BitwiseDevice::SendCommand(), Status Response is: [%s]\n", inBuffer );
#endif

	if( strcasecmp(inBuffer,"[none]") )
	{
		static char static_throw_buffer[4096];
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wformat-overflow"
#pragma GCC diagnostic ignored "-Wformat-truncation"
		snprintf(static_throw_buffer,4096,"[%s]",inBuffer);
#pragma GCC diagnostic pop

		throw (const char*)static_throw_buffer;
	}
}

/* add error-checking to QueryResponse */

char * BitwiseDevice::QueryResponse( char *buffer, int buflen, const char *command, ... )
{
	char outBuffer[4096+4] = "stc;";
	va_list argptr;
	va_start(argptr,command);

	vsnprintf(outBuffer+4,4096,command,argptr);
	va_end(argptr);


#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"BitwiseDevice::QueryResponse(), command: %s", outBuffer );
#endif

	base::QueryResponse(buffer,buflen,outBuffer);

#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"BitwiseDevice::QueryResponse(), Response is: [%s]\n", buffer );
#endif

	char inBuffer[4096];
	base::QueryResponse(inBuffer,4096,(char*)"st?\n");

#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"BitwiseDevice::QueryResponse(), Status Response is: [%s]\n", inBuffer );
#endif

	if( strcasecmp(inBuffer,"[none]") )
	{
		static char static_throw_buffer[4096];
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wformat-overflow"
#pragma GCC diagnostic ignored "-Wformat-truncation"
		snprintf(static_throw_buffer,4096,"[%s]",inBuffer);
#pragma GCC diagnostic pop
		throw (const char*)static_throw_buffer;
	}

#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"BitwiseDevice::QueryResponse(), Returning: [%s]\n", buffer );
#endif

	return buffer;
}

//================================================================================
//================================================================================

/* specifying configurations: */
/* "[recent]"  ...  most recent settings */
/* "[factory]"  ... factory settings */
/* "[startup]"  ... settings from selectable startup configuration file */
/* full-path-name ... settings from fully-specified configuration file path  */
/* filename-only ... settings from file located in configuration folder */

void BitwiseDevice::SaveConfiguration( const char *configuration )
{
	base::SendCommand( "save \"%s\"\n", configuration );
}

void BitwiseDevice::RestoreConfiguration( const char *configuration, bool waitToComplete )
{
	App.Stop(); // just to make sure

	base::SendCommand( "stc; restore \"%s\"\n", configuration );/* use base: to avoid error checking */

	if( waitToComplete )
		WaitForRestoreToComplete();
}

void BitwiseDevice::WaitForRestoreToComplete()
{
	double now = timestamp();
	double timeout = now + 30.0;
#ifdef DEBUG
	double begin_time=now;
#endif

	while( now < timeout )
	{
		usleep(500*1000);
		now = timestamp();

#ifdef DEBUG
		if( getDebugging() )
			fprintf(stderr,"Restoring configuration %.1lf\n",now-begin_time);
#endif

		char buffer[4096];
		base::QueryResponse(buffer,4096,"inprogress\n"); /* use base: to avoid error checking */
		if( buffer[0]=='F'||buffer[0]=='0' )
			break;
	}

	if( now >= timeout )
		throw "[Timeout_Restoring_Configuration]";

#ifdef DEBUG
	if( getDebugging() )
		fprintf(stderr,"Restoring configuration complete %.1lf\n",timestamp()-begin_time);
#endif

	base::SendCommand( "stc\n");/* use base: to avoid error checking */
}

//================================================================================
//================================================================================

bool BitwiseDevice::getIsRunning()
{
	char buffer[4096];
	if( App.getRunState(buffer,4096)==NULL )
		throw "[Unable_To_Retrieve_Run_State]" ;

	char *ptr = strtok( buffer, "{}," );
	bool onState = false;
	while ( ptr!= NULL && !onState )
	{
		onState = onState || (strncasecmp(ptr, "Stop", 4) != 0);
		ptr = strtok(NULL,"{},");
	}

	return onState ;
}

void BitwiseDevice::Run( double waitUntilRunningTimeout )
{
	App.Run();

	if( waitUntilRunningTimeout>0 )
	{
		double now = timestamp();
		double timeout = now + waitUntilRunningTimeout;

		while( now<timeout && !getIsRunning() )
		{
			usleep( 10*1000 );
			now=timestamp();
		}

		if( now>=timeout )
			throw "[Run_Timeout]";
	}
}

void BitwiseDevice::RunSingle( double waitUntilRunningTimeout )
{
	App.Run(true);

	if( waitUntilRunningTimeout>0 )
	{
		double now = timestamp();
		double timeout = now + waitUntilRunningTimeout;

		while( now<timeout && !getIsRunning() )
		{
			usleep( 10*1000 );
			now=timestamp();
		}

		if( now>=timeout )
			throw "[Run_Once_Timeout]";
	}
}

void BitwiseDevice::WaitForRunToStart( double timeoutSec )
{
	double now = SocketDevice::timestamp();
	double timeout = now + timeoutSec;

	while( now<timeout && !getIsRunning() )
	{
		usleep( 200*1000 ); /* poll 5 times per second */
		now=SocketDevice::timestamp();
	}

	Stop();
	if( now>=timeout )
		throw "[Wait_Run_Start_Timeout]";
}

void BitwiseDevice::WaitForRunToComplete( double timeoutSec )
{
	double now = SocketDevice::timestamp();
	double timeout = now + timeoutSec;

	while( now<timeout && getIsRunning() )
	{
		usleep( 200*1000 ); /* poll 5 times per second */
		now=SocketDevice::timestamp();
	}

	Stop();
	if( now>=timeout )
		throw "[Wait_Run_Complete_Timeout]";
}

void BitwiseDevice::Stop()
{
	App.Stop();
}

void BitwiseDevice::Clear()
{
	App.Clear();
}

//================================================================================
//================================================================================

void BitwiseDevice::fileXferBuffer(
		char *buffer_bytes,
		int byte_count,
		const char *prefix ) /* use prefix "Same" for retry */
{
	if( buffer_bytes==NULL || byte_count<1 )
		throw "[XferBuffer_Is_Empty]";

	uint32_t cksum=0;
	for( int n=0; n<byte_count; n++ )
		cksum += (uint8_t) buffer_bytes[n];

	SendCommand( "stc; File:Xfer:%sBuffer %u 0x%x\n", prefix, byte_count, cksum );
	Send( buffer_bytes, byte_count );
}

void BitwiseDevice::SendFileAs( char *localFilePath, char *destinationFilePath )
{
	struct stat statbuf;

	if( localFilePath==NULL || localFilePath[0]==0 )
		throw "[Local_Filename_Is_Missing]";

	if( destinationFilePath==NULL || destinationFilePath[0]==0 )
		throw "[Destination_Filename_Is_Missing]";

	if(stat(localFilePath, &statbuf)!=0 )
		throw "[Send_Unable_To_Stat_File]";

	FILE *f = fopen(localFilePath,"rb");
	if( f==NULL )
		throw "[Send_Unable_To_Open_File]";

	try
	{
		char timebuffer[128];
		strftime( timebuffer, 128, "%Y/%m/%d %H:%M:%S", localtime( &statbuf.st_mtime ));
		SendCommand("File:Xfer:Put \"%s\" %s\n", destinationFilePath, timebuffer );

		char buffer[4096];
		char response_buffer[1024];
		char *status;

		unsigned int count = fread(buffer,1,4096,f);
		while( count>0 )
		{
			fileXferBuffer( buffer, count );
			status = base::QueryResponse(response_buffer,1024,"st?\n");

			unsigned int retry=0;
			while( retry<3 && !strcasecmp(status,"[Checksum_Error]"))
			{
				fileXferBuffer( buffer, count, "Same" );
				status = base::QueryResponse(response_buffer,1024,"st?\n");
				retry++ ;
			}

			if( strcasecmp(status,"[none]") )
				throw "[File_Send_Failed]";

			count = fread(buffer,1,4096,f);
		}

		SendCommand("File:Xfer:DonePut\n");

		fclose(f);
	}
	catch(...)
	{
		if(f!=NULL )
			fclose(f);

		SendCommand("File:Xfer:DonePut\n");
		base::SendCommand("File:Del \"%s\"\n",destinationFilePath);

		throw;
	}

}

void BitwiseDevice::ReceiveFileAs( char *sourceFilePath, char *localFilePath )
{
	/* Todo: Is code-complete, needs testing */

	if( sourceFilePath==NULL || sourceFilePath[0]==0 )
		throw "[Source_Filename_Is_Missing]";

	if( localFilePath==NULL || localFilePath[0]==0 )
		throw "[Local_Filename_Is_Missing]";

	char xfer[8192];
	char *buffer;
	int n;

	/* returns with long string containing fields separated by space: */
	/*   "filename" .. including double quotes */
	/*   byte count */
	/*   year/month/day .. including forward slashes, year is 4 digits */
	/*   HH:MM:SS .. including colons */

	buffer = base::QueryResponse(
				xfer,
				8192,
				"File:Xfer:Get \"%s\"\n", sourceFilePath
				);

    for( n=1; buffer[n]!=0 && buffer[n]!='"' && n<8192 ; n++)
       ;

	if( buffer[0]!='"' || buffer[n]!='"' )
		throw "[Invalid_Response_From_Get_Command]";

	unsigned int length, year, month, day, hour, minute, second;

	if( sscanf( buffer+n+1,"%u %u/%u/%u %u:%u:%u",
		&length, &year, &month, &day, &hour, &minute, &second ) != 7 )
		throw "[Invalid_Response_Length_Date_Time]" ;

	FILE *f = fopen(localFilePath,"wb");
	if( f==NULL )
		throw "[Unable_To_Create_Local_File]";

	try
	{
		struct
		{
			uint32_t magic; // 0x12345678
			uint32_t bytes;
			uint32_t sum;
		} response ;

        unsigned int totalTransferred=0;
        unsigned int blen;

        while( totalTransferred<length )
        {
        	base::SendCommand( "File:Xfer:Next\n" );
        	blen = base::Receive( (char*) &response, sizeof(response) );

        	if( blen!=sizeof(response) )
        		throw "[No_Response_From_Next_Command]" ;

        	if( response.magic != 0x12345678 )
        		throw "[Response_From_Next_Command_Is_Invalid]";

        	if( response.bytes==0 )
        		break;

        	unsigned int cnt=0;

        	if( response.bytes>8192 )
        		throw"[Individual_Transfer_Is_Too_Big]";

        	cnt=0;
        	while( cnt<response.bytes )
        	{
        		blen = base::Receive( xfer+cnt, response.bytes-cnt );
        		if( blen==0 )
        			throw "[Binary_Xfer_Unsuccessful]";
        		cnt += blen;
        	}

        	uint32_t sum=0;

        	for( uint32_t i=0; i<response.bytes; i++ )
        		sum += (uint8_t) xfer[i];

        	int retry=3;
        	while( sum != response.sum && retry>0 )
        	{
            	base::SendCommand( "File:Xfer:Resend\n" );
            	blen = base::Receive( (char*) &response, sizeof(response) );

            	if( blen!=sizeof(response) )
            		throw "[No_Response_From_Resend_Command]" ;

            	if( response.magic != 0x12345678 )
            		throw "[Response_From_Next_Command_Is_Invalid]";

            	if( response.bytes>8192 )
            		throw"[Individual_Transfer_Is_Too_Big]";

            	cnt=0;
            	while( cnt<response.bytes )
            	{
            		blen = base::Receive( xfer+cnt, response.bytes-cnt );
            		if( blen==0 )
            			throw "[Binary_Retry_Unsuccessful]";
            		cnt += blen;
            	}

            	uint32_t sum=0;

            	for( uint32_t i=0; i<response.bytes; i++ )
            		sum += (uint8_t) xfer[i];

            	retry--;
        	}

        	if( retry==0 )
        		throw "[Binary_Xfer_Retries_Failed]";

        	if( fwrite(xfer,1,response.bytes,f) != response.bytes )
        		throw "[Failed_Writing_To_New_File]";

        	totalTransferred += response.bytes;
        }

        SendCommand("File:Xfer:DoneGet\n");

        fclose(f);
        f=NULL;

    	/* set resulting file to have appropriate date and time */

    	struct stat statbuf;

    	if( stat(localFilePath,&statbuf)!=0 )
    		throw"[Unable_To_Stat_Destination_File]";

    	struct tm * timeinfo;
    	timeinfo = localtime( &statbuf.st_mtime );
    	timeinfo->tm_year = year - 1900;
    	timeinfo->tm_mon = month - 1;
    	timeinfo->tm_mday = day;
    	timeinfo->tm_hour = hour;
    	timeinfo->tm_min = minute;
    	timeinfo->tm_sec = second;

    	struct utimbuf new_times;

    	new_times.actime = mktime( timeinfo );
    	new_times.modtime = mktime( timeinfo );

    	if( utime( localFilePath, &new_times ) < 0 )
    		throw "[Unable_To_Set_Destination_File_Date_Time]";
	}
	catch(...)
	{
		if(f!=NULL)
			fclose(f);
		unlink(localFilePath);
		throw;
	}
}
// EOF

