/* AutomationExtender.cpp */
//================================================================================
// BOOST SOFTWARE LICENSE
//
// Copyright 2020 BitWise Laboratories Inc.
// Author.......Jim Waschura
// Contact......info@bitwiselabs.com
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.
//================================================================================

#include <stdarg.h> /* va_list, va_start, va_end */
#include <stdio.h> /* vsnprintf,snprintf,fprintf */
#include <string.h> /* strcmp, strtok */
#include <unistd.h> /* usleep */

#include "AutomationExtender.h"

//================================================================================
//================================================================================

void AutomationExtender::setDebugging(bool newValue)
{
	m_Debugging=newValue;
}

bool AutomationExtender::getDebugging()
{
	return m_Debugging || getExtender()->getDebugging();
}

void AutomationExtender::SendCommand( const char *command, ... )
{
	char Buf[4096];
	strncpy(Buf,getPrefix(),4096-1);

	va_list argptr;
	va_start(argptr,command);

	vsnprintf(Buf+getPrefixLength(),4096-getPrefixLength(),command,argptr);
	va_end(argptr);

	getExtender()->SendCommand("%s",Buf);
}

char * AutomationExtender::QueryResponse( char *buffer, int buflen, const char *command, ... )
{
	char Buf[4096];
	strncpy(Buf,getPrefix(),4096-1);

	va_list argptr;
	va_start(argptr,command);

	vsnprintf(Buf+getPrefixLength(),4096-getPrefixLength(),command,argptr);
	va_end(argptr);

	return getExtender()->QueryResponse(buffer,buflen,"%s",Buf);
}

void AutomationExtender::SendBinaryCommand( const char *buffer, int count, const char *command, ... )
{
	char Buf[4096];
	strncpy(Buf,getPrefix(),4096-1);

	va_list argptr;
	va_start(argptr,command);

	vsnprintf(Buf+getPrefixLength(),4096-getPrefixLength(),command,argptr);
	va_end(argptr);

	getExtender()->SendBinaryCommand(buffer,count,"%s",Buf);
}

char *AutomationExtender::QueryBinaryResponse( int *pcount, const char *command, ... ) /* caller responsible for free(return_value) */
{
	char Buf[4096];
	strncpy(Buf,getPrefix(),4096-1);

	va_list argptr;
	va_start(argptr,command);

	vsnprintf(Buf+getPrefixLength(),4096-getPrefixLength(),command,argptr);
	va_end(argptr);

	return getExtender()->QueryBinaryResponse(pcount,"%s",Buf);
}

int AutomationExtender::QueryResponse_int( const char *command, ... )
{
	char Buf[4096];
	strncpy(Buf,getPrefix(),4096-1);

	va_list argptr;
	va_start(argptr,command);

	vsnprintf(Buf+getPrefixLength(),4096-getPrefixLength(),command,argptr);
	va_end(argptr);

	return getExtender()->QueryResponse_int("%s",Buf);
}

long long AutomationExtender::QueryResponse_int64( const char *command, ... )
{
	char Buf[4096];
	strncpy(Buf,getPrefix(),4096-1);

	va_list argptr;
	va_start(argptr,command);

	vsnprintf(Buf+getPrefixLength(),4096-getPrefixLength(),command,argptr);
	va_end(argptr);

	return getExtender()->QueryResponse_int64("%s",Buf);
}

bool AutomationExtender::QueryResponse_bool( const char *command, ... )
{
	char Buf[4096];
	strncpy(Buf,getPrefix(),4096-1);

	va_list argptr;
	va_start(argptr,command);

	vsnprintf(Buf+getPrefixLength(),4096-getPrefixLength(),command,argptr);
	va_end(argptr);

	return getExtender()->QueryResponse_bool("%s",Buf);

return false;
}

double AutomationExtender::QueryResponse_double( const char *command, ... )
{
	char Buf[4096];
	strncpy(Buf,getPrefix(),4096-1);

	va_list argptr;
	va_start(argptr,command);

	vsnprintf(Buf+getPrefixLength(),4096-getPrefixLength(),command,argptr);
	va_end(argptr);

	return getExtender()->QueryResponse_double("%s",Buf);
}

int AutomationExtender::QueryResponse_enum( const char *enum_strings_null_terminated[], const char *command, ... )
{
	char Buf[4096];
	strncpy(Buf,getPrefix(),4096-1);

	va_list argptr;
	va_start(argptr,command);

	vsnprintf(Buf+getPrefixLength(),4096-getPrefixLength(),command,argptr);
	va_end(argptr);

	return getExtender()->QueryResponse_enum(enum_strings_null_terminated, "%s",Buf);
}

