/* SocketDevice.cpp */
//================================================================================
// BOOST SOFTWARE LICENSE
//
// Copyright 2020 BitWise Laboratories Inc.
// Author.......Jim Waschura
// Contact......info@bitwiselabs.com
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.
//================================================================================

#include <stdarg.h> /* va_list, va_start, va_end */
#include <stdio.h> /* vsnprintf */
#include <string.h> /* strlen */
#include <stdlib.h> /* malloc */
#include <sys/time.h> /* gettimeofday */
#include <netdb.h> /* gethostbyname() */
#include <unistd.h> /* close, sleep */

/* future: for multi-threading, need mutex around socket access.  Also set FD_CLOEXEC */
/* to prevent fork() from duplicating open sockets. Could implement asynchronous access */
/* with timeouts, but should not be necessary for automation clients, as oppowed to servers. */

#ifdef WIN32
 #include <winsock2.h>
 #include <ws2tcpip.h>
#else
 #include <arpa/inet.h>   /* IP addresses manipulation utilities */
 #include <netinet/in.h>  /* sockaddr_in structure definition */
 #include <sys/socket.h>  /* berkley socket library */
#endif

#include "SocketDevice.h"

#ifdef WIN32
	#pragma comment(lib,  "ws2_32.lib")

	static bool wsa_initialized=false;
	static void print_wsa_error(char *prefix, int num )
	{
		wchar_t *s = NULL;

		FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL, WSAGetLastError(),
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
			(LPWSTR)&s, 0, NULL);
		fprintf( stderr,"%s%S\n", prefix, s);
		LocalFree(s);
	}
#endif

	/* strip trailing \n and/or \r, and remove */
	/* surrounding double-quotes if present */

	static char * cleanString(char *string)
	{
		char *src = string;
		char *dst = string;

		for(  ;*src; src++ )
		{
			bool isLast = *(src+1)==0 || *(src+1)=='\r' || *(src+1)=='\n';
			bool isFirst = src==string;

			if( *src == '\n' ) ;
			else if( *src == '\r' ) ;
			else if( isFirst && *src == '"' ) ;
			else if( isLast && *src == '"' ) ;
			else if( dst == src ) dst++;
			else { *(dst++) = *src ; }
		}
		*dst = 0;

		return string;
	}

SocketDevice::~SocketDevice()
{
	if(getIsConnected() )
		Disconnect();
}

/* static */
double SocketDevice::timestamp()
{
	static double begin=0;
	timeval tv;
	gettimeofday(&tv,NULL);
	double retn = (double)tv.tv_sec + 1e-6 * (double)tv.tv_usec;
	if( begin==0 ) begin = retn;
	return retn-begin;
}

//================================================================================
//================================================================================

/* can specify port with address using colon, such as '192.168.1.121:923'   */

void SocketDevice::Connect( const char *ipaddress, int dflt_port )
{
#ifdef DEBUG
	if( getDebugging() )
		fprintf(stderr,"SocketDevice::Connect(), ipaddress=\"%s\", dflt_port=%d\n", ipaddress,dflt_port );
#endif


#ifdef WIN32
	if( !wsa_initialized )
	{
		wsa_initialized=true;
		WSADATA wsaData = {0};

		int status = WSAStartup(MAKEWORD(2, 2),&wsaData);
		if( status !=0 )
		{
			fprintf(stderr,"SocketDevice::SocketDevice() WSAStartup failed: %d\n", status );
			throw "[WSA_Init_Failed]";
		}
	}
#endif

	if(getSock()>=0)
		Disconnect();

	char tempBuffer[4096];
	int tempPort = dflt_port;
	strncpy(tempBuffer,ipaddress,4096-1);

	char *colonFound = strchr(tempBuffer,':');
	if( colonFound!=0 )
	{
		if( strlen(colonFound+1)>0 && sscanf(colonFound+1,"%d",&tempPort )!=1 )
			throw "[Unrecognized_Port_Specification]";

		*colonFound=0;
	}

	struct hostent * hostPtr =
		gethostbyname(tempBuffer);

	if( hostPtr == 0)
		throw "[Invalid_IP_Address]";

	// the first address in the list of host addresses

	struct in_addr * addr_ptr =
		(struct in_addr * ) * hostPtr -> h_addr_list;

		// changed the address format to the
		// Internet address in standard dot notation

	char *add = inet_ntoa( * addr_ptr);
	if ( add==0 || *add == 0)
		throw "[IP_Address_Format_Error]";

#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"SocketDevice::Connect(), final_port=%d\n", tempPort );
#endif

	struct sockaddr_in sockAddr;
	sockAddr.sin_family = AF_INET;
	sockAddr.sin_port = htons(tempPort);
	sockAddr.sin_addr.s_addr = inet_addr(add);

	m_Sock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
	if( m_Sock == -1 )
		throw "[Create_Socket_Failed]";

	int status = connect(
		getSock(),
		(struct sockaddr *)&sockAddr,
		sizeof(struct sockaddr)
		);

	if( status == -1 )
	{
		close(getSock());
		m_Sock = -1;
		throw "[Unable_To_Connect]";
	}

	m_IsConnected = true;
}

void SocketDevice::Disconnect()
{
#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"SocketDevice::Disconnect()\n" );
#endif


	if(getSock()>=0)
	{
		int err = 1;
		socklen_t len = sizeof err;
		getsockopt(getSock(), SOL_SOCKET, SO_ERROR, (char *)&err, &len);

		struct linger l;
		l.l_onoff = 1;
		l.l_linger = 1;
		setsockopt(getSock(), SOL_SOCKET, SO_LINGER, &l, sizeof(l));

		shutdown(getSock(),SHUT_RDWR);
		close(getSock());

		m_Sock = -1;
		m_IsConnected = false;

		//pause to ensure server completely closes connection

		sleep(2);
	}
}

//================================================================================
//================================================================================

int SocketDevice::Send( const char *ptr, int count )
{
#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"SocketDevice::Send(), count=%d\n", count );
#endif

	if(getSock()<0)
		throw "[Invalid_Socket]";

	if(count<1)
		throw "[Invalid_Count]";

	return send(getSock(),ptr,count,0);
}

int SocketDevice::Receive( char *buffer, int buflen )
{
#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"SocketDevice::Receive(), buflen=%d\n", buflen );
#endif

	if(getSock()<0)
		throw "[Invalid_Socket]";

	if(buflen<1)
		throw "[Invalid_Buffer_Length]";

	if( buffer==0 )
		throw "[Invalid_Buffer]";

	buffer[0]=0;
	int retn = recv( getSock(), buffer, buflen, 0 );

	if( retn == -1 )
		throw "[Socket_Receive_Error]";

	if( retn == 0 )
		throw "[Socket_Zero_Bytes_Received]";

	return retn;
}

//================================================================================
//================================================================================
 /* '\n' terminated */
void SocketDevice::SendCommand( const char *command, ... )
{
	if(getSock()<0)
		throw "[Invalid_Socket]";

	if( !getIsConnected() )
		throw "[Not_Connected]";

	char Buf[4096];
	va_list argptr;
	va_start(argptr,command);

	vsnprintf(Buf,4096,command,argptr);
	va_end(argptr);

	if( strlen(Buf)==0 )
		throw "[Sending_Empty_Command]";

#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"SocketDevice::SendCommand(), command=%s", Buf );
#endif

	int status = Send(Buf,strlen(Buf));
	if( status != (int)strlen(Buf))
		throw "[Socket_Send_Error]";
}

/* '\n' terminated. For properties, has '?' before '\n'.  */
char * SocketDevice::QueryResponse( char *buffer, int buflen, const char *command, ... )
{

	if(getSock()<0)
		throw "[Invalid_Socket]";

	if( !getIsConnected() )
		throw "[Not_Connected]";

	if( buflen<=0 )
		throw "[Invalid_Buffer_Length]";

	if( buffer==0 )
		throw "[Invalid_Buffer]";

	buffer[0]=0;

	char Buf[4096];
	va_list argptr;
	va_start(argptr,command);

	vsnprintf(Buf,4096,command,argptr);
	va_end(argptr);

	if( strlen(Buf)==0 )
		throw "[Sending_Empty_Query]";

#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"SocketDevice::QueryResponse(), buflen=%d, command=%s", buflen, Buf );
#endif

	int status=Send( Buf, strlen(Buf) );

	if( status != (int)strlen(Buf) )
		throw "[Socket_Send_Error]";

	buffer[0]=0;
	int rxd = recv( getSock(), buffer, buflen, 0 );

	if( rxd < 0 )
		throw "[Socket_Receive_Error]";

	if( rxd == 0 )
		throw "[Socket_Zero_Bytes_Received]";

	if( rxd<buflen ) /* null-terminate if room */
		buffer[rxd] = 0;

#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"SocketDevice::QueryResponse(), raw=%s", buffer );
#endif

	char *cleaned = cleanString(buffer); /* strip trailing '\n' and double-quotes */

#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"SocketDevice::QueryResponse(), received=%s\n", cleaned );
#endif

	return cleaned;
}

int SocketDevice::QueryResponse_int( const char *command, ... )
{
	char outBuffer[4096];
	char inBuffer[4096];
	va_list argptr;
	va_start(argptr,command);

	vsnprintf(outBuffer,4096,command,argptr);
	va_end(argptr);

#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"SocketDevice::QueryResponse_int(), command=%s", outBuffer );
#endif

	QueryResponse(inBuffer,4096,outBuffer);

	int number;
	if( sscanf(inBuffer,"%i",&number ) != 1 )
		throw "[Invalid_Integer_Response]";

	return number;
}

long long SocketDevice::QueryResponse_int64( const char *command, ... )
{
	char outBuffer[4096];
	char inBuffer[4096];
	va_list argptr;
	va_start(argptr,command);

	vsnprintf(outBuffer,4096,command,argptr);
	va_end(argptr);

#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"SocketDevice::QueryResponse_int64(), command=%s", outBuffer );
#endif

	QueryResponse(inBuffer,4096,outBuffer);

	long long int number;
	if( sscanf(inBuffer,"%lli",&number ) != 1 )
		throw "[Invalid_Integer_Response]";

	return number;
}


bool SocketDevice::QueryResponse_bool( const char *command, ... )
{
	char outBuffer[4096];
	char inBuffer[4096];
	va_list argptr;
	va_start(argptr,command);

	vsnprintf(outBuffer,4096,command,argptr);
	va_end(argptr);

#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"SocketDevice::QueryResponse_bool(), command=%s", outBuffer );
#endif

	QueryResponse(inBuffer,4096,outBuffer);

	return inBuffer[0]=='1' || inBuffer[0]=='t' || inBuffer[0]=='T' ;
}

double SocketDevice::QueryResponse_double( const char *command, ... )
{
	char outBuffer[4096];
	char inBuffer[4096];
	va_list argptr;
	va_start(argptr,command);

	vsnprintf(outBuffer,4096,command,argptr);
	va_end(argptr);

#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"SocketDevice::QueryResponse_double(), command=%s", outBuffer );
#endif

	QueryResponse(inBuffer,4096,outBuffer);

	double number;
	if( sscanf(inBuffer,"%lf",&number ) != 1 )
		throw "[Invalid_Double_Response]";

	return number;
}

int SocketDevice::QueryResponse_enum( const char *enum_strings_null_terminated[], const char *command, ... )
{
	char outBuffer[4096];
	char inBuffer[4096];
	va_list argptr;
	va_start(argptr,command);

	if( enum_strings_null_terminated==0 )
		throw "[Invalid_Enum_List]";

	vsnprintf(outBuffer,4096,command,argptr);
	va_end(argptr);

#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"SocketDevice::QueryResponse_enum(), command=%s", outBuffer );
#endif

	QueryResponse(inBuffer,4096,outBuffer);

	int index=0;
	for( ;enum_strings_null_terminated[index]!=0 ; index++)
		if( !strcmp( inBuffer, enum_strings_null_terminated[index] ) )
			break;

	if( enum_strings_null_terminated[index]==0 )
		throw "[Unrecognized_Enum]";

	return index;
}

//================================================================================
//================================================================================

void SocketDevice::SendBinaryCommand( const char *buffer, int count, const char *command, ... )
{
	if(getSock()<0)
		throw "[Invalid_Socket]";

	if( !getIsConnected() )
		throw "[Not_Connected]";

	if( count<=0 )
		throw "[Invalid_Count]";

	if( buffer==0 )
		throw "[Invalid_Buffer]";

	char outBuffer[4096];
	va_list argptr;
	va_start(argptr,command);

	vsnprintf(outBuffer,4096,command,argptr);
	va_end(argptr);

#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"SocketDevice::SendBinaryCommand(), command=%s", outBuffer );
#endif

	if( strlen(outBuffer)==0 )
		throw "[Sending_Empty_Command]";

	int status;
	status = Send(outBuffer,strlen(outBuffer));
	if( status != (int)strlen(outBuffer) )
		throw "[Error_Sending_Command]";

	/* okay for 4-byte little-endian architectures */
	if( sizeof(int)!=4 )
		throw "[Requires_4_Byte_Int]";

	status = send(getSock(),(char*)&count,4,0);
	if( status != 4 )
		throw "[Error_Sending_Count]";

	status = send(getSock(),buffer,count,0);
	if( status != count )
		throw "[Error_Sending_Buffer]";
}

char *SocketDevice::QueryBinaryResponse( int *pcount, const char *command, ... ) /* caller responsible for free(return_value) */
{
	if(getSock()<0)
		throw "[Invalid_Socket]";

	if( !getIsConnected() )
		throw "[Not_Connected]";

	char outBuffer[4096];
	va_list argptr;
	va_start(argptr,command);

	vsnprintf(outBuffer,4096,command,argptr);
	va_end(argptr);

#ifdef DEBUG
	if(getDebugging())
		fprintf(stderr,"SocketDevice::QueryBinaryResponse(), command=%s", outBuffer );
#endif

	if( strlen(outBuffer)==0 )
		throw "[Sending_Empty_Command]";

	int status;
	status = Send( outBuffer, strlen(outBuffer) );
	if( status != (int)strlen(outBuffer) )
		throw "[Error_Sending_Command]";

	int count=0;
	/* okay for 4-byte little-endian architectures */
	if( sizeof(int)!=4 )
		throw "[Requires_4_Byte_Int]";

	status = recv( getSock(), (char*)&count,4, 0 );
	if( status!=4 )
		throw "[Error_Receiving_Count]";

	if(pcount)
		*pcount = count;

	char *retn = (char*) malloc( count+1 );
	retn[count]=0 ;

	if( count>0 )
	{
		try
		{
			int total=0;
			while(total<count)
			{
				int xfer = recv( getSock(), retn+total,count-total,0);
				if( xfer<=0 )
					throw "[Received_Zero_Byte_Buffer]";

				if( xfer<0 )
					throw "[Error_Receiving_Buffer]";

				total += xfer;
				usleep(1); /* ensure scheduler task-switch */
			}
		}
		catch(...)
		{
			free(retn);
			throw;
		}
	}

	return retn;
}

//================================================================================
//================================================================================
