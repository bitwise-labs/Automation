/* autogenCommon.cpp */
//================================================================================
// BOOST SOFTWARE LICENSE
//
// Copyright 2020 BitWise Laboratories Inc.
// Author.......Jim Waschura
// Contact......info@bitwiselabs.com
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.
//================================================================================

#include <stdio.h> /* fprintf, stderr */

#include "autogenCommon.h"

/* ================================================================ */

char* BranchApp::getList(char *buffer,int buflen) /* List of all applications */
{
    return QueryResponse(buffer,buflen,"List?\n");
}

char* BranchApp::getRunActive(char *buffer,int buflen) /* List of active run objects */
{
    return QueryResponse(buffer,buflen,"RunActive?\n");
}

char* BranchApp::getRunDurLimit(char *buffer,int buflen) /* Run Duration Limit */
{
    return QueryResponse(buffer,buflen,"RunDurLimit?\n");
}

void BranchApp::setRunDurLimit(const char* newValue) /* Run Duration Limit */
{
    SendCommand("RunDurLimit \"%s\"\n",newValue);
}

char* BranchApp::getRunList(char *buffer,int buflen) /* List of all run objects */
{
    return QueryResponse(buffer,buflen,"RunList?\n");
}

char* BranchApp::getRunState(char *buffer,int buflen) /* List of all run object states */
{
    return QueryResponse(buffer,buflen,"RunState?\n");
}

int BranchApp::getSequence() /* Gui Sequence */
{
    return QueryResponse_int("Sequence?\n");
}

bool BranchApp::getShowNav() /* Show Navigation Toolbar */
{
    return QueryResponse_bool("ShowNav?\n");
}

void BranchApp::setShowNav(bool newValue) /* Show Navigation Toolbar */
{
    SendCommand("ShowNav %c\n",newValue?'T':'F');
}

bool BranchApp::getShowText() /* Show Text on GUI */
{
    return QueryResponse_bool("ShowText?\n");
}

void BranchApp::setShowText(bool newValue) /* Show Text on GUI */
{
    SendCommand("ShowText %c\n",newValue?'T':'F');
}

char* BranchApp::getTab(char *buffer,int buflen) /* Application Tab */
{
    return QueryResponse(buffer,buflen,"Tab?\n");
}

void BranchApp::setTab(const char* newValue) /* Application Tab */
{
    SendCommand("Tab \"%s\"\n",newValue);
}

void BranchApp::Clear() /* Clear [<active-appname-list-no-commas>] */
{
    SendCommand("Clear\n");
}

void BranchApp::GuiReset() /* Gui Reset Tabs, Todo:add arguments */
{
    fprintf(stderr,"BranchApp::GuiReset(), Todo: add arguments if needed\n");
    SendCommand("GuiReset\n");
}

void BranchApp::Refresh() /* Gui Refresh, Todo:add arguments */
{
    fprintf(stderr,"BranchApp::Refresh(), Todo: add arguments if needed\n");
    SendCommand("Refresh\n");
}

void BranchApp::Run(bool runOnceFlag) /* Run [Once] [<active-runobj-list-no-commas>] */
{
    SendCommand("Run%s\n",runOnceFlag?" Once":"");
}

void BranchApp::Stop() /* Stop [<running-runobj-list-no-commas>] */
{
    SendCommand("Stop\n");
}


/* ================================================================ */

char* BranchConst::getOptions(char *buffer,int buflen) /* Option Code */
{
    return QueryResponse(buffer,buflen,"Options?\n");
}

char* BranchConst::getSN(char *buffer,int buflen) /* Serial Number */
{
    return QueryResponse(buffer,buflen,"SN?\n");
}

/* ================================================================ */

char* BranchFile::getDir(char *buffer,int buflen) /* Current Directory */
{
    return QueryResponse(buffer,buflen,"Dir?\n");
}

void BranchFile::setDir(const char* newValue) /* Current Directory */
{
    SendCommand("Dir \"%s\"\n",newValue);
}

char* BranchFile::Checksum(char *buffer,int buflen, char *filepath) /* Checksum File */
{
    return QueryResponse(buffer,buflen,"Checksum \"%s\"\n",filepath);
}

void BranchFile::Copy(char *frompath, char *topath) /* Copy File */
{
    SendCommand("Copy \"%s\" \"%s\"\n",frompath,topath);
}

void BranchFile::Del(char *filepath) /* Delete File, Todo:add arguments */
{
    SendCommand("Del \"%s\"\n",filepath);
}

char* BranchFile::Exists(char *buffer,int buflen, char *filepath) /* File Exists */
{
    return QueryResponse(buffer,buflen,"Exists \"%s\"\n",filepath);
}

char *BranchFile::Fetch(char *filepath, int *pcount) /* Fetch File - Must free() return value, Todo:add arguments */
{
    return QueryBinaryResponse(pcount,"Fetch \"%s\"\n",filepath);
}

void BranchFile::Length(char *filepath) /* File Length, Todo:add arguments */
{
    SendCommand("Length \"%s\"\n",filepath);
}

char *BranchFile::List(char *dirpath) /* List Directory - Must free() return value, Todo:add arguments */
{
    return QueryBinaryResponse(0,"List \"%s\"\n",dirpath);
}

void BranchFile::Rename(char *frompath, char *topath) /* Rename File, Todo:add arguments */
{
    fprintf(stderr,"BranchFile::Rename(), Todo: add arguments if needed\n");
    SendCommand("Rename \"%s\" \"%s\"\n",frompath,topath);
}

void BranchFile::XferBuffer() /* Transmit next buffer to device-requires count, optional checksum, Todo:add arguments */
{
    fprintf(stderr,"BranchFile::XferBuffer(), Todo: add arguments if needed\n");
    SendCommand("Xfer:Buffer\n");
}

void BranchFile::XferDoneGet() /* Indicates completion of get operation, Todo:add arguments */
{
    fprintf(stderr,"BranchFile::XferDoneGet(), Todo: add arguments if needed\n");
    SendCommand("Xfer:DoneGet\n");
}

void BranchFile::XferDonePut() /* Indicates completion of send operation, Todo:add arguments */
{
    fprintf(stderr,"BranchFile::XferDonePut(), Todo: add arguments if needed\n");
    SendCommand("Xfer:DonePut\n");
}

void BranchFile::XferGet() /* Get file for transfer-respond filename, length, date, time, Todo:add arguments */
{
    fprintf(stderr,"BranchFile::XferGet(), Todo: add arguments if needed\n");
    SendCommand("Xfer:Get\n");
}

void BranchFile::XferNext() /* Retrieve next buffer-respond three u32 values, Todo:add arguments */
{
    fprintf(stderr,"BranchFile::XferNext(), Todo: add arguments if needed\n");
    SendCommand("Xfer:Next\n");
}

void BranchFile::XferPut() /* Put file-requires filepath and optional modification date and time, Todo:add arguments */
{
    fprintf(stderr,"BranchFile::XferPut(), Todo: add arguments if needed\n");
    SendCommand("Xfer:Put\n");
}

void BranchFile::XferResend() /* Retrieve last buffer--respond three u32 values, Todo:add arguments */
{
    fprintf(stderr,"BranchFile::XferResend(), Todo: add arguments if needed\n");
    SendCommand("Xfer:Resend\n");
}

void BranchFile::XferSameBuffer() /* Re-transmit same buffer to device-requires count, optional checksum, Todo:add arguments */
{
    fprintf(stderr,"BranchFile::XferSameBuffer(), Todo: add arguments if needed\n");
    SendCommand("Xfer:SameBuffer\n");
}

/* ================================================================ */

char* BranchPatt::getFile(int index,char *buffer,int buflen) /* User pattern filename */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse(buffer,buflen,"File[%d]?\n",index);
}

char* BranchPatt::getFolder(char *buffer,int buflen) /* Current folder */
{
    return QueryResponse(buffer,buflen,"Folder?\n");
}

void BranchPatt::setFolder(const char* newValue) /* Current folder */
{
    SendCommand("Folder \"%s\"\n",newValue);
}

const char *BranchPatt::GuiCh_Strings[] =
{
    "Ch0",
    "Ch1",
    "Dual",
    0
};

BranchPatt::GuiCh BranchPatt::getGuiCh()
{
    return (GuiCh)QueryResponse_enum(GuiCh_Strings,"GuiCh?\n");
}

void BranchPatt::setGuiCh(GuiCh newValue )
{
    SendCommand("GuiCh \"%s\"\n",GuiCh_Strings[(int)newValue]);
}

const char *BranchPatt::GuiFormat_Strings[] =
{
    "Hex",
    "Decimal",
    "Octal",
    "Binary",
    0
};

BranchPatt::GuiFormat BranchPatt::getGuiFormat()
{
    return (GuiFormat)QueryResponse_enum(GuiFormat_Strings,"GuiFormat?\n");
}

void BranchPatt::setGuiFormat(GuiFormat newValue )
{
    SendCommand("GuiFormat \"%s\"\n",GuiFormat_Strings[(int)newValue]);
}

int BranchPatt::getGuiSymbols() /* Gui number of symbols */
{
    return QueryResponse_int("GuiSymbols?\n");
}

void BranchPatt::setGuiSymbols(int newValue) /* Gui number of symbols */
{
    SendCommand("GuiSymbols %d\n",newValue);
}

int BranchPatt::getGuiSymbolSize() /* Gui bits per symbol */
{
    return QueryResponse_int("GuiSymbolSize?\n");
}

void BranchPatt::setGuiSymbolSize(int newValue) /* Gui bits per symbol */
{
    SendCommand("GuiSymbolSize %d\n",newValue);
}

const char *BranchPatt::GuiType_Strings[] =
{
    "All",
    "Pattern",
    "Playlist",
    0
};

BranchPatt::GuiType BranchPatt::getGuiType()
{
    return (GuiType)QueryResponse_enum(GuiType_Strings,"GuiType?\n");
}

void BranchPatt::setGuiType(GuiType newValue )
{
    SendCommand("GuiType \"%s\"\n",GuiType_Strings[(int)newValue]);
}

int BranchPatt::getRestoreBitShift(int index) /* Restore bit shift */
{
    if(index<0||index>=3) throw "[Index_Out_Of_Range]";
    return QueryResponse_int("RestoreBitShift[%d]?\n",index);
}

void BranchPatt::setRestoreBitShift(int index,int newValue) /* Restore bit shift */
{
    if(index<0||index>=3) throw "[Index_Out_Of_Range]";
    SendCommand("RestoreBitShift[%d] %d\n",index,newValue);
}

char* BranchPatt::getRestoreFile(int index,char *buffer,int buflen) /* Restore user pattern files */
{
    if(index<0||index>=3) throw "[Index_Out_Of_Range]";
    return QueryResponse(buffer,buflen,"RestoreFile[%d]?\n",index);
}

void BranchPatt::setRestoreFile(int index,const char* newValue) /* Restore user pattern files */
{
    if(index<0||index>=3) throw "[Index_Out_Of_Range]";
    SendCommand("RestoreFile[%d] \"%s\"\n",index,newValue);
}

char* BranchPatt::getRootFolder(char *buffer,int buflen) /* User Patterns root folder */
{
    return QueryResponse(buffer,buflen,"RootFolder?\n");
}

char* BranchPatt::getStatusMsg(char *buffer,int buflen) /* Status message */
{
    return QueryResponse(buffer,buflen,"StatusMsg?\n");
}

char* BranchPatt::getVerifyMsg(char *buffer,int buflen) /* Verify message */
{
    return QueryResponse(buffer,buflen,"VerifyMsg?\n");
}

void BranchPatt::ClearStatusMsg() /* Clear status message, Todo:add arguments */
{
    fprintf(stderr,"BranchPatt::ClearStatusMsg(), Todo: add arguments if needed\n");
    SendCommand("ClearStatusMsg\n");
}

void BranchPatt::ClearVerifyMsg() /* Clear verify message, Todo:add arguments */
{
    fprintf(stderr,"BranchPatt::ClearVerifyMsg(), Todo: add arguments if needed\n");
    SendCommand("ClearVerifyMsg\n");
}

void BranchPatt::Copy() /* File copy, Todo:add arguments */
{
    fprintf(stderr,"BranchPatt::Copy(), Todo: add arguments if needed\n");
    SendCommand("Copy\n");
}

void BranchPatt::Delete() /* File delete, Todo:add arguments */
{
    fprintf(stderr,"BranchPatt::Delete(), Todo: add arguments if needed\n");
    SendCommand("Delete\n");
}

const char *BranchPatt::PatternChannel_Strings[] = {"Ch0","Ch1","Dual",0};

void BranchPatt::Deploy( PatternChannel ch, const char *filename, int bitShift ) /* Deploy pattern */
{
    SendCommand("Deploy %s %d \"%s\"\n",PatternChannel_Strings[(int)ch], bitShift, filename );
}

char *BranchPatt::Fetch(int *pcount) /* Fetch file - Must free() return value, Todo:add arguments */
{
    fprintf(stderr,"BranchPatt::Fetch(), Todo: add arguments if needed\n");
    return QueryBinaryResponse(pcount,"Fetch\n");
}

char *BranchPatt::FetchDir() /* Fetch directory - Must free() return value, Todo:add arguments */
{
    fprintf(stderr,"BranchPatt::FetchDir(), Todo: add arguments if needed\n");
    return QueryBinaryResponse(0,"FetchDir\n");
}

void BranchPatt::Grab() /* Grab pattern, Todo:add arguments */
{
    fprintf(stderr,"BranchPatt::Grab(), Todo: add arguments if needed\n");
    SendCommand("Grab\n");
}

void BranchPatt::NewFolder() /* New folder, Todo:add arguments */
{
    fprintf(stderr,"BranchPatt::NewFolder(), Todo: add arguments if needed\n");
    SendCommand("NewFolder\n");
}

void BranchPatt::Rename() /* File rename, Todo:add arguments */
{
    fprintf(stderr,"BranchPatt::Rename(), Todo: add arguments if needed\n");
    SendCommand("Rename\n");
}

void BranchPatt::Save() /* File save, Todo:add arguments */
{
    fprintf(stderr,"BranchPatt::Save(), Todo: add arguments if needed\n");
    SendCommand("Save\n");
}

void BranchPatt::Verify() /* Verify file, Todo:add arguments */
{
    fprintf(stderr,"BranchPatt::Verify(), Todo: add arguments if needed\n");
    SendCommand("Verify\n");
}


/* ================================================================ */

double BranchSyn::getClockRateGHz() /* Internal clock rate */
{
    return QueryResponse_double("ClockRate?\n");
}

void BranchSyn::setClockRateGHz(double newValue) /* Internal clock rate */
{
    SendCommand("ClockRate %lf\n",newValue);
}

double BranchSyn::getDataRateGbps() /* Doubled clock rate */
{
    return QueryResponse_double("DataRate?\n");
}

void BranchSyn::setDataRateGbps(double newValue) /* Doubled clock rate */
{
    SendCommand("DataRate %lf\n",newValue);
}

const char *BranchSyn::Dest_Strings[] =
{
    "Ch0",
    "Ch1",
    "Calib",
    "Output",
    0
};

BranchSyn::Dest BranchSyn::getDest(int index)
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return (Dest)QueryResponse_enum(Dest_Strings,"Dest[%d]?\n",index);
}

void BranchSyn::setDest(int index,Dest newValue )
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    SendCommand("Dest[%d] \"%s\"\n",index,Dest_Strings[(int)newValue]);
}

const char *BranchSyn::DivCalib_Strings[] =
{
    "Div2",
    "Div4",
    "Div8",
    "Div16",
    0
};

BranchSyn::DivCalib BranchSyn::getDivCalib()
{
    return (DivCalib)QueryResponse_enum(DivCalib_Strings,"DivCalib?\n");
}

void BranchSyn::setDivCalib(DivCalib newValue )
{
    SendCommand("DivCalib \"%s\"\n",DivCalib_Strings[(int)newValue]);
}

const char *BranchSyn::DivOutput_Strings[] =
{
    "Div2",
    "Div4",
    "Div8",
    "Div16",
    0
};

BranchSyn::DivOutput BranchSyn::getDivOutput()
{
    return (DivOutput)QueryResponse_enum(DivOutput_Strings,"DivOutput?\n");
}

void BranchSyn::setDivOutput(DivOutput newValue )
{
    SendCommand("DivOutput \"%s\"\n",DivOutput_Strings[(int)newValue]);
}

int BranchSyn::getHwVersion() /* Hardware version */
{
    return QueryResponse_int("HwVersion?\n");
}

const char *BranchSyn::Led_Strings[] =
{
    "Auto",
    "Green",
    "Red",
    "Off",
    0
};

BranchSyn::Led BranchSyn::getLed(int index)
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return (Led)QueryResponse_enum(Led_Strings,"Led[%d]?\n",index);
}

void BranchSyn::setLed(int index,Led newValue )
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("Led[%d] \"%s\"\n",index,Led_Strings[(int)newValue]);
}

bool BranchSyn::getLockDetect() /* Synthesizer Lock detected */
{
    return QueryResponse_bool("LockDetect?\n");
}

double BranchSyn::getOpRateGHz() /* Operating clock rate, -1 means not set */
{
    return QueryResponse_double("OpRate?\n");
}

void BranchSyn::setOpRateGHz(double newValue) /* Operating clock rate, -1 means not set */
{
    SendCommand("OpRate %lf\n",newValue);
}

const char *BranchSyn::RefSource_Strings[] =
{
    "IntRef",
    "ExtRef",
    0
};

BranchSyn::RefSource BranchSyn::getRefSource()
{
    return (RefSource)QueryResponse_enum(RefSource_Strings,"RefSource?\n");
}

void BranchSyn::setRefSource(RefSource newValue )
{
    SendCommand("RefSource \"%s\"\n",RefSource_Strings[(int)newValue]);
}

const char *BranchSyn::Source_Strings[] =
{
    "Internal",
    "ExtA",
    "ExtB",
    0
};

BranchSyn::Source BranchSyn::getSource(int index)
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return (Source)QueryResponse_enum(Source_Strings,"Source[%d]?\n",index);
}

void BranchSyn::setSource(int index,Source newValue )
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    SendCommand("Source[%d] \"%s\"\n",index,Source_Strings[(int)newValue]);
}

void BranchSyn::Map() /* Map clock source to destination(s), Todo:add arguments */
{
    fprintf(stderr,"BranchSyn::Map(), Todo: add arguments if needed\n");
    SendCommand("Map\n");
}

/* ================================================================ */

char* BranchSys::getBuild(char *buffer,int buflen) /* Software Build */
{
    return QueryResponse(buffer,buflen,"Build?\n");
}

char* BranchSys::getCheckDNS(char *buffer,int buflen) /* DNS Check of bitwiselaboratories.com */
{
    return QueryResponse(buffer,buflen,"CheckDNS?\n");
}

char* BranchSys::getCompile(char *buffer,int buflen) /* Compile type */
{
    return QueryResponse(buffer,buflen,"Compile?\n");
}

char* BranchSys::getGateway(char *buffer,int buflen) /* Gateway */
{
    return QueryResponse(buffer,buflen,"Gateway?\n");
}

char* BranchSys::getHostname(char *buffer,int buflen) /* Hostname */
{
    return QueryResponse(buffer,buflen,"Hostname?\n");
}

char* BranchSys::getIP(char *buffer,int buflen) /* IP Address */
{
    return QueryResponse(buffer,buflen,"IP?\n");
}

char* BranchSys::getNickname(char *buffer,int buflen) /* System nickname */
{
    return QueryResponse(buffer,buflen,"Nickname?\n");
}

void BranchSys::setNickname(const char* newValue) /* System nickname */
{
    SendCommand("Nickname \"%s\"\n",newValue);
}

double BranchSys::getPmuTempC() /* PMU Temperature */
{
    return QueryResponse_double("PmuTemp?\n");
}

char* BranchSys::getProtoVer(char *buffer,int buflen) /* Protocol Version */
{
    return QueryResponse(buffer,buflen,"ProtoVer?\n");
}

bool BranchSys::getShowSettings() /* Show Settings */
{
    return QueryResponse_bool("ShowSettings?\n");
}

void BranchSys::setShowSettings(bool newValue) /* Show Settings */
{
    SendCommand("ShowSettings %c\n",newValue?'T':'F');
}

int BranchSys::getUsers() /* Number of users */
{
    return QueryResponse_int("Users?\n");
}


