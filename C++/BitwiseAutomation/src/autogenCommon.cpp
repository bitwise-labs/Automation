/* autogenCommon.cpp */
//================================================================================
// BOOST SOFTWARE LICENSE
//
// Copyright 2020 BitWise Laboratories Inc.
// Author.......Jim Waschura
// Contact......info@bitwiselabs.com
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.
//================================================================================

#include <stdio.h> /* fprintf, stderr */

#include "autogenCommon.h"

/* ================================================================ */

char* BranchApp::getList(char *buffer,int buflen) /* List of all applications */
{
    return QueryResponse(buffer,buflen,"List?\n");
}

char* BranchApp::getRunActive(char *buffer,int buflen) /* List of active run objects */
{
    return QueryResponse(buffer,buflen,"RunActive?\n");
}

char* BranchApp::getRunDurLimit(char *buffer,int buflen) /* Run Duration Limit */
{
    return QueryResponse(buffer,buflen,"RunDurLimit?\n");
}

void BranchApp::setRunDurLimit(const char* newValue) /* Run Duration Limit */
{
    SendCommand("RunDurLimit \"%s\"\n",newValue);
}

char* BranchApp::getRunList(char *buffer,int buflen) /* List of all run objects */
{
    return QueryResponse(buffer,buflen,"RunList?\n");
}

char* BranchApp::getRunState(char *buffer,int buflen) /* List of all run object states */
{
    return QueryResponse(buffer,buflen,"RunState?\n");
}

int BranchApp::getSequence() /* Gui Sequence */
{
    return QueryResponse_int("Sequence?\n");
}

bool BranchApp::getShowNav() /* Show Navigation Toolbar */
{
    return QueryResponse_bool("ShowNav?\n");
}

void BranchApp::setShowNav(bool newValue) /* Show Navigation Toolbar */
{
    SendCommand("ShowNav %c\n",newValue?'T':'F');
}

bool BranchApp::getShowText() /* Show Text on GUI */
{
    return QueryResponse_bool("ShowText?\n");
}

void BranchApp::setShowText(bool newValue) /* Show Text on GUI */
{
    SendCommand("ShowText %c\n",newValue?'T':'F');
}

char* BranchApp::getTab(char *buffer,int buflen) /* Application Tab */
{
    return QueryResponse(buffer,buflen,"Tab?\n");
}

void BranchApp::setTab(const char* newValue) /* Application Tab */
{
    SendCommand("Tab \"%s\"\n",newValue);
}

void BranchApp::Clear() /* Clear all applications */
{
    SendCommand("Clear\n");
}

void BranchApp::GuiReset() /* Gui Reset Tabs */
{
    SendCommand("GuiReset\n");
}

void BranchApp::Refresh() /* Gui Refresh */
{
    SendCommand("Refresh\n");
}

void BranchApp::Run(bool runOnceFlag)
{
    SendCommand("Run%s\n",runOnceFlag?" Once":"");
}

void BranchApp::Stop()
{
    SendCommand("Stop\n");
}


/* ================================================================ */

char* BranchConst::getOptions(char *buffer,int buflen) /* Option Code */
{
    return QueryResponse(buffer,buflen,"Options?\n");
}

char* BranchConst::getSN(char *buffer,int buflen) /* Serial Number */
{
    return QueryResponse(buffer,buflen,"SN?\n");
}

/* ================================================================ */

char* BranchPatt::getFile(int index,char *buffer,int buflen) /* User pattern filename */
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return QueryResponse(buffer,buflen,"File[%d]?\n",index);
}

char* BranchPatt::getFolder(char *buffer,int buflen) /* Current folder */
{
    return QueryResponse(buffer,buflen,"Folder?\n");
}

void BranchPatt::setFolder(const char* newValue) /* Current folder */
{
    SendCommand("Folder \"%s\"\n",newValue);
}

const char *BranchPatt::GuiCh_Strings[] =
{
    "Ch0",
    "Ch1",
    "Dual",
    0
};

BranchPatt::GuiCh BranchPatt::getGuiCh()
{
    return (GuiCh)QueryResponse_enum(GuiCh_Strings,"GuiCh?\n");
}

void BranchPatt::setGuiCh(GuiCh newValue )
{
    SendCommand("GuiCh \"%s\"\n",GuiCh_Strings[(int)newValue]);
}

const char *BranchPatt::GuiFormat_Strings[] =
{
    "Hex",
    "Decimal",
    "Octal",
    "Binary",
    0
};

BranchPatt::GuiFormat BranchPatt::getGuiFormat()
{
    return (GuiFormat)QueryResponse_enum(GuiFormat_Strings,"GuiFormat?\n");
}

void BranchPatt::setGuiFormat(GuiFormat newValue )
{
    SendCommand("GuiFormat \"%s\"\n",GuiFormat_Strings[(int)newValue]);
}

int BranchPatt::getGuiSymbols() /* Gui number of symbols */
{
    return QueryResponse_int("GuiSymbols?\n");
}

void BranchPatt::setGuiSymbols(int newValue) /* Gui number of symbols */
{
    SendCommand("GuiSymbols %d\n",newValue);
}

int BranchPatt::getGuiSymbolSize() /* Gui bits per symbol */
{
    return QueryResponse_int("GuiSymbolSize?\n");
}

void BranchPatt::setGuiSymbolSize(int newValue) /* Gui bits per symbol */
{
    SendCommand("GuiSymbolSize %d\n",newValue);
}

const char *BranchPatt::GuiType_Strings[] =
{
    "All",
    "Pattern",
    "Playlist",
    0
};

BranchPatt::GuiType BranchPatt::getGuiType()
{
    return (GuiType)QueryResponse_enum(GuiType_Strings,"GuiType?\n");
}

void BranchPatt::setGuiType(GuiType newValue )
{
    SendCommand("GuiType \"%s\"\n",GuiType_Strings[(int)newValue]);
}

int BranchPatt::getRestoreBitShift(int index) /* Restore bit shift */
{
    if(index<0||index>=3) throw "[Index_Out_Of_Range]";
    return QueryResponse_int("RestoreBitShift[%d]?\n",index);
}

void BranchPatt::setRestoreBitShift(int index,int newValue) /* Restore bit shift */
{
    if(index<0||index>=3) throw "[Index_Out_Of_Range]";
    SendCommand("RestoreBitShift[%d] %d\n",index,newValue);
}

char* BranchPatt::getRestoreFile(int index,char *buffer,int buflen) /* Restore user pattern files */
{
    if(index<0||index>=3) throw "[Index_Out_Of_Range]";
    return QueryResponse(buffer,buflen,"RestoreFile[%d]?\n",index);
}

void BranchPatt::setRestoreFile(int index,const char* newValue) /* Restore user pattern files */
{
    if(index<0||index>=3) throw "[Index_Out_Of_Range]";
    SendCommand("RestoreFile[%d] \"%s\"\n",index,newValue);
}

char* BranchPatt::getRootFolder(char *buffer,int buflen) /* User Patterns root folder */
{
    return QueryResponse(buffer,buflen,"RootFolder?\n");
}

char* BranchPatt::getStatusMsg(char *buffer,int buflen) /* Status message */
{
    return QueryResponse(buffer,buflen,"StatusMsg?\n");
}

char* BranchPatt::getVerifyMsg(char *buffer,int buflen) /* Verify message */
{
    return QueryResponse(buffer,buflen,"VerifyMsg?\n");
}

void BranchPatt::ClearStatusMsg() /* Clear status message */
{
    SendCommand("ClearStatusMsg\n");
}

void BranchPatt::ClearVerifyMsg() /* Clear verify message */
{
    SendCommand("ClearVerifyMsg\n");
}

void BranchPatt::Copy(const char *fromPath, const char *toPath) /* File copy*/
{
     SendCommand("Copy \"%s\" \"%s\"\n" ,fromPath,toPath);
}

void BranchPatt::Delete(const char *filePath) /* File delete */
{
     SendCommand("Delete \"%s\"\n");
}

const char *BranchPatt::PatternChannel_Strings[] = {"Ch0","Ch1","Dual",0};

void BranchPatt::Deploy( PatternChannel ch, const char *filename, int bitShift ) /* Deploy pattern */
{
    SendCommand("Deploy %s %d \"%s\"\n",PatternChannel_Strings[(int)ch], bitShift, filename );
}

char *BranchPatt::Fetch(const char *filePath, int *pcount) /* Fetch file - Must free() return value, */
{
    return QueryBinaryResponse(pcount,"Fetch \"%s\"\n",filePath);
}

char *BranchPatt::FetchDir( const char *pathName, GuiType optionalType ) /* Fetch directory - Must free() return value */
{
    return QueryBinaryResponse(
    	0,
		"FetchDir \"%s\" %s\n",
		pathName,
    	GuiType_Strings[(int)optionalType]
		);
}

void BranchPatt::Grab( PatternChannel ch, int symSize, GuiFormat fmt, const char *filePath ) /* Grab pattern */
{
    SendCommand("Grab %s %d %s \"%s\"\n",
    		PatternChannel_Strings[(int)ch],
			symSize,
			GuiFormat_Strings[(int)fmt],
			filePath
			);
}

void BranchPatt::NewFolder(const char *folderPath) /* New folder */
{
    SendCommand("NewFolder \"%s\"\n",folderPath);
}

void BranchPatt::Rename(const char *fromPath, const char *toName) /* File rename */
{
    SendCommand("Rename \"%s\" \"%s\"\n" ,fromPath,toName);
}

void BranchPatt::Save(const char *filePath) /* File save */
{
    SendCommand("Save \"%s\"\n",filePath);
}

void BranchPatt::Verify(const char *filePath) /* Verify file */
{
    SendCommand("Verify \"%s\"\n",filePath);
}

/* ================================================================ */

double BranchSyn::getClockRateGHz() /* Internal clock rate */
{
    return QueryResponse_double("ClockRate?\n");
}

void BranchSyn::setClockRateGHz(double newValue) /* Internal clock rate */
{
    SendCommand("ClockRate %lf\n",newValue);
}

double BranchSyn::getDataRateGbps() /* Doubled clock rate */
{
    return QueryResponse_double("DataRate?\n");
}

void BranchSyn::setDataRateGbps(double newValue) /* Doubled clock rate */
{
    SendCommand("DataRate %lf\n",newValue);
}

const char *BranchSyn::Dest_Strings[] =
{
    "Ch0",
    "Ch1",
    "Calib",
    "Output",
    0
};

BranchSyn::Dest BranchSyn::getDest(int index)
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return (Dest)QueryResponse_enum(Dest_Strings,"Dest[%d]?\n",index);
}

void BranchSyn::setDest(int index,Dest newValue )
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    SendCommand("Dest[%d] \"%s\"\n",index,Dest_Strings[(int)newValue]);
}

const char *BranchSyn::DivCalib_Strings[] =
{
    "Div2",
    "Div4",
    "Div8",
    "Div16",
    0
};

BranchSyn::DivCalib BranchSyn::getDivCalib()
{
    return (DivCalib)QueryResponse_enum(DivCalib_Strings,"DivCalib?\n");
}

void BranchSyn::setDivCalib(DivCalib newValue )
{
    SendCommand("DivCalib \"%s\"\n",DivCalib_Strings[(int)newValue]);
}

const char *BranchSyn::DivOutput_Strings[] =
{
    "Div2",
    "Div4",
    "Div8",
    "Div16",
    0
};

BranchSyn::DivOutput BranchSyn::getDivOutput()
{
    return (DivOutput)QueryResponse_enum(DivOutput_Strings,"DivOutput?\n");
}

void BranchSyn::setDivOutput(DivOutput newValue )
{
    SendCommand("DivOutput \"%s\"\n",DivOutput_Strings[(int)newValue]);
}

int BranchSyn::getHwVersion() /* Hardware version */
{
    return QueryResponse_int("HwVersion?\n");
}

const char *BranchSyn::Led_Strings[] =
{
    "Auto",
    "Green",
    "Red",
    "Off",
    0
};

BranchSyn::Led BranchSyn::getLed(int index)
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    return (Led)QueryResponse_enum(Led_Strings,"Led[%d]?\n",index);
}

void BranchSyn::setLed(int index,Led newValue )
{
    if(index<0||index>=2) throw "[Index_Out_Of_Range]";
    SendCommand("Led[%d] \"%s\"\n",index,Led_Strings[(int)newValue]);
}

bool BranchSyn::getLockDetect() /* Synthesizer Lock detected */
{
    return QueryResponse_bool("LockDetect?\n");
}

double BranchSyn::getOpRateGHz() /* Operating clock rate, -1 means not set */
{
    return QueryResponse_double("OpRate?\n");
}

void BranchSyn::setOpRateGHz(double newValue) /* Operating clock rate, -1 means not set */
{
    SendCommand("OpRate %lf\n",newValue);
}

const char *BranchSyn::RefSource_Strings[] =
{
    "IntRef",
    "ExtRef",
    0
};

BranchSyn::RefSource BranchSyn::getRefSource()
{
    return (RefSource)QueryResponse_enum(RefSource_Strings,"RefSource?\n");
}

void BranchSyn::setRefSource(RefSource newValue )
{
    SendCommand("RefSource \"%s\"\n",RefSource_Strings[(int)newValue]);
}

const char *BranchSyn::Source_Strings[] =
{
    "Internal",
    "ExtA",
    "ExtB",
    0
};

BranchSyn::Source BranchSyn::getSource(int index)
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    return (Source)QueryResponse_enum(Source_Strings,"Source[%d]?\n",index);
}

void BranchSyn::setSource(int index,Source newValue )
{
    if(index<0||index>=4) throw "[Index_Out_Of_Range]";
    SendCommand("Source[%d] \"%s\"\n",index,Source_Strings[(int)newValue]);
}

void BranchSyn::Map(Source clockSource, Dest clockDest) /* Map clock source to destination(s) */
{
    SendCommand("Map %s %s\n",
    	Source_Strings[(int)clockSource],
    	Dest_Strings[(int)clockDest]
		);
}

/* ================================================================ */

char* BranchSys::getBuild(char *buffer,int buflen) /* Software Build */
{
    return QueryResponse(buffer,buflen,"Build?\n");
}

char* BranchSys::getCheckDNS(char *buffer,int buflen) /* DNS Check of bitwiselaboratories.com */
{
    return QueryResponse(buffer,buflen,"CheckDNS?\n");
}

char* BranchSys::getCompile(char *buffer,int buflen) /* Compile type */
{
    return QueryResponse(buffer,buflen,"Compile?\n");
}

char* BranchSys::getGateway(char *buffer,int buflen) /* Gateway */
{
    return QueryResponse(buffer,buflen,"Gateway?\n");
}

char* BranchSys::getHostname(char *buffer,int buflen) /* Hostname */
{
    return QueryResponse(buffer,buflen,"Hostname?\n");
}

char* BranchSys::getArchitecture(char *buffer,int buflen) /* Architecture */
{
    return QueryResponse(buffer,buflen,"Architecture?\n");
}

char* BranchSys::getIP(char *buffer,int buflen) /* IP Address */
{
    return QueryResponse(buffer,buflen,"IP?\n");
}

char* BranchSys::getNickname(char *buffer,int buflen) /* System nickname */
{
    return QueryResponse(buffer,buflen,"Nickname?\n");
}

void BranchSys::setNickname(const char* newValue) /* System nickname */
{
    SendCommand("Nickname \"%s\"\n",newValue);
}

double BranchSys::getPmuTempC() /* PMU Temperature */
{
    return QueryResponse_double("PmuTemp?\n");
}

char* BranchSys::getProtoVer(char *buffer,int buflen) /* Protocol Version */
{
    return QueryResponse(buffer,buflen,"ProtoVer?\n");
}

bool BranchSys::getShowSettings() /* Show Settings */
{
    return QueryResponse_bool("ShowSettings?\n");
}

void BranchSys::setShowSettings(bool newValue) /* Show Settings */
{
    SendCommand("ShowSettings %c\n",newValue?'T':'F');
}

int BranchSys::getUsers() /* Number of users */
{
    return QueryResponse_int("Users?\n");
}


/* ================================================================ */

char* BranchFile::getDir(char *buffer,int buflen) /* Current Directory */
{
    return QueryResponse(buffer,buflen,"Dir?\n");
}

void BranchFile::setDir(const char* newValue) /* Current Directory */
{
    SendCommand("Dir \"%s\"\n",newValue);
}

char* BranchFile::Checksum(char *buffer,int buflen, char *filepath) /* Checksum File */
{
    return QueryResponse(buffer,buflen,"Checksum \"%s\"\n",filepath);
}

void BranchFile::Copy(char *frompath, char *topath) /* Copy File */
{
    SendCommand("Copy \"%s\" \"%s\"\n",frompath,topath);
}

void BranchFile::Del(char *filepath) /* Delete File */
{
    SendCommand("Del \"%s\"\n",filepath);
}

bool BranchFile::Exists( char *filepath) /* File Exists */
{
    return QueryResponse_bool("Exists \"%s\"\n",filepath);
}

char *BranchFile::Fetch(char *filepath, int *pcount) /* Fetch File - Must free() return value */
{
    return QueryBinaryResponse(pcount,"Fetch \"%s\"\n",filepath);
}

int BranchFile::Length(char *filepath) /* File Length */
{
    return QueryResponse_int("Length \"%s\"\n",filepath);
}

char *BranchFile::List(char *dirpath, char *otheroptions) /* List Directory - Must free() return value */
{
    return QueryBinaryResponse(0,"List \"%s\" %s\n",dirpath, otheroptions);
}

void BranchFile::Rename(char *frompath, char *topath) /* Rename File */
{
    SendCommand("Rename \"%s\" \"%s\"\n",frompath,topath);
}

/* ================================================================ */

char* BranchAnnounce::getMsg(char *buffer,int buflen) /* Message */
{
    return QueryResponse(buffer,buflen,"Msg?\n");
}

void BranchAnnounce::setMsg(const char* newValue) /* Message */
{
    SendCommand("Msg \"%s\"\n",newValue);
}

int BranchAnnounce::getSequence() /* Message sequence number */
{
    return QueryResponse_int("Sequence?\n");
}

void BranchAnnounce::Clear() /* Clear message, Todo:add arguments */
{
    SendCommand("Clear\n");
}

/* ================================================================ */

int BranchMem::getSeq() /* Serial number of blob contents */
{
    return QueryResponse_int("Seq?\n");
}

bool BranchMem::getVisible() /* Visibility of memory trace */
{
    return QueryResponse_bool("Visible?\n");
}

void BranchMem::setVisible(bool newValue) /* Visibility of memory trace */
{
    SendCommand("Visible %c\n",newValue?'T':'F');
}

void BranchMem::Capture() /* Capture memory from chart trace, Todo:add arguments */
{
    SendCommand("Capture\n");
}

void BranchMem::Clear() /* Clear memory, Todo:add arguments */
{
    SendCommand("Clear\n");
}

/* ================================================================ */

